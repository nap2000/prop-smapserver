/*
This file is part of SMAP.

SMAP is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SMAP is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

*/

var gWait = 0;		// This javascript file only
var gCache = {};
var gCacheGroup = {};
var gCacheStatusQuestions = {};
var gEligibleUser;


/*
 * Convert a choice list name into a valid jquery class name
 */
function jq(choiceList) {

	var c;

	c = choiceList.replace( /(:|\.|\[|\]|,)/g, "\\$1" );
	return c;
}

/* 
 * ==============================================================
 * Task Functions
 * ==============================================================
 */

function addPendingTask(taskId, assignmentId, status, source) {
	var i,
		duplicate = false,
		assignment;

	assignment = {
		assignment_id: assignmentId,
		assignment_status: status,
		task_id: taskId
	};
	globals.gPendingUpdates.push(assignment);

	if(source === "table") {
		updateMapTaskSelections(taskId, true);
	} else if(source === "map") {
		$('#tasks_table').find('[data-taskid=' + taskId + ']').prop("checked", true).closest('tr').addClass("info");
	}
}

function removePendingTask(taskId, source) {
	var i;
	for (i = 0; i < globals.gPendingUpdates.length; i++) {
		if(globals.gPendingUpdates[i].task_id === taskId) {
			globals.gPendingUpdates.splice(i,1);
			break;
		}
	}
	if(source === "table") {
		updateMapTaskSelections(taskId, false);
	} else if(source === "map") {
		$('#tasks_table').find('[data-taskid=' + taskId + ']').prop("checked", false).closest('tr').removeClass("info");
	}
}

/*
 * ===============================================================
 * Project Functions
 * ===============================================================
 */

/*
 * Update the list of available projects
 * Note when addAll is set to true the list is not used to change the default project
 *   In this case the value of the list should not be set to the default project
 */
function updateProjectList(addAll, projectId, callback) {

	var $projectSelect = $('.project_list'),
		i,
		h = [],
		idx = -1,
		updateCurrentProject = true;

	if(addAll) {
		h[++idx] = '<option value="0">' + localise.set["c_all"] + '</option>';
		updateCurrentProject = false;
	}
	for(i = 0; i < globals.gProjectList.length; i++) {
		h[++idx] = '<option value="';
		h[++idx] = globals.gProjectList[i].id;
		h[++idx] = '">';
		h[++idx] = htmlEncode(globals.gProjectList[i].name);
		h[++idx] = '</option>';

		if(globals.gProjectList[i].id === projectId) {
			updateCurrentProject = false;
		}
	}
	$projectSelect.empty().append(h.join(''));

	// If for some reason the user's default project is no longer available then
	//  set the default project to the first project in the list
	//  if the list is empty then set the default project to undefined
	if(updateCurrentProject && globals.gProjectList[0]) {
		globals.gCurrentProject = globals.gProjectList[0].id;		// Update the current project id
		globals.gCurrentSurvey = -1;
		globals.gCurrentTaskGroup = undefined;
	} else if(updateCurrentProject) {
		globals.gCurrentProject = -1;		// Update the current project id
		globals.gCurrentSurvey = -1;
		globals.gCurrentTaskGroup = undefined;
	}

	saveCurrentProject(globals.gCurrentProject,
		globals.gCurrentSurvey,
		globals.gCurrentTaskGroup);

	if(!addAll) {
		$projectSelect.val(globals.gCurrentProject);			// Set the initial project value
		$('#projectId').val(globals.gCurrentProject);			// Set the project value for the hidden field in template upload
	}

	if(typeof callback !== "undefined") {
		callback(globals.gCurrentProject);				// Call the callback with the correct current project
	}
}

/*
 * Get the list of available projects from the server
 */
function getMyProjects(projectId, callback, getAll) {
	addHourglass();
	$.ajax({
		url: "/surveyKPI/myProjectList",
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			globals.gProjectList = data;
			updateProjectList(getAll, projectId, callback);
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert("Error: Failed to get list of projects: " + err);
			}
		}
	});
}

/*
 * Save the time of the last alert for the user
 */
function saveLastAlert(lastAlert, seen) {

	var alertStatus = {
		lastalert: lastAlert,
		seen: seen
	}

	$.ajax({
		type: "POST",
		contentType: "application/json",
		url: "/surveyKPI/user/alertstatus",
		cache: false,
		data: {
			alertstatus: JSON.stringify(alertStatus)
		}
	});
}

/*
 * Save the current project id in the user defaults
 */
function saveCurrentProject(projectId, surveyId, taskGroupId) {

	if(surveyId > 0 || projectId > 0 || taskGroupId > 0) {

		var user = {
			current_project_id: projectId,
			current_survey_id: surveyId,
			current_task_group_id: taskGroupId
		};

		var userString = JSON.stringify(user);

		addHourglass();
		$.ajax({
			type: "POST",
			contentType: "application/json",
			url: "/surveyKPI/user/currentproject",
			cache: false,
			data: { user: userString },
			success: function(data, status) {
				removeHourglass();
			}, error: function(data, status) {
				removeHourglass();
			}
		});
	}
}

/*
 * Save the current relationship between survey and surveyGroup
 */
function saveCurrentGroupSurvey(surveyId, gs, fName) {

	if (surveyId > 0) {

		var groupSurvey = {
			sId: surveyId,
			groupIdent: gs,
			fName: fName
		};

		var groupString = JSON.stringify(groupSurvey);

		addHourglass();
		$.ajax({
			type: "POST",
			contentType: "application/json",
			url: "/surveyKPI/user/groupsurvey",
			cache: false,
			data: {groupSurvey: groupString},
			success: function (data, status) {
				removeHourglass();
			}, error: function (data, status) {
				removeHourglass();
			}
		});
	}
}

/*
 * ===============================================================
 * User Functions
 * ===============================================================
 */

/*
 * Add user details popup to the page
 * Legacy only used with non bootstrap pages - these should be replaced with bootstrap
 */
function addUserDetailsPopup() {
	var
		h =[],
		idx = -1;


	h[++idx] = '<div id="modify_me_popup" style="display:none;">';
	h[++idx] = '<div class="left_panel">';
	h[++idx] = '<form id="me_edit_form">';
	h[++idx] = '<label for="me_name">';
	h[++idx] = localise.set["c_name"];
	h[++idx] = '</label>';
	h[++idx] = '<input type="text" id="me_name" required><br/>';

	h[++idx] = '<label for="me_language">';
	h[++idx] = localise.set["c_lang"];
	h[++idx] = '</label>';
	h[++idx] = '<select class="language_select" id="me_language"></select><br/>';

	h[++idx] = '<label for="me_email">';
	h[++idx] = localise.set["c_email"];
	h[++idx] = '</label>';
	h[++idx] = '<input type="text" id="me_email" pattern="^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$"><br/>';

	h[++idx] = '<label for="me_organisation">';
	h[++idx] = localise.set["c_org"];
	h[++idx] = '</label>';
	h[++idx] = '<select class="organisation_select" id="me_organisation"></select><br/>';

	h[++idx] = '<label for="me_enterprise">';
	h[++idx] = localise.set["c_ent"];
	h[++idx] = '</label>';
	h[++idx] = '<div id="me_enterprise"></div><br/>';

	h[++idx] = '<label for="u_tz">';
	h[++idx] = localise.set["c_tz"];
	h[++idx] = '</label>';
	h[++idx] = '<select class="timezone_select" id="u_tz"></select>';

	h[++idx] = '<span id="reset_me_password_fields" style="display:none;">';
	h[++idx] = '<label for="reset_me_password">';
	h[++idx] = localise.set["c_r_p"];
	h[++idx] = '</label>';
	h[++idx] = '<input type="checkbox" id="reset_me_password"/><br/>';
	h[++idx] = '</span>';

	h[++idx] =	'<span id="password_me_fields" style="display:none;">';
	h[++idx] = '<label for="me_password" data-lang="c_password" class="lang">';
	h[++idx] = localise.set["c_password"];
	h[++idx] = '</label>';
	h[++idx] = '<input id="me_password" type="password"><br/>';

	h[++idx] = '<label for="me_password_confirm" data-lang="c_c_p" class="lang">';
	h[++idx] = localise.set["c_password"];
	h[++idx] = '</label>';
	h[++idx] = '<input id="me_password_confirm" type="password"><br/>';
	h[++idx] = '</span>';
	h[++idx] = '</form>';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	$(document.body).append(h.join(''));

}

/*
 * Populate a language select widget
 */
function populateLanguageSelect(sId, $elem) {
	$.getJSON("/surveyKPI/languages/" + sId, function(data) {

		$elem.empty();
		$.each(data, function(j, item) {
			$elem.append('<option value="' + item + '">' + htmlEncode(item) + '</option>');
		});
	});
}

/*
 * Populate a pdf select widget
 * Set the template set as the default to be selected
 * If there is no default template and there is a template specified in settings (legacy) then set that as the default
 */
function populatePdfSelect(sId, $elem) {
	var url = "/surveyKPI/surveys/templates/" + sId;
	url += addCacheBuster(url);

	$.getJSON(url, function(data) {

		var defaultTemplateId,
			fromSettingsTemplateId;

		$elem.empty();
		$elem.append('<option value="-2">' + localise.set["c_auto"] + '</option>');
		$elem.append('<option value="-1">' + localise.set["c_none"] + '</option>');
		$.each(data, function(j, item) {
			if(item.default_template) {
				defaultTemplateId = item.id;
			} else if(item.fromSettings) {
				fromSettingsTemplateId = item.id;
			}
			$elem.append('<option value="' + item.id + '">' + htmlEncode(item.name) + '</option>');
		});
		if(typeof defaultTemplateId !== "undefined") {
			$elem.val(defaultTemplateId);
		} else if(typeof fromSettingsTemplateId !== "undefined") {
			$elem.val(fromSettingsTemplateId)
		} else {
			$elem.val(-2);		// Set to auto
		}

	});
}

/*
 * Add user details popup to the page
 */
function addUserDetailsPopupBootstrap4() {
	var	h =[],
		idx = -1;

	h[++idx] = '<div id="modify_me_popup" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="modifyMeLabel" aria-hidden="true">';
	h[++idx] = '<div class="modal-dialog modal-lg">';
	h[++idx] = '<div class="modal-content">';
	h[++idx] = '<div class="modal-header">';
	h[++idx] = '<h4 class="modal-title" id="modifyMeLabel"></h4>';
	h[++idx] = '<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>';
	h[++idx] = '</div>';    // modal-headers

	h[++idx] = '<div class="modal-body">';
	h[++idx] = '<form role="form" id="me_edit_form">';
	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_name" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_name"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<input type="text" id="me_name" required class="form-control">';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_language" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_lang"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<select id="me_language" class="language_select form-control"></select>';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_email" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_email"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<input type="email" class="form-control" id="me_email"';
	h[++idx] = ' placeholder="Enter email"';
	h[++idx] = ' pattern="^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$">';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_organisation" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_org"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<select id="me_organisation" class="organisation_select form-control"></select>';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_enterprise" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_ent"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<div id="me_enterprise" class="form-control"></div>';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="u_tz" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_tz"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<select class="form-control timezone_select" id="u_tz"></select>';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="d-none" id="reset_me_password_fields">';
	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label class="col-form-label col-sm-2">';
	h[++idx] = localise.set["c_r_p"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<div class="checkbox">';
	h[++idx] = '<input type="checkbox" id="reset_me_password">';
	h[++idx] = '</div>';        // checkbox
	h[++idx] = '</div>';        // col-sm-10
	h[++idx] = '</div>';        // form-group
	h[++idx] = '</div>';        // reset password fields

	h[++idx] = '<div class="d-none" id="password_me_fields">';
	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_password" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_password"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<input id="me_password" type="password" placeholder="Password" class="form-control">';
	h[++idx] = '</div>';
	h[++idx] = '</div>';

	h[++idx] = '<div class="form-group row">';
	h[++idx] = '<label for="me_password_confirm" class="col-sm-2 control-label">';
	h[++idx] = localise.set["c_c_p"];
	h[++idx] = '</label>';
	h[++idx] = '<div class="col-sm-10">';
	h[++idx] = '<input id="me_password_confirm" type="password" placeholder="Password" class="form-control">';
	h[++idx] = '</div>';  // around input
	h[++idx] = '</div>';  // form group
	h[++idx] = '</div>';  // password fields
	h[++idx] = '<div id="me_alert" class="alert d-none text-wrap text-break" role="alert"></div>';
	h[++idx] = '</form>';
	h[++idx] = '</div>';    // modal body

	h[++idx] = '<div class="modal-footer">';
	h[++idx] = '<button type="button" class="btn btn-default" data-dismiss="modal">';
	h[++idx] = localise.set["c_close"];
	h[++idx] = '</button>';

	h[++idx] = '<button id="userProfileLogout"type="button" class="btn btn-default" data-dismiss="modal">';
	h[++idx] = localise.set["c_logout"];
	h[++idx] = '</button>';

	h[++idx] = '<button id="userProfileSave" type="button" class="btn btn-primary">';
	h[++idx] = localise.set["c_save"];
	h[++idx] = '</button>';
	h[++idx] = '</div>';    // modal - footer
	h[++idx] = '</div>';        // modal - content
	h[++idx] = '</div>';            // modal - dialog
	h[++idx] = '</div>';                // popup

	$(document.body).append(h.join(''));

	enableUserProfileBS();
}

/*
 * Update the user details on the page
 */
function updateUserDetails(data, getOrganisationsFn, getEnterprisesFn, getServerDetailsFn) {

	var groups = data.groups,
		i,
		bootstrap_enabled = (typeof $().modal == 'function');

	if(data.language && data.language !== gUserLocale) {
		try {
			localStorage.setItem('user_locale', data.language);  // Write to storage may be disabled
			location.reload();
		} catch (e) {

		}

	} else if(data.o_id != globals.gOrgId) {
		location.reload();
	}

	globals.gLoggedInUser = data;
	globals.gOrgId = data.o_id;

	if(bootstrap_enabled) {

		$('#modify_me_popup').on('show.bs.modal', function (event) {
			var $this = $(this)
			$this.find('.modal-title').text(data.ident + "@" + data.organisation_name)

			$("#me_alert").hide();

			$('#me_edit_form')[0].reset();
			$('#reset_me_password_fields').removeClass('d-none').show();
			$('#password_me_fields').hide();
			addLanguageOptions($('.language_select'), data.language);
			addOrganisationOptions($('.organisation_select'), data.o_id, data.orgs);
			$('#me_name').val(data.name);
			$('#me_email').val(data.email);
			$('#me_enterprise').text(globals.gEnterpriseName);
			$('#u_tz').val(globals.gTimezone);

			$(".navbar-collapse").removeClass("in").addClass("collapse");	// Remove drop down menu
		});


	} else {
		$('#username').text(data.name).button({ label: htmlEncode(data.name),
			icons: { primary: "ui-icon-person" }}).off().click(function(){
			$('#me_edit_form')[0].reset();

			$('#reset_me_password_fields').removeClass('d-none').show();
			$('#password_me_fields').hide();
			addLanguageOptions($('.language_select'), data.language);
			addOrganisationOptions($('.organisation_select'), data.o_id, data.orgs);
			$('#me_name').val(data.name);
			$('#me_email').val(data.email);
			$('#me_enterprise').text(globals.gEnterpriseName);
			$('#u_tz').val(globals.gTimezone);

			$('#modify_me_popup').dialog("option", "title", data.name + "@" + data.organisation_name);
			$('#modify_me_popup').dialog("open");
		});
	}

	/*
	 * Show restricted functions
	 */
	if(groups) {
		for(i = 0; i < groups.length; i++) {
			if(groups[i].id === globals.GROUP_ADMIN) {
				globals.gIsAdministrator = true;

                if(data.billing_enabled) {
                    globals.gOrgBillingData = true;
                }

			} else if(groups[i].id === globals.GROUP_ORG_ADMIN) {
				globals.gIsOrgAdministrator = true;
				globals.gBillingData = true;

			} else if(groups[i].id === globals.GROUP_SECURITY) {
				globals.gIsSecurityAdministrator = true;

			} else if(groups[i].id === globals.GROUP_ENTERPRISE) {
                globals.gIsEnterpriseAdministrator = true;
				globals.gBillingData = true;

            } else if(groups[i].id === globals.GROUP_ANALYST) {
				globals.gIsAnalyst = true;

			} else if(groups[i].id === globals.GROUP_DASHBOARD) {
				globals.gIsDashboard = true;

			} else if(groups[i].id === globals.GROUP_MANAGE) {
				globals.gIsManage = true;

			} else if(groups[i].id === globals.GROUP_ENUM) {
				globals.gIsEnum = true;

			} else if(groups[i].id === globals.GROUP_VIEW_DATA) {
                globals.gViewData = true;

            } else if(groups[i].id === globals.GROUP_MANAGE_TASKS) {
				globals.gManageTasks = true;

			} else if(groups[i].id === globals.GROUP_OWNER) {
                globals.gIsServerOwner = true;
            }
		}
	}

	// Only show items relevant to a user
	$('.restrict_role').hide();
	if(globals.gIsEnum) {
		$('.enum_role').removeClass('d-none').show();
	}
	if(globals.gIsAnalyst) {
		$('.analyst_role').removeClass('d-none').show();
	}
	if(globals.gIsDashboard) {
		$('.dashboard_role').removeClass('d-none').show();
	}
	if(globals.gViewData) {
		$('.data_role').removeClass('d-none').show();
	}
	if(globals.gManageTasks) {
		$('.task_role').show();
	}
	if(globals.gIsAdministrator) {
		$('.admin_role').removeClass('d-none').show();
	}
	if(globals.gIsManage) {
		$('.manage_role').removeClass('d-none').show();
	}
	if(globals.gIsSecurityAdministrator) {
		$('.security_role').removeClass('d-none').show();
	}
	if(globals.gIsOrgAdministrator) {  // Admins can see their personal organisations
		$('.org_role').removeClass('d-none').show();
	}
	if(globals.gIsOrgAdministrator || globals.gIsAdministrator) {  // Admins can see their personal organisations
		if(typeof getOrganisationsFn === "function") {
			getOrganisationsFn();
		}
	}
	if(globals.gIsEnterpriseAdministrator) {
		$('.enterprise_role').removeClass('d-none').show();
		if(typeof getEnterprisesFn === "function") {
			getEnterprisesFn();
		}
	}
	if(globals.gIsServerOwner) {
		$('.owner_role').removeClass('d-none').show();
		if(typeof getServerDetailsFn === "function") {
			getServerDetailsFn();
		}
	}

	if(globals.gTraining) {
		$('#train_link').prop("href", globals.gTraining);
		$('#m_training').removeClass('d-none').show();
	}

	//TODO set logic for enabling disabling billing
	if(isBusinessServer() && (globals.gBillingData || globals.gOrgBillingData)) {
		$('.billing_role').removeClass('d-none').show();
	}

	// Other conditional elements
	if(globals.gSendTrail === 'off') {
		$('.user_trail').hide();
	}

	// 	Customer configurable details - the configurable part is TODO
	$('#my_name').val(data.name);			// Add the name to the configurable list

	if(data.settings) {
		var userDetails = JSON.parse(data.settings);
		$('#my_title').val(userDetails.title);
		$('#my_license').val(userDetails.license);
		$('#my_signature').attr("src", "/surveyKPI/file/" + data.signature + "/users?type=sig");
	}

	// Hide any menus that have been disabled by custom java scripts
	$('.perm_dis_menu').hide();
}

function addLanguageOptions($elem, current) {

	var h = [],
		idx = -1,
		i,
		languages = [
			{
				locale: "ar",
				name: "Arabic"
			},
			{
				locale: "en",
				name: "English"
			},
			{
				locale: "fr",
				name: "French"
			},
			{
				locale: "hi",
				name: "Hindi"
			},
			{
				locale: "pt",
				name: "Portugese"
			},
			{
				locale: "es",
				name: "Spanish"
			}
		];

	for(i = 0; i < languages.length; i++) {
		h[++idx] = '<option value="';
		h[++idx] = languages[i].locale;
		h[++idx] = '">';
		h[++idx] = localise.set[languages[i].locale];
		h[++idx] = '</option>';
	}
	$elem.html(h.join(''));
	if(current) {
		$elem.val(current);
	} else {
		$elem.val("en");
	}
}

function addOrganisationOptions($elem, current, orgs) {

	var h = [],
		idx = -1,
		i;

	for(i = 0; i < orgs.length; i++) {
		h[++idx] = '<option value="';
		h[++idx] = orgs[i].id;
		h[++idx] = '">';
		h[++idx] = htmlEncode(orgs[i].name);
		h[++idx] = '</option>';
	}
	$elem.html(h.join(''));
	if(current) {
		$elem.val(current);
	}
}

/*
 * Enable the user profile button
 */
function enableUserProfile () {
	// Initialise the dialog for the user to edit their own account details
	$('#modify_me_popup').dialog(
		{
			autoOpen: false, closeOnEscape:true, draggable:true, modal:true,
			title:"User Profile",
			show:"drop",
			width:350,
			height:350,
			zIndex: 2000,
			buttons: [
				{
					text: "Cancel",
					click: function() {

						$(this).dialog("close");
					}
				}, {
					text: "Save",
					click: function() {

						var user = globals.gLoggedInUser,
							userList = [],
							error = false,
							userList;

						user.name = $('#me_name').val();
						user.language = $('#me_language').val();
						user.email = $('#me_email').val();
						if($('#me_password').is(':visible')) {
							user.password = $('#me_password').val();
							if($('#me_password_confirm').val() !== user.password) {
								error = true;
								user.password = undefined;
								alert("Passwords do not match");
								$('#me_password').focus();
								return false;
							}
						} else {
							user.password = undefined;
						}

						user.current_project_id = 0;	// Tell service to ignore project id and update other details
						user.current_survey_id = 0;
						user.current_task_group_id = 0;

						user.timezone = $('#u_tz').val();
						globals.gTimezone = user.timezone;

						user.o_id = $('#me_organisation').val();
						if(user.o_id == globals.gOrgId) {
							user.o_id = 0;	// No change
						}

						saveCurrentUser(user, undefined);			// Save the updated user details to disk
						$(this).dialog("close");
					},
				}, {
					text: "Logout",
					click: function() {
						logout();
						$(this).dialog("close");
					}

				}
			]
		}
	);


	// Initialise the reset password checkbox
	$('#reset_me_password').click(function () {
		if($(this).is(':checked')) {
			$('#password_me_fields').removeClass('d-none').show();
		} else {
			$('#password_me_fields').hide();
		}
	});
}

/*
 * Logout function
 */
function logout() {

	try {
		localStorage.setItem('navbar_color', undefined);
		localStorage.setItem('navbar_text_color', undefined);
		localStorage.setItem('main_logo', undefined);
	} catch (e) {

	}

	jQuery.ajax({
		type: "GET",
		cache: false,
		url: "/surveyKPI/logout",
		beforeSend: function(xhr){xhr.setRequestHeader("Authorization","Basic YXNkc2E6");},
		username: "shkdhasfkhd",
		password: "sieinkdnfkdf",
		error: function(data, status) {
			window.location.href="/logout.html";
		},
		success: function(data,status) {
			window.location.href="/logout.html";
		}
	});
}

/*
 * Enable the user profile button
 */
function enableUserProfileBS () {


	/*
	 * User logout
	 */
	$('#userProfileLogout').click(function() {
		logout();
	});

	$("#modify_me_popup :input").keydown(function() {
		$("#me_alert").hide();
	});

	/*
	 * Save the user profile
	 */
	$('#userProfileSave').click(function() {
		var user = globals.gLoggedInUser,
			userList = [],
			error = false,
			userList;

		user.name = $('#me_name').val();
		user.language = $('#me_language').val();
		user.email = $('#me_email').val();
		if($('#me_password').is(':visible')) {
			user.password = $('#me_password').val();
			if($('#me_password_confirm').val() !== user.password) {
				error = true;
				user.password = undefined;
				$('#me_alert').removeClass('alert-success d-none').addClass('alert-danger').text(localise.set["msg_pwd_m"]).show();
				$('#me_password').focus();
				return false;
			}
		} else {
			user.password = undefined;
		}

		user.o_id = $('#me_organisation').val();
		if(user.o_id == globals.gOrgId) {
			user.o_id = 0;	// No change
		}

		globals.gTimezone = $('#u_tz').val();
		user.timezone = globals.gTimezone;

		user.current_project_id = 0;	// Tell service to ignore project id and update other details
		user.current_survey_id = 0;
		user.current_task_group_id = 0;

		saveCurrentUser(user, $('#modify_me_popup'));			// Save the updated user details to disk
	});


	// Initialise the reset password checkbox
	$('#reset_me_password').click(function () {
		if($(this).is(':checked')) {
			$('#password_me_fields').removeClass('d-none').show();
		} else {
			$('#password_me_fields').hide();
		}
	});
}

/*
 * Save the currently logged on user's details
 */
function saveCurrentUser(user, $dialog) {

	var userString = JSON.stringify(user);
	addHourglass();
	$.ajax({
		type: "POST",
		cache: false,
		contentType: "application/json",
		dataType: 'json',
		url: "/surveyKPI/user?x=x", // Terminate url with ? so that the service worker will pick it out
		data: { user: userString },
		success: function(data) {
			removeHourglass();
			if(data.error) {
				if($dialog) {
					$('#me_alert').removeClass('alert-success d-none').addClass('alert-danger').text(data.msg).show();
				} else {
					alert(localise.set["c_error"] + " : " + data.msg);  // legacy non bootstrap
				}
			} else if($dialog) {
				$dialog.modal("hide");
				updateUserDetails(data, undefined);
			}

		}, error: function(data, status) {
			removeHourglass();
			alert(localise.set["c_error"] + " : " + data.responseText);
		}
	});
}

function getAvailableTimeZones(callback) {
	addHourglass();
	$.ajax({
		url: "/surveyKPI/utility/timezones",
		contentType: "application/json",
		cache: true,
		success: function(data) {
			removeHourglass();

			if(typeof callback == "function") {
				callback(data);
			}

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["c_error"] + ": " + err);
			}
		}
	});
}

function showTimeZones(timeZones) {
	var h =[],
		idx = -1,
		i,
		tz;

	for (i = 0; i < timeZones.length; i++) {
		tz = timeZones[i];
		h[++idx] = '<option value="';
		h[++idx] = tz.id;
		h[++idx] = '">';
		h[++idx] = htmlEncode(tz.name);
		h[++idx] = '</option>';
	}
	$('.timezone_select').empty().html(h.join(''));
	if(!globals.gTimezone) {
		globals.gTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;      // Browser timezone
	}
	$('#u_tz').val(globals.gTimezone);   // Set time zone in user profile
	$('#timezone').html(localise.set["c_tz"] + ": " + globals.gTimezone);   // Show timezone where this is enabled
}

function addTimeZoneToUrl(url) {
	if(url) {
		if(url.indexOf("?") > 0) {
			url += "&";
		} else {
			url += "?";
		}
		url += "tz=";
		url += encodeURIComponent(globals.gTimezone);
	}
	return url;
}

/*
 * Create the user profile dialog and get any data it needs
 */
function setupUserProfile(bs4) {

	if(bs4) {
		addUserDetailsPopupBootstrap4();
	} else {
		addUserDetailsPopup();	// legacy
	}
	getAvailableTimeZones(showTimeZones);
}

function getLoggedInUser(callback, getAll, getProjects, getOrganisationsFn, hideUserDetails,
                         dontGetCurrentSurvey, getEnterprisesFn, getServerDetailsFn) {
	addHourglass();
	$.ajax({
		url: "/surveyKPI/user",
		contentType: "application/json",
		cache: false,
		success: function(data) {
			removeHourglass();

			var i;

			globals.gServerCanSendEmail = data.sendEmail;

			globals.gEmailEnabled = data.allow_email;
			globals.gFacebookEnabled = data.allow_facebook;
			globals.gTwitterEnabled = data.allow_twitter;
			globals.gCanEdit = data.can_edit;
			globals.gSendTrail = data.ft_send_location;
			globals.gAlertSeen = data.seen;		// Alerts have been acknowledged
			globals.gLastAlertTime = data.lastalert;
			globals.gOrgId = data.o_id;
			globals.gEntId = data.e_id;
			globals.gEnterpriseName = data.enterprise_name;
			globals.gSetAsTheme = data.set_as_theme;
			globals.gNavbarColor = data.navbar_color;
			globals.gNavbarTextColor = data.navbar_text_color;
			globals.gTraining = data.training;
			globals.gRefreshRate = data.refresh_rate;

			if(data.timezone) {
				globals.gTimezone = data.timezone;
			} else {
				globals.gTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
			}
			$('#u_tz').val(globals.gTimezone);

			if(!hideUserDetails) {
				updateUserDetails(data, getOrganisationsFn, getEnterprisesFn, getServerDetailsFn);
			}

			if(!dontGetCurrentSurvey) {	// Hack, on edit screen current survey is set as parameter not from the user's defaults
				globals.gCurrentSurvey = data.current_survey_id;
			}
			globals.gCurrentProject = data.current_project_id;
			globals.gCurrentTaskGroup = data.current_task_group_id;
			$('#projectId').val(globals.gCurrentProject);		// Set the project value for the hidden field in template upload
			if(data.groupSurveys) {
				for(i = 0; i < data.groupSurveys.length; i++) {
					globals.gGroupSurveys[data.groupSurveys[i].sId] = data.groupSurveys[i].groupIdent;
					globals.gSubForms[data.groupSurveys[i].sId] = data.groupSurveys[i].fName;
				}
			}

			setOrganisationTheme();

			if(getProjects) {
				getMyProjects(globals.gCurrentProject, callback, getAll);	// Get projects
			} else {
				if(typeof callback !== "undefined") {
					callback(globals.gCurrentSurvey);				// Call the callback with the correct current project
				}
			}

			// Add hack to show beta functions. There should be a user setting of beta tester
			if(data.name &&(data.name.indexOf("Penman") >= 0 || data.name.indexOf("Torrado") >= 0)) {
				$('.beta').show();
			}

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0 || xhr.status == 401) {
				return;  // Not an error or an authorisation error which is handled by the service worker
			} else {
				console.log("Error: Failed to get user details: " + err);

				var msg = localise.set["c_error"] + ": ";
				if(err && err.indexOf('Unauthorized') >= 0) {
					msg += localise.set["c_auth"];
				} else {
					msg += err;
				}
				alert(msg);
			}
		}
	});
}

/*
 * Get the users queries
 */
function getQueries(published) {

	var url="/surveyKPI/query" + (published ? "?published=true" : "");

	addHourglass();

	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			var h = [],
				idx = -1,
				i,
				item,
				$elem = $('#export_query');

			removeHourglass();

			if(data && data.length > 0) {
				for(i = 0; i < data.length; i++) {
					item = data[i];
					h[++idx] = '<option value="';
					h[++idx] = item.id;
					h[++idx] = '">';
					h[++idx] = '<td>';
					h[++idx] = htmlEncode(item.name);
					h[++idx] = '</option>';
				}
			}

			$elem.html(h.join(''));

		}, error: function(xhr, textStatus, err) {

			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert("Error: Failed to get list of queriess: " + err);
			}
		}
	});
}

/*
 * ===============================================================
 * Common functions for managing media (on both the edit page and shared resource page)
 * ===============================================================
 */

/*
 * Upload files to the server
 * Writes status to   .upload_file_msg
 */
function uploadFiles(url, formName, callback1, param, callback2) {

	var f = document.forms.namedItem(formName),
		formData = new FormData(f);

	url = addUrlParam(url, "getlist=true");
	addHourglass();
	$('.submitFiles').addClass('disabled');
	$.ajax({
		url: url,
		type: 'POST',
		xhr: function () {
			var myXhr = $.ajaxSettings.xhr();
			if(myXhr.upload){
				myXhr.upload.addEventListener('progress', progressFn, false);
			}
			return myXhr;
		},
		data: formData,
		cache: false,
		contentType: false,
		processData:false,
		success: function(data) {
			removeHourglass();
			var callbackParam = param,
				cb1 = callback1,
				cb2 = callback2;
			$('.upload_file_msg').removeClass('alert-danger').addClass('alert-success').html(localise.set["c_success"]);
			if(typeof cb1 === "function") {
				cb1(data, callbackParam);
			}
			if(typeof cb2 === "function") {
				cb2(data);
			}
			document.forms.namedItem(formName).reset();

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			document.forms.namedItem(formName).reset();
			$('.submitFiles').removeClass('disabled');
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				var msg = xhr.responseText;
				if(msg && msg.indexOf("no tags") >= 0) {
					msg = localise.set["msg_u_nt"];
				} else {
					msg = localise.set["msg_u_f"] + " : " + msg;
				}
				$('.upload_file_msg').removeClass('alert-success').addClass('alert-danger').html(msg);

			}
		}
	});
}

/*
 * Add a parameter to a URL
 */
function addUrlParam(url, param) {
	if(url.indexOf("?") > 0) {
		url += "&" + param;
	} else {
		url += "?" + param;
	}
	return url;
}

/*
 * Progress function for the uploading of files
 */
function progressFn(e) {
	if(e.lengthComputable){
		var w = (100.0 * e.loaded) / e.total;
		$('.progress-bar').css('width', w+'%').attr('aria-valuenow', w);
	}
}

/*
 * Refresh the media view and then set the mode to manage
 */
function refreshMediaViewManage(data, sId) {
	refreshMediaView(data, sId);
	$('.mediaManage').show();
	$('.mediaSelect').hide();
}
/*
 * Refresh the view of any attached media if the available media items has changed
 */
function refreshMediaView(data, sId) {

	var i,
		survey = globals.model.survey,
		$element,
		h = [],
		idx = -1,
		files;

	if(survey && sId) {
		// Set the display name
		$('.formName').text(survey.displayName);
		$('#survey_id').val(sId);
		gSId = sId;
	}

	if(data) {
		files = data.files;

		if(sId) {
			$element = $('#filesSurvey');
		} else {
			$element = $('#filesOrg');
		}

		for(i = 0; i < files.length; i++){
			h[++idx] = '<tr class="';
			h[++idx] = files[i].type;
			h[++idx] = '">';
			h[++idx] = '<td class="preview">';
			h[++idx] = '<a target="_blank" href="';
			h[++idx] = files[i].url;
			if(files[i].url.indexOf("?") < 0) {     // Add some random text to prevent caching on identical file names
				h[++idx] = "?";
			} else {
				h[++idx] = "&";
			}
			h[++idx] = "_v" + new Date().getTime().toString();
			h[++idx] = '">';
			if(files[i].type == "audio") {
				h[++idx] = addAudioIcon();
			} else if(files[i].type == "geojson") {
				h[++idx] = addVectorMapIcon();
			} else {
				h[++idx] = '<img width="100" height="100" src="';
				h[++idx] = files[i].thumbnailUrl + addCacheBuster(files[i].thumbnailUrl);
				h[++idx] = '" alt="';
				h[++idx] = files[i].name;
				h[++idx] = '">';
			}
			h[++idx] = '</a>';
			h[++idx] = '</td>';
			h[++idx] = '<td class="filename">';
			h[++idx] = '<p>';
			h[++idx] = files[i].name;
			h[++idx] = '</p>';
			h[++idx] = '</td>';
			h[++idx] = '<td class="mediaManage">';
			h[++idx] = localTime(files[i].modified);
			h[++idx] = '</td>';
			h[++idx] = '<td class="mediaManage">';
			h[++idx] = '<p>';
			h[++idx] = files[i].size;
			h[++idx] = '</p>';
			h[++idx] = '</td>';
			h[++idx] = '<td class="mediaManage">';
			h[++idx] = '<button class="media_del btn btn-danger" data-url="';
			h[++idx] = files[i].deleteUrl;
			h[++idx] = '">';
			h[++idx] = '<i class="fas fa-trash-alt"></i>'
			h[++idx] = '</button>';
			h[++idx] = '</td>';
			h[++idx] = '<td class="mediaSelect">';
			h[++idx] = '<button class="mediaAdd btn btn-success">';
			h[++idx] = '<i class="fas fa-plus"></i> '
			h[++idx] = localise.set['c_add'];
			h[++idx] = '</button>';
			h[++idx] = '</td>';


			h[++idx] = '</tr>';

		}


		$element.html(h.join(""));

		$('.media_del', $element).click(function () {
			var surveyId = sId,
				url = $(this).data('url'),
				idx = url.lastIndexOf('/'),
				filename = url.substring(idx + 1);

			if(confirm(localise.set["msg_confirm_del"] + filename)) {
				delete_media(url, surveyId);
			}
		});

	}

	// If this is the organisational view we can refresh the list of choices for selecting vector maps
	if(!sId) {
		refreshVectorSelects(data);
	}
}

/*
 * Refresh the vector select lists
 */
function refreshVectorSelects(data) {

	var i,
		$vectorData = $('#vector_data'),
		$vectorStyle = $('#vector_style'),
		h_d = [],
		idx_d = -1,
		h_s = [],
		idx_s = -1,
		files;

	if(data) {
		files = data.files;

		for(i = 0; i < files.length; i++){
			if(files[i].type === "geojson") {
				h_d[++idx_d] = '<option value="';
				h_d[++idx_d] = files[i].name;
				h_d[++idx_d] = '">';
				h_d[++idx_d] = htmlEncode(files[i].name);
				h_d[++idx_d] = '</option>';
			}

			if(files[i].type === "TODO") {
				h_s[++idx_s] = '<option value="';
				h_s[++idx_s] = files[i].name;
				h_s[++idx_s] = '">';
				h_s[++idx_s] = htmlEncode(files[i].name);
				h_s[++idx_s] = '</option>';
			}

		}


		$vectorData.html(h_d.join(""));
		$vectorStyle.html(h_s.join(""));


	}
}

function addAudioIcon() {
	var h = [],
		idx = -1;

	h[++idx] = '<span class="has_tt" title="Audio">';
	h[++idx] = '<span class="glyphicon glyphicon-volume-up edit_type"></span>';
	h[++idx] = '</span>';

	return h.join('');
}

function addVectorMapIcon() {
	var h = [],
		idx = -1;

	h[++idx] = '<span class="has_tt" title="Audio">';
	h[++idx] = '<span class="glyphicon glyphicon glyphicon-map-marker edit_type"></span>';
	h[++idx] = '</span>';

	return h.join('');
}

function getFilesFromServer(url, sId, callback, getall) {

	var hasParams = false;
	if(sId) {
		gSId = sId;
		url += '?survey_id=' + sId;
		hasParams = true;
	}
	if(getall) {
		url += (hasParams ? '&' : '?') + 'getall=true';
	}

	url += addCacheBuster(url);

	addHourglass();
	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			var surveyId = sId;
			callback(data, surveyId);

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				$('.upload_file_msg').removeClass('alert-success').addClass('alert-danger').html("Error: " + err);
			}
		}
	});
}

/*
 * Delete a media file
 */
function delete_media(url, sId) {
	addHourglass();
	$.ajax({
		url: url,
		type: 'DELETE',
		cache: false,
		success: function(data) {
			removeHourglass();
			var surveyId = sId;
			refreshMediaViewManage(data, surveyId);

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				$('.upload_file_msg').removeClass('alert-success').addClass('alert-danger').html("Error: " + err);
			}
		}
	});

}
/*
 * ===============================================================
 * Hourglass Functions
 * ===============================================================
 */

function addHourglass() {

	if(gWait === 0) {

		$("#hour_glass,.hour_glass,.sk-spinner").show();
	}
	++gWait;
}

function removeHourglass() {

	--gWait;
	if(gWait === 0) {

		$("#hour_glass,.hour_glass,.sk-spinner").hide();
	}

}

/*
 * ===============================================================
 * Survey Functions
 * ===============================================================
 */

/*
 * Load the surveys from the server
 */
function loadSurveys(projectId, selector, getDeleted, addAll, callback, useIdx) {

	var url="/surveyKPI/surveys?projectId=" + projectId + "&blocked=true";

	if(selector === undefined) {
		selector = ".survey_select";	// Update the entire class of survey select controls
	}

	if(typeof projectId !== "undefined" && projectId != -1 && projectId != 0) {

		if(getDeleted) {
			url+="&deleted=true";
		}
		addHourglass();

		$.ajax({
			url: url,
			dataType: 'json',
			cache: false,
			success: function(data) {
				var sel = selector;
				var all = addAll;

				removeHourglass();

				showSurveyList(data, sel + ".data_survey", all, true, false, useIdx);
				showSurveyList(data, sel + ".oversight_survey", all, false, true, useIdx);
				showSurveyList(data, sel + ".data_oversight_survey", all,true, true, useIdx);

				if(typeof callback == "function") {
					callback(data);
				}
			},
			error: function(xhr, textStatus, err) {

				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					console.log("Error: Failed to get list of surveys: " + err);
				}
			}
		});
	} else {
		var $elem = $('.data_survey, .oversight_survey, .data_oversight_survey');
		$elem.empty();
		if(addAll) {
			$elem.append('<option value="_all">' + localise.set["c_all_s"] + '</option>');
		}

		if(callback) {
			callback();
		}

	}
}

/*
 * Show the surveys in select boxes
 */
function showSurveyList(data, selector, addAll, dataSurvey, oversightSurvey, useIdx) {

	var i,
		item,
		h = [],
		idx = -1,
		$elem,
		$elem_disable_blocked,
		selValue;

	$elem = $(selector);
	$elem_disable_blocked = $(selector + ".disable_blocked");

	$elem.empty();
	var valueSelected = false;
	if(addAll) {
		h[++idx] = '<option value="_all">';
		h[++idx] = localise.set["c_all_s"];		// All Surveys
		h[++idx] = '</option>';

		selValue = "_all";
		valueSelected = true;
	}

	for(i = 0; i < data.length; i++) {
		item = data[i];
		if(item.dataSurvey && dataSurvey || item.oversightSurvey && oversightSurvey) {
			h[++idx] = '<option';
			if (!valueSelected && !item.blocked) {
				valueSelected = true;
				selValue = useIdx ? i : item.id;
			}
			if (item.blocked) {
				h[++idx] = ' class="blocked"';
			}
			h[++idx] = ' value="';
			h[++idx] = useIdx ? i : item.id;
			h[++idx] = '">';
			h[++idx] = htmlEncode(item.displayName);
			if (item.blocked) {
				h[++idx] = ' (' + localise.set["c_blocked"] + ')';
			}
			h[++idx] = '</option>';
		}
		if(globals.gCurrentSurvey > 0 && globals.gCurrentSurvey === item.id) {
			selValue = useIdx ? i : item.id;
		}
	}

	$elem.empty().append(h.join(''));
	$elem.val(selValue);
	$("option.blocked", $elem_disable_blocked).attr("disabled", "disabled");

}

/*
 * Load the surveys from the server
 */
function loadForms(surveyId, selector) {

	var url="/surveyKPI/surveys/forms?surveyId=" + surveyId,
		$elem,
		selector_disable_blocked,
		h = [],
		idx = -1,
		i,
		item;

	if(selector === undefined) {
		selector = ".form_select";	// Update the entire class of form select controls
	}
	$elem = $(selector);


	addHourglass();

	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {

			removeHourglass();
			$elem.empty();

			for(i = 0; i < data.length; i++) {
				item = data[i];
				h[++idx] = '<option';
				h[++idx] = ' value="';
				h[++idx] = item.id;
				h[++idx] = '">';
				h[++idx] = htmlEncode(item.name);
				h[++idx] = '</option>';
			}

			$elem.empty().append(h.join(''));

			if(globals.gCurrentForm > 0) {
				$elem.val(globals.gCurrentForm);
			}


		},
		error: function(xhr, textStatus, err) {

			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				console.log("Error: Failed to get list of forms: " + err);
			}
		}
	});

}

// Common Function to get the language and question list (for the default language)
function getLanguageList(sId, callback, addNone, selector, setGroupList, filterQuestion) {

	if(typeof sId === "undefined") {
		sId = globals.gCurrentSurvey;
	}

	if(typeof filterQuestion === "undefined") {
		filterQuestion = "-1";
	}

	function getAsyncLanguageList(sId, theCallback, selector, filterQuestion) {
		addHourglass();
		$.ajax({
			url: languageListUrl(sId),
			dataType: 'json',
			cache: false,
			success: function(data) {
				removeHourglass();
				globals.gSelector.setSurveyLanguages(sId, data);
				retrievedLanguages(sId, selector, data, theCallback, filterQuestion, setGroupList, addNone);
			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert(localise.set["c_error"] + ": " + err);
				}
			}
		});
	}

	var data = globals.gSelector.getSurveyLanguages(sId);
	if(data) {
		retrievedLanguages(sId, selector, data, callback, filterQuestion, setGroupList, addNone);
	} else {
		getAsyncLanguageList(sId, callback, selector, filterQuestion);
	}
}

/*
 * Called after languages have been retrieved
 */
function retrievedLanguages(sId, selector, data, theCallback, filterQuestion, setGroupList, addNone) {
	if(selector) {
		setSurveyViewLanguages(data, undefined, selector, addNone);
	} else {
		setSurveyViewLanguages(data, undefined, '#settings_language', false);
		setSurveyViewLanguages(data, undefined, '#export_language', true);
		setSurveyViewLanguages(data, undefined, '#language_name', false);
	}

	if(data[0]) {
		var dateqId = $('#task_start').val();
		getQuestionList(sId, data[0], filterQuestion, "-1", theCallback, setGroupList, undefined, dateqId, undefined);	// Default language to the first in the list
	} else {
		if(typeof theCallback === "function") {
			theCallback();
		}
	}
}

//Function to get the question list
function getQuestionList(sId, language, qId, groupId, callback, setGroupList, view, dateqId, qName) {

	function getAsyncQuestionList(sId, language, theCallback, groupId, qId, view, dateqId, qName) {

		addHourglass();
		$.ajax({
			url: questionListUrl(sId, language, true),
			dataType: 'json',
			cache: false,
			success: function(data) {
				removeHourglass();
				globals.gSelector.setSurveyQuestions(sId, language, data);
				setSurveyViewQuestions(data, qId, view, dateqId, qName);

				if(setGroupList && typeof setSurveyViewQuestionGroups === "function") {
					setSurveyViewQuestionGroups(data, groupId);
				}
				if(typeof theCallback === "function") {
					theCallback();
				}
			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert("Error: Failed to get list of questions: " + err);
				}
			}
		});
	}

	getAsyncQuestionList(sId, language, callback, groupId, qId, view, dateqId, qName);
}

//Function to get the meta list
function getMetaList(sId, metaItem) {

	addHourglass();
	$.ajax({
		url: "/surveyKPI/metaList/" + sId,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			globals.gSelector.setSurveyMeta(sId, data);
			setSurveyViewMeta(data, metaItem);
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["c_error"] + ": " + err);
			}
		}
	});
}

/*
 * Function to get the list of notification alerts
 * These are extracted from the settings for the survey
 */
function getAlertList(sId, alertId) {

	addHourglass();
	$.ajax({
		url: "/surveyKPI/cases/settings/" + sId,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			globals.gSelector.setSurveyAlerts(sId, data);
			setSurveyAlerts(data, alertId);
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["c_error"] + ": " + err);
			}
		}
	});
}


//Set the language list in the survey view control
function setSurveyViewLanguages(list, language,elem, addNone) {

	var $languageSelect = $(elem),
		i;

	$languageSelect.empty();
	if(addNone) {
		$languageSelect.append('<option value="none">' + localise.set["c_none"] + '</option>');
	}

	for(i = 0; i < list.length; i++) {
		$languageSelect.append('<option value="' + list[i] + '">' + htmlEncode(list[i]) + '</option>');
	}

	if(language) {
		$languageSelect.val(language);
	}
}

// Set the question list in the survey view control
function setSurveyViewQuestions(list, qId, view, dateqId, qName) {

	var $questionSelect = $('.selected_question'),
		$dateQuestions = $('.date_questions'),
		$questionNameSelect = $('.selected_name_question'),     // this should replace selected_question
		label;

	$questionSelect.empty();
	$questionSelect.append('<option value="-1">' + localise.set["c_none"] + '</option>');

	$questionNameSelect.empty();
	$questionNameSelect.append('<option value="-1">' + localise.set["c_none"] + '</option>');

	$dateQuestions.empty();
	$dateQuestions.append('<option value="-1">' + localise.set["ed_i_c"] + '</option>');

	if(list) {
		$.each(list, function(j, item) {
			if(typeof item.q === "undefined") {
				label = "";
			} else {
				label = item.q;
			}
			if(item.is_ssc) {
				$questionSelect.append('<option value="' + item.id + '">ssc : ' + htmlEncode(item.name + " : " + item.fn) + '</option>');
			} else {
				$questionSelect.append('<option value="' + item.id + '">' + htmlEncode(item.name + " : " + label) + '</option>');
				$questionNameSelect.append('<option value="' + item.name + '">' + htmlEncode(item.name) + '</option>');
				if(item.type === 'timestamp' || item.type === 'dateTime' || item.type == 'date') {
					$dateQuestions.append('<option value="' + item.id + '">' + htmlEncode(item.name + " : " + label) + '</option>');
				}
			}
		});
	}
	if(!qId) {
		qId = "-1";
	}
	$questionSelect.val(qId);

	if(!qName) {
		qName = "-1";
	}
	$questionNameSelect.val(qName);

	if(!dateqId) {
		dateqId = "-1";
	}
	$dateQuestions.val(dateqId);

	if(view) {
		setFilterFromView(view);	// Set the filter dialog settings
	}

}

// Set the meta list in the survey view control
function setSurveyViewMeta(list, metaItem) {

	var $metaSelect = $('.selected_meta'),
		item,
		i;

	$metaSelect.empty();

	// Add none
	$metaSelect.append('<option value="-1">' + localise.set["c_none"] + '</option>');

	// Add the user who submitted the survey
	$metaSelect.append('<option value="_user">' + localise.set["c_submitter"] + '</option>');

	if(list) {
		for(i = 0; i < list.length; i++) {
			item = list[i];
			$metaSelect.append('<option value="' + item.name + '">' + htmlEncode(item.name) + '</option>');
		}
	}
	if(!metaItem) {
		metaItem = "-1";
	}
	$metaSelect.val(metaItem);

}

/*
 * Populate the alert list
 */
function setSurveyAlerts(settings, alertId) {

	var $elem = $('.alert_list'),
		item,
		i;

	$elem.empty();

	if(settings && settings.alerts) {
		for(i = 0; i < settings.alerts.length; i++) {
			item = settings.alerts[i];
			$elem.append('<option value="' + item.id + '">' + htmlEncode(item.name) + '</option>');
		}
	}
	if(alertId) {
		$elem.val(alertId);
	}


}

/*
 * ------------------------------------------------------------
 * Web service Functions
 */
function languageListUrl (sId) {

	var url = "/surveyKPI/languages/";
	url += sId;
	return url;
}

/*
 * Web service handler for retrieving available "count" questions for graph
 *  @param {string} survey
 */
function questionListUrl (sId, language, exc_read_only) {

	var url = "/surveyKPI/questionList/",
		ro_text;

	if(exc_read_only) {
		ro_text = "true";
	} else {
		ro_text = "false";
	}

	url += sId;
	url += "/" + encodeURIComponent(language);
	url += "?exc_read_only=" + ro_text;
	return url;
}

/**
 * Web service handler for question Meta Data
 * @param {string} survey id
 * @param {string} question id
 */
function questionMetaURL (sId, lang, qId) {

	var url = "/surveyKPI/question/";
	url += sId;
	url += "/" + lang;
	url += "/" + qId;
	url += "/getMeta";
	return url;
}

/*
 * Get a survey details - depends on globals being set
 */
function getSurveyDetails(callback, get_changes, hide_soft_deleted) {

	var tz = globals.gTimezone;
	var url="/surveyKPI/surveys/" + globals.gCurrentSurvey;
	if(get_changes) {
		url += "?get_changes=true";
		url += "&tz=" + encodeURIComponent(tz);
	} else {
		url += "?tz=" + encodeURIComponent(tz);
	}
	if(hide_soft_deleted) {
		url += "&get_soft_delete=false";
	}

	if(!globals.gCurrentSurvey) {
		alert("Error: Can't get survey details, Survey identifier not specified");
	} else {
		addHourglass();
		$.ajax({
			url: url,
			dataType: 'json',
			cache: false,
			success: function(data) {
				removeHourglass();
				globals.model.setSurveyData(data);
				globals.model.setSettings();
				setLanguages(data.languages, callback);

				if(typeof callback == "function") {
					callback();
				}
			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					if(xhr.status == 404) {
						// The current survey has probably been deleted or the user no longer has access
						globals.gCurrentSurvey = undefined;
						return;
					}
					alert("Error: Failed to get survey: " + err);
				}
			}
		});
	}
}

/*
 * Get a survey details - depends on globals being set
 */
function getGroupSurveys(callback) {

	var tz = globals.gTimezone;
	var url="/surveyKPI/surveys/groups/" + globals.gCurrentSurvey;
	url += "?tz=" + encodeURIComponent(tz);

	if(!globals.gCurrentSurvey) {
		alert("Error: Can't get group details, Survey identifier not specified");
	} else {
		addHourglass();
		$.ajax({
			url: url,
			dataType: 'json',
			cache: false,
			success: function(data) {
				removeHourglass();
				globals.gGroupSurveys = data;
				if(typeof callback == "function") {
					callback();
				}
			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					if(xhr.status == 404) {
						// The current survey has probably been deleted or the user no longer has access
						globals.gCurrentSurvey = undefined;
						return;
					}
					alert("Error: Failed to get survey: " + err);
				}
			}
		});
	}

}

/*
 * Set the languages for the editor
 */
function setLanguages(languages, languageCallback) {

	var h = [],
		h2 = [],
		idx = -1,
		idx2 = -1,
		$lang_menu = $('.language_menu_list'),
		$lang = $('.language_list'),
		$lang1 = $('#language1'),
		$lang2 = $('#language2'),
		i;

	globals.gLanguage1 = 0;	// Language indexes used for translations
	globals.gLanguage2 = 0;
	if(languages.length > 1) {
		globals.gLanguage2 = 1;
	}

	for (i = 0; i < languages.length; i++) {
		h[++idx] = '<li>';
		h[++idx] = '<a data-lang="';
		h[++idx] = i;
		h[++idx] = '" href="javascript:void(0)">';
		h[++idx] = htmlEncode(languages[i].name);
		h[++idx] = '</a>';
		h[++idx] = '</li>';

		h2[++idx2] = '<option value="';
		h2[++idx2] = i;
		h2[++idx2] = '">';
		h2[++idx2] = htmlEncode(languages[i].name);
		h2[++idx2] = '</option>';
	}

	$lang_menu.empty().append(h.join(""));
	$lang.empty().append(h2.join(""));

	$('#langSelected').text(languages[ globals.gLanguage].name);
	$('.language_menu_list a').click(function() {
		globals.gLanguage = $(this).data("lang");
		$('#langSelected').text(languages[ globals.gLanguage].name);
		languageCallback();
	});

	$lang1.val(globals.gLanguage1);
	$lang2.val(globals.gLanguage2)
}

/*
 * Get a survey details - depends on globals being set
 */
function createNewSurvey(name, existing, existing_survey, shared_results, callback) {

	console.log("create new: " + existing + " : " + existing_survey + " : " + shared_results);

	var url="/surveyKPI/surveys/new/" + globals.gCurrentProject + "/" + encodeURIComponent(name);
	if(!existing) {
		existing_survey = 0;
	}

	addHourglass();
	$.ajax({
		type: "POST",
		url: url,
		cache: false,
		dataType: 'json',
		data: {
			existing: existing,
			existing_survey: existing_survey,
			existing_form: 0,
			shared_results: shared_results
		},
		cache: false,
		success: function(data) {
			removeHourglass();

			globals.model.setSurveyData(data);
			globals.model.setSettings();
			globals.gCurrentSurvey = data.id;

			saveCurrentProject(-1, globals.gCurrentSurvey, undefined);	// Save the current survey id

			setLanguages(data.languages, callback);

			if(typeof callback == "function") {
				callback();
			}
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				bootbox.alert(localise.set["c_error"] + xhr.responseText);
			}
		}
	});
}

/*
 * Open a form for editing
 */
function openForm(type) {

	$('.reusing_form').hide();
	$('#base_on_existing').prop('checked', false);
	$('#shared_results').prop('checked', false);
	$('#new_form_name').val("");
	if(type === "new") {
		$('.existing_form').hide();
		$('.new_form').show();
		$('#openSurveyLabel').html(localise.set["tm_g_new"]);
		$('#get_form').html(localise.set["c_create"]);
		globals.gExistingSurvey = false;
	} else {
		$('.existing_form').show();
		$('.new_form').hide();
		$('#openSurveyLabel').html(localise.set["tm_g_open"]);
		$('#get_form').html(localise.set["m_open"]);
		globals.gExistingSurvey = true;
	}
	$('#openFormModal').modal('show');

}

/*
 * If this is a smap server return the subdomain
 */
function getServerSubDomainName() {

	var hostname = location.hostname;
	var sd = "";

	if(hostname.indexOf('.smap.com.au') > 0) {
		sd = hostname.substring(0, hostname.indexOf('.smap.com.au'));
	} else if(hostname === 'localhost') {
		sd = 'localhost';
	}

	return sd;
}

/*
 * Return true if this is a business server
 */
function isBusinessServer() {

	var hostname = location.hostname;
	var bs = true;

	if(hostname.indexOf('smap.com.au') > 0) {
		bs = false;
	}
	if(hostname.indexOf('sg.smap.com.au') >= 0 ||
		hostname.indexOf('ubuntu1804.smap.com.au') >= 0 ||
		hostname.indexOf('demo.smap.com.au') >= 0) {
		bs = true;
	}

	return bs;
}

/*
 * Returns the class of server that has custom menus
 */
function getCustomMenuClass() {

	var hostname = location.hostname;
	var classname = undefined;

	if(hostname.indexOf('cuso.smap.com.au') >= 0) {
		classname = '.xxxx1';
	} else if(hostname.indexOf('demo.smap.com.au') >= 0) {
		classname = '.xxxx1';
	} else {
		if(hostname === 'localhost') {
			classname = '.xxxx1';   // testing
		}
	}

	return classname;
}


/*
 * Return true if this is a self registration server
 */
function isSelfRegistrationServer() {
	var hostname = location.hostname;
	var sr = true;

	if(hostname !== 'localhost' &&
		hostname !== 'sg.smap.com.au' &&
		hostname.indexOf('reachnettechnologies.com') < 0 &&
		hostname.indexOf('.icanreach.com') < 0 &&
		hostname.indexOf('encontactone.com') < 0 &&
		hostname !== 'app.kontrolid.com' &&
		hostname !== 'kontrolid.smap.com.au') {
		sr = false;
	}
	return sr;
}

/*
 * Validate start and end dates
 */
function validDates() {
	var $d1 = $('#startDate'),
		$d2 = $('#endDate'),
		d1 = $d1.data("DateTimePicker").date(),
		d2 = $d2.data("DateTimePicker").date()

	if(!d1 || !d1.isValid()) {
		$('#ut_alert').show().text("Invalid Start Date");
		setTimeout(function() {
			$('.form-control', '#startDate').focus();
		}, 0);
		return false;
	}

	if(!d2 || !d2.isValid()) {
		$('#ut_alert').show().text("Invalid End Date");
		setTimeout(function() {
			$('.form-control', '#endDate').focus();
		}, 0);
		return false;
	}

	if(d1 > d2) {
		$('#ut_alert').show().text("End date must be greater than or the same as the start date");
		setTimeout(function() {
			$('.form-control', '#startDate').focus();
		}, 0);
		return false;
	}

	$('#ut_alert').hide();
	return true;
}

/*
 * Convert a date into UTC
 */
function getUtcDate($element, start, end) {

	var theDate,
		utcDate;

	if(start) {
		theDate = $element.data("DateTimePicker").date().startOf('day');
	} else if (end) {
		theDate = $element.data("DateTimePicker").date().endOf('day');
	} else {
		theDate = $element.data("DateTimePicker").date();
	}

	utcDate = moment.utc(theDate);

	console.log("date:" + theDate.format("YYYY-MM-DD HH:mm:ss"));
	console.log("UTC:" + utcDate.format("YYYY-MM-DD HH:mm:ss"));

	return utcDate.valueOf();

}

/*
 * Get a description from a change made in the editor
 */
function getChangeDescription(change, version) {

	var h =[],
		idx = -1,
		oldVal,
		newVal,
		forms = globals.model.survey.forms,
		str;

	if(change.action === "external option") {
		/*
		 * Options added from a file
		 */
		h[++idx] = 'Choice <span style="color:blue;">';
		h[++idx] = htmlEncode(change.option.externalLabel);
		h[++idx] = '</span>';
		h[++idx] = ' from file: <span style="color:blue;">';
		h[++idx] = htmlEncode(change.fileName);
		h[++idx] = '</span>';

	} else if(change.action === "template_update") {
		h[++idx] = localise.set["ed_c_template"];
		h[++idx] = ' <span style="color:blue;">';
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "template_add") {
		h[++idx] = localise.set["ed_a_template"];
		h[++idx] = ' <span style="color:blue;">';
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "template_delete") {
		h[++idx] = ' <span style="color:red;">';
		h[++idx] = localise.set["ed_d_template"];
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "settings_update") {
		h[++idx] = localise.set["ed_c_settings"];
		h[++idx] = ' <span style="color:blue;">';
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "language_update") {
		h[++idx] = localise.set["ed_c_languages"];
		h[++idx] = ' <span style="color:blue;">';
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "add_preload") {
		h[++idx] = ' <span style="color:blue;">';
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "del_preload") {
		h[++idx] = ' <span style="color:red;">';
		h[++idx] = htmlEncode(change.msg);
		h[++idx] = '</span>';

	} else if(change.action === "update") {

		/*
		 * Updates to questions and options and list names
		 */
		if(change.property.prop === "type") {
			newVal = htmlEncode(translateType(change.property.newVal));
			oldVal = htmlEncode(translateType(change.property.oldVal));
		} else {
			newVal = htmlEncode(change.property.newVal);
			oldVal = htmlEncode(change.property.oldVal);
		}


		if(change.property.prop === "name") {

			// Deprecate the following when the structure of these log objects is made consistent
			if(typeof change.property.type === "optionList" || change.property.type === "unknown") {
				change.type = "choice list ";
			}

			h[++idx] = change.property.type;
			h[++idx] = ' ';
			h[++idx] = localise.set["msg_ren"],
				h[++idx] = ': <span style="color:blue;">';
			h[++idx] = newVal;		// Already encoded
			h[++idx] = '</span>';
			h[++idx] = ' from: <span style="color:red;">';
			h[++idx] = oldVal;	// Already encoded
			h[++idx] = '</span>';
		} else {
			str = localise.set["ed_c_chg_p"];
			if(change.property.propType === "constraint_msg" || change.property.propType === "required_msg" || change.property.propType === "guidance_hint") {
				str = str.replace("%s1", '"' + htmlEncode(change.property.propType) + '"');
			} else {
				str = str.replace("%s1", '"' + htmlEncode(change.property.prop) + '"');
			}
			str = str.replace("%s2", htmlEncode(change.property.name));
			str = str.replace("%s3", '<span style="color:blue;">' + newVal + '</span>');	// Already encoded
			str = str.replace("%s4", '<span style="color:red;">' + oldVal + '</span>');		// Already encoded
			h[++idx] = str;
		}

	} else if(change.action === "add")  {

		/*
		 * New questions or options
		 */
		if(change.type === "question" || change.changeType === "question"){  // deprecate checking of changeType

			str = localise.set["ed_c_add_q"];
			str = str.replace("%s1", '<span style="color:blue;">' + htmlEncode(change.question.name) + "</span>");
			var typeString;
			if(change.question.type === "string") {
				typeString = 'text';
			} else if(change.question.type === "select"){
				typeString = 'select_multiple';
			} else if(change.question.type === "select1"){
				typeString = 'select_one';
			} else {
				typeString = change.question.type;
			}
			str = str.replace("%s2", '<span style="color:red;">' + htmlEncode(typeString) + "</span>");
			h[++idx] = str;

		} else if(change.type === "option" || change.changeType === "option") {	// deprecate checking of changeType
			/*
			 * Options added or deleted from the editor
			 */
			str = localise.set["ed_c_add_o"];
			var valueStr = '<span style="color:blue;">' + change.option.value;
			if(change.option.labels && change.option.labels.length >= 1) {
				valueStr += ' (';
				valueStr += htmlEncode(change.option.labels[0].text);
				valueStr += ')';
			}
			valueStr += '</span>';
			str = str.replace("%s1", valueStr);
			str = str.replace("%s2", '<span style="color:blue;">' + htmlEncode(change.option.optionList) + '</span>');
			h[++idx] = str;
		}

	}  else if(change.action === "move")  {

		/*
		 * New questions or options
		 */
		h[++idx] = 'Moved ';

		if(change.type === "question" || change.changeType === "question") {  // deprecate checking of changeType){

			h[++idx] = 'question <span style="color:blue;">';
			h[++idx] = change.question.name;
			if(change.question.sourceSeq >= 0) {
				h[++idx] = '</span> from position <span style="color:red;">';
				h[++idx] = htmlEncode(change.question.sourceSeq);
				h[++idx] = '</span> in form ';
				h[++idx] = htmlEncode(forms[change.question.sourceFormIndex].name);
			} else {
				h[++idx] = '</span> from form ';
				h[++idx] = htmlEncode(forms[change.question.sourceFormIndex].name);
			}
			h[++idx] = '</span> to position <span style="color:red;">';
			h[++idx] = htmlEncode(change.question.seq);
			h[++idx] = '</span>';
			h[++idx] = ' in form ';
			h[++idx] = htmlEncode(forms[change.question.formIndex].name);


		} else if(change.type === "option") {

			h[++idx] = 'choice <span style="color:blue;">';
			h[++idx] = htmlEncode(change.option.value);
			if(change.option.labels && change.option.labels.length >= 1) {
				h[++idx] = ' (';
				h[++idx] = htmlEncode(change.option.labels[0].text);
				h[++idx] = ')';
			}
			h[++idx] = '</span>';
			h[++idx] = ' from choice list: <span style="color:blue;">';
			h[++idx] = htmlEncode(change.option.sourceOptionList);
			h[++idx] = '</span>';
			h[++idx] = ' to choice list: <span style="color:blue;">';
			h[++idx] = htmlEncode(change.option.optionList);
			h[++idx] = '</span>';
		}

	} else if(change.action === "delete")  {

		if(change.type === "question" || change.changeType === "question"){

			h[++idx] = localise.set["ed_c_del_q"];

			h[++idx] = ' <span style="color:blue;">';
			h[++idx] = htmlEncode(change.question.name);
			h[++idx] = '</span>';

		} else if(change.type === "option") {

			str = localise.set["ed_c_del_o"];
			var valueStr = '<span style="color:blue;">' + htmlEncode(change.option.value);
			if(change.option.labels && change.option.labels.length >= 1) {
				valueStr  += ' (';
				valueStr  += htmlEncode(change.option.labels[0].text);
				valueStr  += ')';
			}
			valueStr  += '</span>';
			str = str.replace("%s1", valueStr);
			str = str.replace("%s2", '<span style="color:blue;">' + htmlEncode(change.option.optionList) + '</span>');
			h[++idx] = str;
		}
	} else if(change.action === "set_required")  {
		if(change.msg.indexOf('not') < 0) {
			h[++idx] = localise.set["ed_c_sr"];
		} else {
			h[++idx] = localise.set["ed_c_snr"];
		}

	} else if(change.action === "upload_template")  {

		if(version > 1) {
			h[++idx] = localise.set["msg_survey_replaced"];
		} else {
			h[++idx] = localise.set["msg_survey_loaded"];
		}

	} else if(change.action === "role")  {

			h[++idx] = change.msg;

	} else {
		h[++idx] = htmlEncode(change.type);
		h[++idx] = ' ';
		h[++idx] = htmlEncode(change.name);
		h[++idx] = ' changed to: <span style="color:blue;">';
		h[++idx] = htmlEncode(change.newVal);
		h[++idx] = '</span>';
		h[++idx] = ' from: <span style="color:red;">';
		h[++idx] = htmlEncode(change.oldVal);
		h[++idx] = '</span>';
	}

	return h.join('');
}

// Translate types for use in change description
function translateType(input) {
	if(input === "string") {
		output = "text";
	} else {
		output = input;
	}
	return output;
}

/*
 * Get the shared locations from the server
 */
function getLocations(callback) {

	var url="/surveyKPI/tasks/locations";

	addHourglass();
	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			if(typeof callback === "function") {
				callback(data);
			}
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				console.log("Error: Failed to get list of locations: " + err);
			}
		}
	});

}

/*
 * update Location group list
 */
function refreshLocationGroups(tags, includeAll, currentGroup) {

	var g = undefined,
		h = [],
		idx = -1,
		i;

	var includeNfc = $('#includeNfc').prop('checked'),
		includeGeo = $('#includeGeo').prop('checked');

	if(tags) {
		for(i = 0; i < tags.length; i++) {
			if(includeAll || includeLocation(includeNfc, includeGeo, tags[i].uid, tags[i].lat, tags[i].lon)) {

				if (g != tags[i].group) {

					g = tags[i].group;
					if (typeof currentGroup === "undefined") {
						currentGroup = g;
					}

					if(includeAll) {
						if (currentGroup === g) {
							$('.location_group_list_sel').text(g);
						}
						h[++idx] = '<a class="dropdown-item" href="#">';
						h[++idx] = g;
						h[++idx] = '</a>';
					} else {
						h[++idx] = '<option';
						if (currentGroup === g) {
							h[++idx] = ' selected';
						}
						h[++idx] = ' value="';
						h[++idx] = g;
						h[++idx] = '">';
						h[++idx] = htmlEncode(g);
						h[++idx] = '</option>';
					}
				}
			}
		}
	}

	$('.location_group_list').empty().html(h.join(""));
	return currentGroup;
}

/*
 * Add the locations (NFC tags or geofence) to any drop down lists that use them
 */
function setLocationList(locns, current, currentGroup) {

	var h = [],
		idx = -1,
		i;

	if(locns && locns.length) {
		h[++idx] = '<option value="-1">';
		h[++idx] = localise.set["c_none"];
		h[++idx] = '</option>';
		for(i = 0; i < locns.length; i++) {
			if(locns[i].group === currentGroup) {
				h[++idx] = '<option value="';
				h[++idx] = i;
				h[++idx] = '">';
				h[++idx] = htmlEncode(locns[i].name);
				h[++idx] = '</option>';
			}
		}
	}

	$('.location_select').empty().append(h.join(""));
	$('.location_select').val(current);


}

/*
 * Test for whether or not a location should be shown in the resource page
 */
function includeLocation(includeNfc, includeGeo, uid, lat, lon) {
	var include = false;

	if(includeNfc && typeof uid !== 'undefined' && uid !== '') {
		include = true;
	}
	if(!include && includeGeo && lat != 0 && lon != 0) {
		include = true;
	}

	return include;
}

/*
 * Convert a timestamp in UTC to local time and return a date object
 */
function localTimeAsDate(utcTime) {
	var utcDate,
		localTime;

	if(utcTime) {
		if(utcTime.indexOf('+') > 0) {
			utcDate  = moment.utc(utcTime, 'YYYY-MM-DD HH:mm:ss Z').toDate();
		} else {
			utcDate  = moment.utc(utcTime, 'YYYY-MM-DD HH:mm:ss').toDate();
		}
		localTime = moment(utcDate);
	}
	return localTime;
}

/*
 * Convert a timestamp in UTC to local time
 */
function localTime(utcTime) {
	var utcDate,
		localTime;

	if(utcTime) {
		if(utcTime.indexOf('+') > 0) {
			utcDate  = moment.utc(utcTime, 'YYYY-MM-DD HH:mm:ss Z').toDate();
		} else {
			utcDate  = moment.utc(utcTime, 'YYYY-MM-DD HH:mm:ss').toDate();
		}
		localTime = moment(utcDate).format('YYYY-MM-DD HH:mm:ss');
	}
	return localTime;
}


function utcTime(localTime) {

	var utcTime,
		localDate;

	if(localTime) {
		localDate = moment(localTime).toDate();
		utcTime =  moment.utc(localDate).format('YYYY-MM-DD HH:mm:ss');
	}
	return utcTime;

}

function isLate(finish) {

	var late = false,
		current = new Date(),
		finishDate,
		localFinish;

	if(finish) {
		localFinish = localTime(finish);
		finishDate = new Date(localFinish);
		if(current > finishDate) {
			late = true;
		}
	}
	return late;

}

function downloadPdf(language, orientation, include_references, launched_only, sIdent, instanceId, pdfTemplateId) {

	var docURL = "/surveyKPI/pdf/" + sIdent
		+ "?language=" + language
		+ "&instance=" + instanceId
		+ "&pdftemplate=" + pdfTemplateId
		+ "&tz=" + globals.gTimezone;
	if(orientation === "landscape") {
		docURL += "&landscape=true";
	}
	if(include_references) {
		docURL += "&reference_surveys=true";
	}
	if(launched_only) {
		docURL += "&launched_only=true";
	}

	downloadFile(docURL);
}

function downloadFile(url) {

	url += addCacheBuster(url);
	$("body").append("<iframe src='" + url + "' style='display: none;' ></iframe>");
	// Check for errors allow 5 seconds for an error to be returned
	setTimeout(downloadFileErrorCheck, 5000);
}

// Show an error generated by file download
function downloadFileErrorCheck() {
	var msg = $("iframe").last().contents().find('body').html();
	if(msg && msg.indexOf("Error:") === 0) {
		alert(msg.substring(7));	// Jump over "Error: "
	} else if(msg && msg.length > 0) {
		alert(msg);
	}
}

/*
 * Post data to be converted into a file
 */
function generateFile(url, filename, format, mime, data, sId, groupSurvey, title, project, charts, chartData, settings, tz, form) {

	var payload = "sId=" + sId;
	payload += "&format=" + format;
	if(groupSurvey) {
		payload += "&groupSurvey=" + groupSurvey;
	}
	if(form) {
		payload += "&form=" + form;
	}
	if(data) {
		payload += "&data=" + encodeURIComponent(JSON.stringify(data));
	}
	if(title) {
		payload += "&title=" + title;
	}
	if(project) {
		payload += "&project=" + project;
	}
	if(charts) {
		payload += "&charts=" + encodeURIComponent(JSON.stringify(charts));
	}
	if(chartData) {
		payload += "&chartdata=" + encodeURIComponent(JSON.stringify(chartData));
	}
	if(settings) {
		payload += "&settings=" + encodeURIComponent(JSON.stringify(settings));
	}
	if(tz) {
		payload += "&tz=" + encodeURIComponent(JSON.stringify(tz));
	}
	payload = payload.replace(/%20/g, '+');

	var xhr = new XMLHttpRequest();
	xhr.open('POST', url, true);
	xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	xhr.responseType = 'blob';

	xhr.onload = function(e) {
		if (this.status == 200) {
			// get binary data as a response
			var blob = new Blob([this.response], { type: mime });
			var downloadUrl = URL.createObjectURL(blob);
			var a = document.createElement("a");
			a.href = downloadUrl;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			setTimeout(function(){
				document.body.removeChild(a);
				window.URL.revokeObjectURL(url);
			}, 100);
		} else {
			alert(localise.set["c_error"] + ": " + this.statusText);
		}
	};

	xhr.onerror = function(e) {
		alert("Error: Upload Failed");
	}
	xhr.send(payload);

}

/*
 * Post data to be converted into a file
 * This version creates a temporary file on the server
 */
function sendReports(url, filename, format, mime, data, sId, managedId, title, project, charts) {

	var update = {
		sId: sId,
		format: format,
		managedId: managedId,
		data: data,
		title: title,
		project: project,
		charts: charts
	}
	var saveString = JSON.stringify(update);

	addHourglass();
	$.ajax({
		type: "POST",
		dataType: 'text',
		cache: false,
		contentType: "application/json",
		url: url,
		data: { report: saveString },
		success: function(data, status) {
			removeHourglass();

		}, error: function(data, status) {
			removeHourglass();
			alert(data.responseText);
		}
	});

}

/*
 * Get the currently selected rows of datatable data as a json array
 * Also convert the JSON object into an array of Key values pairs. This allows easy converion
 * to a java object on the server
 */
function getTableData(table, columns, format) {

	var rows = table.rows({
		order:  'current',  // 'current', 'applied', 'index',  'original'
		page:   'all',      // 'all',     'current'
		search: 'applied',     // 'none',    'applied', 'removed'
	}).data();

	var data = [],
		cols = [],
		i, j;

	for(i = 0; i < rows.length; i++) {
		cols = [];
		for(j = 0; j < columns.length; j++) {
			if(format === "xlsx" || !columns[j].hide) {
				var k = columns[j].displayName;
				var v = rows[i][columns[j].column_name];

				if (typeof v !== "string") {
					v = JSON.stringify(v);
				}
				cols.push({
					k: k,
					v: v
				})
			}
		}
		data.push(cols);
	}

	return data;


}

/*
 * Get server settings
 */
function getMapboxDefault(callback, param) {

	if(!globals.gMapboxDefault) {
		addHourglass();
		$.ajax({
			url: '/surveyKPI/server/mapbox',
			cache: false,
			success: function(data) {
				removeHourglass();
				globals.gMapboxDefault = data;
				if(typeof callback === "function") {
					callback(param);
				}
			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert(localise.set["error"] + ": " + err);
				}
			}
		});
	} else {
		if(typeof callback === "function") {
			callback(param);
		}
	}
}


/*
 * Get google map api
 */
function getGoogleMapApi(callback, map) {

	console.log("getGoogleMapApi");

	if(!window.smapLoadedGMaps && !window.smapGMapsLoading) {
		console.log("about to call server");

		window.smapGMapsLoading = true;

		window.smapGMapsToLoad = [];
		window.smapGMapsToLoad.push({
			fn: callback,
			locn: map
		});

		addHourglass();
		$.ajax({
			url: '/surveyKPI/server/googlemaps',
			cache: false,
			success: function(data) {

				removeHourglass();
				console.log("Retrieved map keys from server");

				var gElement = document.createElement('script');
				var key = "";
				if(data) {
					key = "?key=" + data;
				}
				//gElement.src = "//maps.google.com/maps/api/js?v=3.6&amp";
				gElement.src = "https://maps.googleapis.com/maps/api/js" + key;
				if(typeof callback === "function") {
					gElement.onload = onLoad;
				}
				document.getElementsByTagName('head')[0].appendChild(gElement);

				function onLoad() {

					var i;

					window.smapGMapsLoading = false;
					window.smapLoadedGMaps = true;

					console.log("Google map loaded");

					for(i = 0; i < window.smapGMapsToLoad.length; i++) {
						console.log("map callback");
						window.smapGMapsToLoad[i].fn(window.smapGMapsToLoad[i].locn);
					}
					delete window.smapGMapsToLoad;
				}

			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert(localise.set["error"] + " " + err);

				}
			}
		});

	} else if(window.smapLoadedGMaps) {
		console.log("Already loaded calling map callback");
		callback(map);
	} else {
		console.log("Adding callback to queue");
		window.smapGMapsToLoad.push({
			fn: callback,
			locn: map
		});
	}
}

/*
 * Add google layers to a map
 */
function addGoogleMapLayers(map) {
	try {
		map.addLayer(new OpenLayers.Layer.Google("Google Satellite",{type: google.maps.MapTypeId.SATELLITE, 'sphericalMercator': true, numZoomLevels: 22}));
		map.addLayer(new OpenLayers.Layer.Google("Google Maps",{type: google.maps.MapTypeId.ROADMAP, 'sphericalMercator': true, numZoomLevels: 22}));
		map.addLayer(new OpenLayers.Layer.Google("Google Hybrid",{type: google.maps.MapTypeId.HYBRID, 'sphericalMercator': true, numZoomLevels: 22}));
	} catch (err) {
		// Fail silently, the user may not want google maps - this is probably caused by a missing maps api key
	}
}

function remoteSurveyChanged() {
	$('#fwd_rem_survey_id').val($('#fwd_rem_survey :selected').val());
	$('#fwd_rem_survey_nm').val($('#fwd_rem_survey :selected').text());
}

/*
 * Get a list of custom reports
 */
function getReports(callback1, callback2, type) {

	var url="/surveyKPI/custom_reports";

	if(type) {
		url += "?type=" + type;
	}

	addHourglass();
	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			var cb1 = callback1,
				cb2 = callback2,
				t = type;
			globals.gReports = data;
			if(typeof cb1 === "function") {
				cb1(data, cb1, cb2, t);
			}
			if(typeof cb2 === "function") {
				cb2(data, cb1, cb2, t);
			}

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				console.log("Error: Failed to get list of reports: " + err);
			}
		}
	});

}

/*
 * Allow the user to pick a report
 */
function showReportList(data) {
	var h = [],
		idx = -1,
		i;

	removeHourglass();

	if(data.length === 0) {

		// Enable / disable elements specifically for managed forms
		$('.selectmanaged').show();
		$('.no_oversight').show();
	} else {
		$('.no_oversight').hide();
		$('.selectmanaged').show();

		h[++idx] = '<option value="0">';
		h[++idx] = localise.set["c_none"];
		h[++idx] = '</option>';
		for(i = 0; i < data.length; i++) {
			h[++idx] = '<option value="';
			h[++idx] = data[i].id;
			h[++idx] = '">';
			h[++idx] = htmlEncode(data[i].name);
			h[++idx] = '</option>';
		}
		$('.customReportList').empty().html(h.join(''));
	}
}

/*
 * Show the Custom Reports in a table
 */
function refreshCustomReportView(data, callback1, callback2, type) {

	var $selector = $('#cr_list'),
		i,
		h = [],
		idx = -1;

	$('.panel_msg').show();
	$('#addReportPopup').modal("hide");

	data = data || [];
	globals.gReports = data;

	h[++idx] = '<table class="table">';
	h[++idx] = '<thead>';
	h[++idx] = '<tr>';
	h[++idx] = '<th>' + localise.set["c_name"], + '</th>';
	h[++idx] = '<th>' + localise.set["c_type"] + '</th>';
	h[++idx] = '</tr>';
	h[++idx] = '</thead>';
	h[++idx] = '<tbody class="table-striped">';

	for(i = 0; i < data.length; i++) {

		h[++idx] = '<tr>';

		// name
		h[++idx] = '<td>';
		h[++idx] = data[i].name;
		h[++idx] = '</td>';

		// type
		h[++idx] = '<td>';
		h[++idx] = data[i].type;
		h[++idx] = '</td>';

		// actions
		h[++idx] = '<td>';

		h[++idx] = '<button type="button" data-idx="';
		h[++idx] = i;
		h[++idx] = '" class="btn btn-default btn-sm rm_cr">';
		h[++idx] = '<i class="fa fa-trash-o"></i></button>';

		h[++idx] = '<button type="button" data-idx="';
		h[++idx] = i;
		h[++idx] = '" class="btn btn-default btn-sm download_cr">';
		h[++idx] = '<i class="fa fa-download"></i></button>';

		h[++idx] = '</td>';
		// end actions

		h[++idx] = '</tr>';
	}

	h[++idx] = '</tbody>';
	h[++idx] = '</table>';

	$selector.empty().append(h.join(''));

	$(".rm_cr", $selector).click(function(){
		var idx = $(this).data("idx");
		if(confirm(localise.set["msg_confirm_del"] + " " + globals.gReports[idx].name)) {
			deleteCustomReport(globals.gReports[idx].id, type);
		}
	});

	$(".download_cr", $selector).click(function(){
		var idx = $(this).data("idx");
		downloadFile("/surveyKPI/custom_reports/xls/" + globals.gReports[idx].id +
			"?filetype=xls&filename=" + cleanFileName(globals.gReports[idx].name));
	});


}

function deleteCustomReport(id, type) {

	var url = "/surveyKPI/custom_reports/" + id;
	if(type) {
		url += "?type=" + type;
	}

	addHourglass();
	$.ajax({
		type: "DELETE",
		url: url,
		success: function(data, status) {
			removeHourglass();
			var t = type;
			console.log("delete: " + t + " : " + type);
			getReports(refreshCustomReportView, showReportList, t);
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["msg_err_del"] + xhr.responseText);
			}
		}
	});
}

/*
 * Get the list of available roles from the server
 */
function getRoles(callback) {
	addHourglass();
	$.ajax({
		url: "/surveyKPI/role/roles",
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			globals.gRoleList = data;
			if(typeof callback === "function") {
				callback();
			}
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["msg_err_get_r"] + " " + err);
			}
		}
	});
}

/*
 * Get the list of available case management settings from the server
 */
function getCms(callback) {
	addHourglass();
	$.ajax({
		url: "/surveyKPI/cases/settings/" + globals.gCurrentSurvey,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			globals.gCmSettings = data;
			if(typeof callback === "function") {
				callback();
			}
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["msg_err_get_r"] + " " + err);
			}
		}
	});
}

function getInterval(seconds) {
	if(seconds < 2) {
		return seconds + ' ' + localise.set["i_sec"];
	} else if(seconds < 60) {
		return seconds + ' ' + localise.set["i_secs"];
	} else if(seconds < 120) {
		return Math.floor(seconds/ 60) + ' ' + localise.set["i_min"];
	} else if(seconds < 3600) {
		return Math.floor(seconds/ 60) + ' ' + localise.set["i_mins"];
	} else if(seconds < (3600 * 2)) {
		return Math.floor(seconds/ (60 * 60)) + ' ' + localise.set["i_hour"];
	} else if(seconds < (3600 * 24)) {
		return Math.floor(seconds/ (60 * 60)) + ' ' + localise.set["i_hours"];
	} else if(seconds < (3600 * 24 * 2)) {
		return Math.floor(seconds/ (60 * 60 * 24)) + ' ' + localise.set["i_day"];
	} else if(seconds < (3600 * 24)) {
		return Math.floor(seconds/ (60 * 60 * 24)) + ' ' + localise.set["i_days"];
	}
}

/*
 * Clean the filename so that it can be passed in a URL
 */
function cleanFileName(filename) {

	var n;

	n = filename.replace(/\//g, '_');	// remove slashes from the filename
	n = n.replace(/[#?&]/g, '_');		// Remove other characters that are not wanted
	n = n.replace("'", "", 'g');		// Remove apostrophes

	return n;
}

/*
 * Convert a :: separated string containing link information into target survey id and question id
 */
function getLinkedTarget(input) {
	var lt,
		values = [];

	if(input) {

		lt = {
			sId: 0,
			qId: 0
		}

		values = input.split("::");
		if(values.length > 0) {
			lt.sId = +values[0].trim();
		}
		if(values.length > 1) {
			lt.qId = +values[1].trim();
		}
	}

	return lt;
}

/*
 * Add a list of forms to pick from during export
 */
function addFormPickList(sMeta, checked_forms) {

	var h = [],
		idx = -1,
		i;

	// Start with the top level form
	for(i = 0; i < sMeta.forms.length; i++) {
		if(sMeta.forms[i].p_id == 0) {
			$(".osmforms").html(addFormToList(sMeta.forms[i], sMeta, 0, true, false, checked_forms, false));
			$(".selectforms").html(addFormToList(sMeta.forms[i], sMeta, 0, false, false, checked_forms, false));
			$(".shapeforms,.taforms").html(addFormToList(sMeta.forms[i], sMeta, 0, true, true, checked_forms, false));
			$(".shapeforms_bs4").html(addFormToList(sMeta.forms[i], sMeta, 0, true, true, checked_forms, true));
		}
	}

	$("button",".selectforms").click(function() {
		var $this = $(this),
			$check = $this.parent().find("input"),
			val,
			val_array = [];

		val = $check.val();
		val_array= val.split(":");
		if(val_array.length > 1) {
			if(val_array[1] === "true") {
				$check.val(val_array[0] + ":false");
				$this.text("Pivot");
			} else {
				$check.val(val_array[0] + ":true");
				$this.text("Flat");
			}
			$this.toggleClass('exportflat');
			$this.toggleClass('exportpivot');
		}

		return false;
	});
}

/*
 * Add a list of date questions to pick from
 */
function addDatePickList(sMeta, currentDate) {

	var h = [],
		idx = -1,
		i,
		value,
		key;

	if(sMeta && sMeta.dates) {
		for(i = 0; i < sMeta.dates.length; i++) {

			key = sMeta.dates[i].name;

			h[++idx] = '<option value="';
			h[++idx] = sMeta.dates[i].id;
			h[++idx] = '">';
			if(key === "Upload Time" || key === "_start" || key === "_end") {
				key = localise.set[key];
			} else if(key === "Scheduled Start") {
				key = localise.set["c_scheduled"]
			}
			h[++idx] = htmlEncode(key);
			h[++idx] = '</option>';

		}

		$(".date_question").empty().html((h.join('')));

		if(typeof currentDate !== "undefined" && currentDate != 0) {
			value = currentDate;
		} else {
			value = $("#settings_date_question").val();
		}
	}
}

/*
 * Add a list of geometry questions to pick from
 */
function addGeomPickList(sMeta) {

	var h = [],
		k = [],
		idx = -1,
		i,
		value,
		theForm;

	if(sMeta && sMeta.forms) {
		for(i = 0; i < sMeta.forms.length; i++) {

			theForm = sMeta.forms[i];

			k[++idx] = h[++idx] = '<div class="exportcontrol showshape showosm" style="display: block;">';
			k[++idx] = h[++idx] = '<label>' + theForm.form + '</label>';
			h[++idx] = '<select class="geomSelect" id="geomForm_' + theForm.f_id;            // export only
			k[++idx] = '<select class="geomSelect" id="geomSettingsForm_' + theForm.f_id;    // Settings only
			k[++idx] = h[++idx] = '" data-form="' + theForm.f_id + '">';
			if(theForm.geomQuestions) {
				for(j = 0; j < theForm.geomQuestions.length; j++) {
					k[++idx] = h[++idx] = '<option value="';
					k[++idx] = h[++idx] = theForm.geomQuestions[j];
					k[++idx] = h[++idx] = '">';
					k[++idx] = h[++idx] = htmlEncode(theForm.geomQuestions[j]);
					k[++idx] = h[++idx] = '</option>';
				}
			}
			k[++idx] = h[++idx] = '</select>';
			k[++idx] = h[++idx] = '</div>';

		}

		$(".geomselect_export").empty().html((h.join('')));
		$(".geomselect_settings").empty().html((k.join('')));

		shapeFormsChanged();

	}
}

function shapeFormsChanged() {
	var formId = getSelectedForm('.shapeforms', true);
	if(formId) {
		$('.geomSelect', '.geomselect_export').prop('disabled', true);
		$('#geomForm_' + formId, '.geomselect_export').prop('disabled', false);
	}
}

function getSelectedForm($forms, ignoreError) {
	var forms = $(':radio:checked', $forms).map(function() {
		return this.value;
	}).get();
	if(forms.length === 0) {
		if(!ignoreError) {
			alert(window.localise.set["msg_one_f2"]);
		}
		return 0;
	}
	return forms[0];
}

function addFormToList(form, sMeta, offset, osm, set_radio, checked_forms, bs4) {

	var h = [],
		idx = -1,
		i,
		type,
		checked;

	if (set_radio) {
		type = "radio";
	} else {
		type = "checkbox";
	}

	// Set checked value based on previous selections
	if(set_radio && offset == 0) {
		checked = 'checked="checked"';
	} else {
		if (offset == 0 && (!checked_forms || checked_forms.length == 0)) {
			checked = 'checked="checked"';
		} else {
			checked = '';
		}
	}
	if(checked_forms && checked_forms.length > 0) {
		for(i = 0; i < checked_forms.length; i++) {
			if(form.f_id == checked_forms[i]) {
				checked = 'checked="checked"';
				break;
			}
		}
	}

	h[++idx] = '<div class="' + type + '"';
	h[++idx] = '<span style="padding-left:';
	h[++idx]= offset + 'px;">';
	h[++idx] = '<label>';
	h[++idx] = '<input class="osmform" type="' + type + '" ' + checked + ' name="osmform" value="';
	h[++idx] = form.f_id;
	if(!osm) {
		h[++idx] = ':false"/>';
	} else {
		h[++idx] = '">';
	}
	if(bs4) {
		h[++idx] = '<span class="ml-2">';
	}
	h[++idx] = form.form;
	if(bs4) {
		h[++idx] = '</span>';
	}
	h[++idx] = '</label>';
	if(form.p_id != 0 && !osm) {
		h[++idx] = ' <button class="exportpivot">Pivot</button>';
	}
	h[++idx]= '</div>';

	// Add the children (recursively)
	for(i = 0; i < sMeta.forms.length; i++) {
		if(sMeta.forms[i].p_id != 0  && sMeta.forms[i].p_id == form.f_id) {
			h[++idx] = addFormToList(sMeta.forms[i], sMeta, offset + 20, osm, set_radio, checked_forms, bs4);
		}
	}

	return h.join('');
}

function getViewLanguages(view) {

	if(view.sId != -1) {
		var url = languageListUrl(view.sId);
		$.getJSON(url, function(data) {
			globals.gSelector.setSurveyLanguages(view.sId, data);
			setSurveyViewLanguages(data, view.lang, '#settings_language', false);
			setSurveyViewLanguages(data, view.lang, '#export_language', true);
		});
	}

}

function validateEmails(emails) {
	var valid = true,
		i;
	if(emails && emails.trim().length > 0) {
		var emailArray = emails.split(",");
		for (i = 0; i < emailArray.length; i++) {
			var validEmail = /[A-Z0-9._%+-]+@[A-Z0-9.-]+.[A-Z]{2,4}/igm;
			if (!validEmail.test(emailArray[i])) {
				valid = false;
				break;
			}
		}
	}
	return valid;
}

/*
 * Prevent the menu bar from extending over two lines
 */
// From: http://stackoverflow.com/questions/20247945/bootstrap-3-navbar-dynamic-collapse
/*
function autocollapse() {
	var $navbar = $('#autocollapse');
    $navbar.removeClass('collapsed'); 
    if($navbar.innerHeight() > 60) // check if we've got 2 lines
        $navbar.addClass('collapsed'); // force collapse mode
}

$(document).on('ready', autocollapse);
$(window).on('resize', autocollapse);
*/

/*
 * Get the roles for a survey
 */
function getSurveyRoles(sId, selectedRoles, setall) {

	if (!gTasks.cache.surveyRoles[sId]) {
		addHourglass();
		$.ajax({
			url: "/surveyKPI/role/survey/" + sId + "?enabled=true",
			dataType: 'json',
			cache: false,
			success: function (data) {
				removeHourglass();
				gTasks.cache.surveyRoles[sId] = data;
				showRoles(gTasks.cache.surveyRoles[sId], selectedRoles);
			},
			error: function (xhr, textStatus, err) {

				removeHourglass();
				if (xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					console.log("Error: Failed to get roles for a survey: " + err);
				}
			}
		});
	} else {
		showRoles(gTasks.cache.surveyRoles[sId], selectedRoles, setall);
	}
}

/*
 * Show the roles
 */
function showRoles(data, selectedRoles, setall) {

	var h = [],
		idx = -1,
		i;

	$('.role_select_roles').empty();
	if (data.length > 0) {
		for (i = 0; i < data.length; i++) {
			h[++idx] = '<div class="col-sm-10 custom-control custom-checkbox ml-2 mb-1">'
			h[++idx] = '<input type="checkbox"';
			h[++idx] = ' id="rolesel_' + i + '"';
			if(setall || roleSelected(data[i].id, selectedRoles)) {
				h[++idx] = ' checked="checked"';
			}
			h[++idx] = ' class="custom-control-input" value="';
			h[++idx] = data[i].id;
			h[++idx] = '">';

			h[++idx] = '<label class="custom-control-label"';
			h[++idx] = ' for="rolesel_' + i + '">';
			h[++idx] = 	data[i].name;
			h[++idx] = '</label>';
			h[++idx] = '</div>';

			/*
			h[++idx] = '<div class="checkbox">';
			h[++idx] = '<label><input type="checkbox" value="';
			h[++idx] = data[i].id;
			h[++idx] = '"';
			if(setall || roleSelected(data[i].id, selectedRoles)) {
				h[++idx] = ' checked';
			}
			h[++idx] = '>';
			h[++idx] = data[i].name;
			h[++idx] = '</label>';
			h[++idx] = '</div>';
			*/

		}
		$('.role_select').show();
		$('.role_select_roles').empty().append(h.join(''));
	}
}

function roleSelected(roleId, selectedRoles) {
	var sel = false;
	if(selectedRoles) {
		for(var i = 0; i < selectedRoles.length; i++) {
			if(selectedRoles[i].id == roleId) {
				sel = true;
				break;
			}
		}
	}
	return sel;
}

 /*
  * Get all the surveys that a user can access
  */
function getAccessibleSurveys($elem, includeNone, includeBlocked, groupsOnly, includeSelf) {

	var url="/surveyKPI/surveys";
	var hasParam = false;
	if(includeBlocked) {
		url += hasParam ? '&' : '?';
		url += 'blocked=true';
		hasParam = true;
	}
	if(groupsOnly) {
		url += hasParam ? '&' : '?';
		url += 'groups=true';
		hasParam = true;
	}

	addHourglass();
	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			var h = [],
				idx = -1,
				i;

			if(includeNone) {
				h[++idx] = '<option value="">';
				h[++idx] = localise.set["c_none"]
				h[++idx] = '</option>';
			}

			if(includeSelf) {
				h[++idx] = '<option value="self">';
				h[++idx] = localise.set["c_self"]
				h[++idx] = '</option>';
			}
			for(i = 0; i < data.length; i++) {
				h[++idx] = '<option value="';
				h[++idx] = data[i].ident;
				h[++idx] = '">';
				h[++idx] = data[i].projectName;
				h[++idx] = ' : ';
				h[++idx] = data[i].displayName;
				h[++idx] = '</option>';
			}
			$elem.empty().append(h.join(''));

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				console.log("Error: Failed to get list of surveys: " + err);
			}
		}
	});
}

/*
 * Get all the csv files that a user can access
 */
function getAccessibleCsvFiles($elem, includeNone) {

	var url="/surveyKPI/csv/files";

	addHourglass();
	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			globals.gCsvFiles = data;
			var h = [],
				idx = -1,
				i;

			if(includeNone) {
				h[++idx] = '<option value="">';
				h[++idx] = localise.set["c_none"]
				h[++idx] = '</option>';
			}
			for(i = 0; i < data.length; i++) {
				h[++idx] = '<option value="';
				h[++idx] = i;
				h[++idx] = '">';
				h[++idx] = htmlEncode(data[i].filename);
				h[++idx] = '</option>';
			}
			$elem.empty().append(h.join(''));

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				console.log("Error: Failed to get list of csv files: " + err);
			}
		}
	});
}

 /*
  * Get the questions in a survey
  */
function getQuestionsInSurvey($elem, sIdent, includeNone, textOnly, callback, includeHrk) {

	function populateElement($elem, data) {
		var h = [],
			idx = -1,
			i,
			setValueFn = callback;

		if (includeNone) {
			h[++idx] = '<option value="">';
			h[++idx] = localise.set["c_none"];
			h[++idx] = '</option>';
		}
		if (includeHrk) {
			h[++idx] = '<option value="_hrk">';
			h[++idx] = localise.set["ed_hrk"];
			h[++idx] = '</option>';
		}
		for (i = 0; i < data.length; i++) {
			if(!textOnly || isTextStorageType(data[i].type)) {
				h[++idx] = '<option value="';
				h[++idx] = data[i].name;
				h[++idx] = '">';
				h[++idx] = htmlEncode(data[i].name);
				h[++idx] = '</option>';
			}
		}
		$elem.empty().append(h.join(''));

		if(typeof setValueFn === "function") {
			setValueFn();
		}
	}

	if(sIdent === 'self') {
		populateElement($elem, globals.model.survey.forms[globals.gFormIndex].questions);
	} else if(gCache[sIdent]) {
		populateElement($elem, gCache[sIdent]);
	} else {
		if (sIdent !== "0") {
			addHourglass();
			$.ajax({
				url: "/surveyKPI/questionListIdent/" + sIdent + "/none?exc_ssc=true",
				dataType: 'json',
				cache: false,
				success: function (data) {
					removeHourglass();
					var theIdent = sIdent;
					var $theElem = $elem;

					gCache[theIdent] = data;
					populateElement($theElem, data);
				},
				error: function (xhr, textStatus, err) {
					removeHourglass();
					if (xhr.readyState == 0 || xhr.status == 0) {
						return;  // Not an error
					} else {
						alert(localise.set["msg_err_get_q"] + ": " + err);
					}
				}
			});
		} else {
			if (includeNone) {
				$elem.empty().append('option value="0">' + localise.set["c_none"] + '</option>');
			}
		}
	}

}

function getQuestionsInCsvFile($elem, index, includeNone) {
	var h = [],
		idx = -1,
		i;
	var data = globals.gCsvFiles[index].headers;

	if (includeNone) {
		h[++idx] = '<option value="">';
		h[++idx] = localise.set["c_none"];
		h[++idx] = '</option>';
	}
	for (i = 0; i < data.length; i++) {
		h[++idx] = '<option value="';
		h[++idx] = data[i].fName;
		h[++idx] = '">';
		h[++idx] = htmlEncode(data[i].fName);
		h[++idx] = '</option>';
	}
	$elem.empty().append(h.join(''));
}

/*
 * Get the questions in a survey
 */
function getGroupQuestionsInSurvey($elem, sIdent) {

	function populateElement($elem, data) {
		var h = [],
			idx = -1,
			i;

		h[++idx] = '<option data-type="" value="">';
		h[++idx] = localise.set["c_none"];
		h[++idx] = '</option>';

		for (i = 0; i < data.length; i++) {
			h[++idx] = '<option data-type="';
			h[++idx] = data[i].type;
			h[++idx] = '" value="';
			h[++idx] = data[i].name;
			h[++idx] = '">';
			h[++idx] = htmlEncode(data[i].name);
			h[++idx] = '</option>';
		}
		$elem.empty().append(h.join(''));
	}

	if(gCacheGroup[sIdent]) {
		populateElement($elem, gCacheGroup[sIdent]);
	} else {
		if (sIdent !== "0") {
			addHourglass();
			$.ajax({
				url: "/surveyKPI/questionListIdent/" + sIdent + "/none/group",
				dataType: 'json',
				cache: false,
				success: function (data) {
					removeHourglass();
					var theIdent = sIdent;
					var $theElem = $elem;

					gCacheGroup[theIdent] = data;
					populateElement($theElem, data);

				},
				error: function (xhr, textStatus, err) {
					removeHourglass();
					if (xhr.readyState == 0 || xhr.status == 0) {
						return;  // Not an error
					} else {
						alert(localise.set["msg_err_get_q"] + ": " + err);
					}
				}
			});
		} else {
			if (includeNone) {
				$elem.empty().append('option value="0">' + localise.set["c_none"] + '</option>');
			}
		}
	}

}

/*
 * Get the questions suitable for use as a status in a survey group using the survey id as the key
 */
function getGroupStatusQuestions($elem, sId) {

	function populateElement($elem, data) {
		var h = [],
			idx = -1,
			i;

		for (i = 0; i < data.length; i++) {
			h[++idx] = '<option value="';
			h[++idx] = data[i].column_name;
			h[++idx] = '">';
			h[++idx] = htmlEncode(data[i].name);
			h[++idx] = '</option>';
		}
		$elem.empty().append(h.join(''));
	}

	if(gCacheStatusQuestions[sId]) {
		populateElement($elem, gCacheStatusQuestions[sId]);
	} else {
		addHourglass();
		$.ajax({
			url: "/surveyKPI/questionList/" + sId + "/none/group?status=true",
			dataType: 'json',
			cache: false,
			success: function (data) {
				removeHourglass();
				var theId = sId;
				var $theElem = $elem;

				gCacheStatusQuestions[theId] = data;
				populateElement($theElem, data);

			},
			error: function (xhr, textStatus, err) {
				removeHourglass();
				if (xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert(localise.set["msg_err_get_q"] + ": " + err);
				}
			}
		});
	}
}

function tokenizeAppearance(input) {
	var chunks = [];
	var tokens = [];
	var chunkTokens = [];
	var i;
	var j;
	var chunk;

	// only search/lookup_choices needs special treatment
	var idx1 = input.indexOf('search');
	if(idx1 < 0) {
		idx1 = input.indexOf('lookup_choices');
	}
	if(idx1 >= 0) {
		chunks.push({
			val:input.substring(0, idx1),
			type: "text"
		});
		if(idx1 < input.length) {
			var idx2 = input.lastIndexOf(')');
			if(idx2 >= 0) {
				chunks.push({
					val: input.substring(idx1, idx2 + 1),
					type: "fn"
				});
				if(idx2 < input.length) {
					chunks.push({
						val: input.substring(idx2 + 1),
						type: "text"
					});
				}
			}
		}
	} else {
		chunks.push({
			val: input,
			type: "text"
		});
	}
	for(i = 0; i < chunks.length; i++) {
		chunk = chunks[i].val.trim();
		if(chunk.length > 0) {
			if(chunks[i].type === "text") {
				chunkTokens = chunk.split(/(\s+)/);
			} else {
				chunkTokens = [];
				chunkTokens.push(chunk);
			}
			for(j = 0; j < chunkTokens.length; j++) {
				if(chunkTokens[j].trim().length > 0) {
					tokens.push(chunkTokens[j].trim());
				}
			}
		}
	}
	return tokens;
}

function setOrganisationTheme() {

	if(globals.gSetAsTheme && globals.gOrgId > 0) {

		var mainLogoSrc = getFromLocalStorage("main_logo");
		var logo = "/media/organisation/" + globals.gOrgId + '/settings/mainLogo';
		if(mainLogoSrc !== logo) {
			setInLocalStorage('main_logo', logo);
			$('.main_logo').attr("src", "/media/organisation/" + globals.gOrgId + '/settings/mainLogo');
		}

		// navbar color
		var navbarColor = getFromLocalStorage("navbar_color");
		if(navbarColor !== globals.gNavbarColor) {
			setInLocalStorage('navbar_color', globals.gNavbarColor);
		}
		// navbar color
		var navbarTextColor = getFromLocalStorage("navbar_text_color");
		if(navbarTextColor !== globals.gNavbarTextColor) {
			setInLocalStorage('navbar_text_color', globals.gNavbarTextColor);
		}
	} else {
		// remove styles
		var navbarColorElement = document. getElementById("navbar_color");
		if(navbarColorElement) {
			navbarColorElement.parentNode.removeChild(navbarColorElement);
		}
		setInLocalStorage('navbar_color', undefined);
		setInLocalStorage('navbar_text_color', undefined);
		setInLocalStorage('main_logo', undefined);

		// Set the default logo
		if(typeof setCustomMainLogo === "function") {
			setCustomMainLogo();
		}
	}
}

/*
 * Surround get / set from local storage in case user has disabled local sorage reading in browser settings
 */
function getFromLocalStorage(key) {
	var value;
	try {
		value = localStorage.getItem(key);
	} catch (e) {

	}
	return value;
}

function setInLocalStorage(key, value) {
	try {
		localStorage.setItem(key, value);
	} catch(e) {

	}
}

function populateTaskGroupList() {
	if (typeof globals.gCurrentProject !== "undefined" && globals.gCurrentProject != -1) {
		addHourglass();
		$.ajax({
			url: "/surveyKPI/tasks/taskgroups/" + globals.gCurrentProject,
			cache: false,
			dataType: 'json',
			success: function (taskgroups) {
				removeHourglass();

				var h = [],
					idx = -1,
					i,
					grp,
					firstTg,
					hasCurrentTg = false;

				window.gTaskGroups = taskgroups;   // Keep the task group list

				if (typeof taskgroups != "undefined" && taskgroups.length > 0) {

					for (i = 0; i < taskgroups.length; i++) {
						grp = taskgroups[i];
						h[++idx] = '<option value="';
						h[++idx] = i;
						h[++idx] = '">';
						h[++idx] = htmlEncode(grp.name);
						h[++idx] = '</option>';
					}
				}
				$('.task_group_select').html(h.join(''));
			},
			error: function (xhr, textStatus, err) {
				removeHourglass();
				if (xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert("Failed to get task group data");
				}
			}
		});
	}
}

/*
 * Show a loaded file as an image
 * From https://codepen.io/adamrifai/pen/YXdEwz
 */
function displayAsImage(file, img) {

	var imgURL = URL.createObjectURL(file);
	img.onload = function() {
		URL.revokeObjectURL(imgURL);
	};

	img.src = imgURL;
}

/*
 * If debug=yes is passed as a parameter then enable debuging statement
 */
function enableDebugging() {

	if(location.search.indexOf("debug=yes") >= 0) {
		$(document).on('click', function(e) { console.log(e.target) });
	}

}

/*
 * ----------------------------------------------------
 * Common task functions shared between task managmeent page and console
 */
function setupAssignType(user_id, role_id, emails, email_question) {
	$('.assign_group').hide();
	$('.assign_type').removeClass('active');
	if(user_id != 0) {
		$('.user_type_checkbox').addClass('active');
		$('.assign_user').show();
	} else  if(role_id != 0) {
		$('.role_type_checkbox').addClass('active');
		$('.assign_role').show();
	} else if((typeof emails !== "undefined" && emails.trim().length > 0)
			|| (typeof email_question !== "undefined" && email_question.trim().length > 0)) {
		$('.email_type_checkbox').addClass('active');
		$('.assign_email').show();
	} else {        // Default to user
		$('.user_type_checkbox').addClass('active');
		$('.assign_user').show();
	}
}

// Convert a location name into a location index
function getLocationIndex(name, tags) {
	var idx = -1,
		i;

	if(tags) {
		for(i = 0; i < tags.length; i++) {
			if(tags[i].name == name) {
				idx = i;
				break;
			}

		}
	}
	return idx;

}

function saveTask(isConsole, currentTaskFeature, saveType, updateId, callback, tg_id) {
	var url = "/api/v1/tasks?preserveInitialData=true",
		taskFeature = {
			properties: {}
		},
		fromDate,
		toDate,
		MIN_SHOW_RANGE = 10;

	taskFeature = $.extend(true, {}, currentTaskFeature);
	taskFeature.properties.assignee_ident = undefined;
	taskFeature.properties.assignee_name = undefined;

	/*
	 * Set the properties of the taskFeature from the dialog
	 */
	taskFeature.properties.pid = globals.gCurrentProject;
	taskFeature.properties.tg_id = tg_id;

	if (!taskFeature.properties.id || taskFeature.properties.id == "") {
		taskFeature.properties["id"] = 0;
	}
	taskFeature.properties.name = $('#tp_name').val();		// task name
	if(isConsole) {
		taskFeature.properties.survey_ident = $('#tp_form_name').val();	// form id
		taskFeature.properties.form_id = undefined;
	} else {
		// old fashioned
		taskFeature.properties.form_id = $('#tp_form_name').val();	// form id
		taskFeature.properties.survey_ident = undefined;
	}

	taskFeature.properties.assign_type = $("button.assign_type.active", "#task_properties").attr("id");
	if(taskFeature.properties.assign_type == 'tp_user_type') {
		taskFeature.properties.assignee = $('#tp_user').val();
		taskFeature.properties.emails = undefined;
	} else if(taskFeature.properties.assign_type == 'tp_email_type') {
		taskFeature.properties.assignee = 0;
		taskFeature.properties.emails = $('#tp_assign_emails').val();
		if(!validateEmails(taskFeature.properties.emails)) {
			alert(localise.set["msg_inv_email"]);
			return false;
		}
	}

	if(isConsole) {
		taskFeature.properties.update_id = updateId;
		taskFeature.properties.initial_data_source = 'survey';
	}

	taskFeature.properties.repeat = $('#tp_repeat').prop('checked');
	taskFeature.properties.complete_all = $('#tp_pol').prop('checked');
	taskFeature.properties.assign_auto = $('#tp_assign_auto').prop('checked');

	fromDate = $('#tp_from').data("DateTimePicker").date();
	toDate = $('#tp_to').data("DateTimePicker").date();

	// Validate dates
	if(toDate && !fromDate) {       // Can't have a to date without a from date
		alert(localise.set["msg_no_from"]);
		return false;
	}
	if(toDate && fromDate && fromDate > toDate) {       // To date must be after from date
		alert(localise.set["msg_sel_dates"]);
		return false;
	}

	if (fromDate) {
		taskFeature.properties.from = utcTime(fromDate.format("YYYY-MM-DD HH:mm:ss"));
	}
	if (toDate) {
		taskFeature.properties.to = utcTime(toDate.format("YYYY-MM-DD HH:mm:ss"));
	}

	taskFeature.properties.location_trigger = $('#nfc_uid').val();
	taskFeature.properties.guidance = $('#tp_guidance').val();
	taskFeature.properties.show_dist = $('#tp_show_dist').val();

	/*
	 * Save location group and location name
	 */
	var locationIdx = $('#location_select').val();
	if(saveType == "nl") {
		taskFeature.properties.location_group = $('#locationGroupSave').val();
		taskFeature.properties.location_name = $('#locationSave').val();
	} else if(saveType == "ul" && locationIdx != "-1") {
		taskFeature.properties.location_group = $('.location_group_list_sel').text();
		taskFeature.properties.location_name = gTags[locationIdx].name;
	} else {
		taskFeature.properties.location_group = undefined;
		taskFeature.properties.location_name = undefined;
	}
	taskFeature.properties.save_type = saveType;

	/*
	 * Convert the geoJson geometry into longitude and latitude for update
	 */
	if (currentTaskFeature.geometry) {
		if (currentTaskFeature.geometry.coordinates && currentTaskFeature.geometry.coordinates.length > 1) {
			//taskFeature.properties.location = "POINT(" + gCurrentTaskFeature.geometry.coordinates.join(" ") + ")";  // deprecate
			taskFeature.properties.lon = currentTaskFeature.geometry.coordinates[0];
			taskFeature.properties.lat = currentTaskFeature.geometry.coordinates[1];

		} else {
			//taskFeature.properties.location = "POINT(0 0)"; // deprecate
			taskFeature.properties.lon = 0;
			taskFeature.properties.lat = 0;
		}
	}

	// TODO task update details (updating existing record)

	// Validations
	if(typeof taskFeature.properties.show_dist === "undefined") {
		taskFeature.properties.show_dist = 0;
	} else {
		taskFeature.properties.show_dist = +taskFeature.properties.show_dist;
	}
	if (taskFeature.properties.show_dist && taskFeature.properties.show_dist < MIN_SHOW_RANGE) {
		alert(localise.set["msg_val_show_dist"]);
		$('#tp_show_dist').focus();
		return;
	}


	var tpString = JSON.stringify(taskFeature.properties);

	addHourglass();
	$.ajax({
		type: "POST",
		dataType: 'text',
		cache: false,
		contentType: "application/json",
		url: url,
		data: {task: tpString},
		success: function (data, status) {
			removeHourglass();
			$('#task_properties').modal("hide");
			callback();
		},
		error: function (xhr, textStatus, err) {

			removeHourglass();
			alert(localise.set["msg_err_upd"] + xhr.responseText);

		}
	});
}

/*
 * Get the list of users from the server so they can be assigned to tasks
 */
function getTaskUsers(projectId) {
	var $users = $('.users_select,#users_filter'),
		i, user,
		h = [],
		idx = -1;

	$users.empty();
	$('#users_filter').append('<option value="0">' + localise.set["t_au"] + '</options>');
	//$('#users_filter').append('<option value="-1">' + localise.set["t_u"] + '</options>');

	$('#users_select_new_task, #users_task_group, #users_select_user, #tp_user')
		.append('<option value="-1">' + localise.set["t_u"] + '</options>');

	$('#users_task_group').append('<option value="-2">' + localise.set["t_ad"] + '</options>');
	$.ajax({
		url: "/surveyKPI/userList",
		cache: false,
		success: function (data) {

			for (i = 0; i < data.length; i++) {
				user = data[i];
				// Check that this user has access to the project

				if (!projectId || userHasAccessToProject(user, projectId)) {
					h[++idx] = '<option value="';
					h[++idx] = user.id;
					h[++idx] = '">';
					h[++idx] = htmlEncode(user.name);
					h[++idx] = '</option>';
				}
			}
			$users.append(h.join(''));
		},
		error: function (xhr, textStatus, err) {
			if (xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["c_error"] + err);
			}
		}
	});
}

function userHasAccessToProject(user, projectId) {
	var i;
	if(user.projects) {
		for (i = 0; i < user.projects.length; i++) {
			if (user.projects[i].id == projectId) {
				return true;
			}
		}
	}
	return false;
}

function setupTaskDialog() {
	$('#tp_email_type, #assign_email_type').click(function() {
		$('.assign_type').removeClass('active');
		$(this).addClass('active');

		$('.assign_user, .assign_role,.assign_data').hide();
		$('.assign_email').show();
		$('#assign_data').prop('placeholder', localise.set['n_eqc']);
		$('.assign_data').show();
	});
	$('#tp_user_type, #assign_user_type').click(function() {
		$('.assign_type').removeClass('active');
		$(this).addClass('active');

		$('.assign_user').show();
		$('.assign_role,.assign_email').hide();
		if($('#users_task_group').val() == -2) {
			$('#assign_data').prop('placeholder', "");
			$('.assign_data').show();
		} else {
			$('.assign_data').hide();
		}
	});
	$('#tp_role_type, #assign_role_type').click(function() {
		$('.assign_type').removeClass('active');
		$(this).addClass('active');

		$('.assign_user, .assign_email').hide();
		$('.assign_role').show();
		if($('#roles_task_group').val() == -2) {
			$('#assign_data').prop('placeholder', "");
			$('.assign_data').show();
		} else {
			$('.assign_data').hide();
		}
	});

	$('#tp_from').datetimepicker({
		useCurrent: false,
		locale: gUserLocale || 'en'
	});

	$('#tp_to').datetimepicker({
		useCurrent: false,
		locale: gUserLocale || 'en'
	});

	$('#tp_from').on("dp.change", function () {

		var startDateLocal = $(this).data("DateTimePicker").date(),
			endDateLocal = $('#tp_to').data("DateTimePicker").date(),
			originalStart = gCurrentTaskFeature.properties.from,
			originalEnd = gCurrentTaskFeature.properties.to,
			newEndDate,
			duration;

		if (startDateLocal) {

			if (originalEnd && originalStart) {
				duration = moment(originalEnd, "YYYY-MM-DD HH:mm:ss").diff(moment(originalStart, "YYYY-MM-DD HH:mm:ss"), 'hours');
				newEndDate = startDateLocal.add(duration, 'hours');
				$('#tp_to').data("DateTimePicker").date(newEndDate);
			}
		}



	});

}

function getStatusClass(status, assign_auto) {

	var statusClass = "";

	if (status === "new") {
		if(assign_auto) {
			statusClass = "bg-orange";
		} else {
			statusClass = "bg-info";
		}
	} else if (status === "submitted" || status === "success") {
		statusClass = "bg-success";
	} else if (status === "late") {
		statusClass = "bg-danger";
	} else if (status === "accepted" || status === "pending") {
		statusClass = "bg-warning";
	} else 	if (status === "error" || status === "unsent" || status === "unsubscribed"
		|| status === "blocked" || status === "rejected" || status === "cancelled" || status === "deleted") {
		statusClass = "bg-rejected";
	} else {
		statusClass = "bg-success";
	}
	return statusClass;
}

/*
 *------------------------------------------------------------------
 * Common notification functions shared between console and notifications
 */
function edit_notification(edit, idx, console) {

	var notification;

	document.getElementById("notification_edit_form").reset();
	setTargetDependencies("email");
	setTriggerDependencies("submission");
	setAttachDependencies("none");

	if(edit) {
		notification = window.gNotifications[idx];

		title = localise.set["msg_edit_notification"];
		$('#trigger').val(notification.trigger);
		$('#target').val(notification.target);
		$('#name').val(notification.name);
		setTargetDependencies(notification.target);

		gSelectedOversightQuestion = notification.updateQuestion;
		gSelectedOversightSurvey = notification.updateSurvey;
		setTriggerDependencies(notification.trigger);
		if(notification.trigger === "console_update") {
			getOversightSurveys(notification.s_id);
		}

		setAttachDependencies(notification.notifyDetails.attach);

		if (notification.trigger !== "task_reminder") {
			$('#survey').val(notification.s_id).change();
		}
		$('#not_filter').val(notification.filter);
		$('#update_value').val(notification.updateValue);
		$('#alerts').val(notification.alert_id);

		// reminder settings
		if (!console) {
			$('#task_group').val(getTaskGroupIndex(notification.tgId));
			if ((notification.period)) {
				var periodArray = notification.period.split(" ");
				if (periodArray.length > 1) {
					$('#r_period').val(periodArray[0]);
					$('#period_list_sel').val(periodArray[1]);
				}
			}
			if(notification.trigger === "task_reminder") {
				taskGroupChanged($('#task_group').val(), notification.notifyDetails.emailQuestionName, notification.notifyDetails.emailMeta);
			}
		}

		if(notification.trigger !== "task_reminder" && (typeof notification.alert_id !== 'undefined'
			|| (notification.notify_details && (notification.notifyDetails.emailQuestionName || notification.notifyDetails.emailMeta)))) {

				surveyChangedNotification(notification.notifyDetails.emailQuestionName,
					notification.notifyDetails.emailMeta,
					notification.alert_id);
		}

		if (notification.notifyDetails) {

			if (notification.target == "email") {
				if (notification.notifyDetails.emails) {
					$('#notify_emails').val(notification.notifyDetails.emails.join(","));
				}
				$('#email_subject').val(notification.notifyDetails.subject);
				$('#email_content').val(notification.notifyDetails.content);
				$('#email_attach').val(notification.notifyDetails.attach);
				$('#include_references').prop('checked', notification.notifyDetails.include_references);
				$('#launched_only').prop('checked', notification.notifyDetails.launched_only);
			} else if (notification.target == "sms") {
				if (notification.notifyDetails.emails) {
					$('#notify_sms').val(notification.notifyDetails.emails.join(","));
				}
				$('#sms_content').val(notification.notifyDetails.content);
				$('#sms_attach').val(notification.notifyDetails.attach);
				$('#sms_sender_id').val(notification.notifyDetails.subject);
			} else if (notification.target == "webhook") {
				$('#callback_url').val(notification.notifyDetails.callback_url);
			}
		}
		if (!console) {
			$('#fwd_rem_survey_id').val(notification.remote_s_ident);
			$('#fwd_rem_survey_nm').val(notification.remote_s_name);
			$('#fwd_user,#user_to_assign').val(notification.remote_user);
			gEligibleUser = notification.remote_user;
			// Password not returned from server - leave blank

			$('#fwd_host').val(notification.remote_host);
		}

		if (!console) {
			if (notification.enabled) {
				$('#nt_enabled').prop('checked', true);
			} else {
				$('#nt_enabled').prop('checked', false);
			}
		}

		window.gUpdateFwdPassword = false;
		window.gSelectedNotification = notification.id;
	} else {

		$('#fwd_host').val(window.gRemote_host);	// Set the values to the ones last used
		$('#fwd_user').val(window.gRemote_user);

		$('#survey').change();

		// Reminders
		$('#r_period').val(1);
		$('#period_list_sel').val('days');
		$('#nt_enabled').prop('checked',true);
		window.gUpdateFwdPassword = true;
		window.gSelectedNotification = -1;
	}

}

function setTargetDependencies(target) {
	$('.forward_options, .sms_options, .webhook_options, .email_options, .escalate_options').hide();
	if(target === "email") {
		$('.email_options').show();
	} else if(target === "forward") {
		$('.forward_options').show();
	} else if(target === "sms") {
		$('.sms_options').show();
	} else if(target  === "webhook") {
		$('.webhook_options').show();
	} else if(target  === "escalate") {
		$('.escalate_options').show();
	}
}

function setTriggerDependencies(trigger) {
	$('.task_reminder_options,.update_options, .submission_options, .cm_alert_options').hide();
	if(trigger === "submission") {
		$('.submission_options').show();
	} else if(trigger === "task_reminder") {
		$('.task_reminder_options').show();
		$('#target').val('email');
		setTargetDependencies('email');
	} else if(trigger === "console_update") {
		$('.update_options, .submission_options').show();
	} else if(trigger === "cm_alert") {
		$('.cm_alert_options').show();
	}
}

function setAttachDependencies(attach) {
	if(attach === "pdf" || attach === "pdf_landscape") {
		$('.pdf_options').show();
	} else  {
		$('.pdf_options').hide();
	}
}

/*
	 * Update the notification list
	 */
function updateNotificationTypes(data) {

	var $selector=$('#target'),
		i,
		h = [],
		idx = -1;

	for(i = 0; i < data.length; i++) {

		h[++idx] = '<option value="';
		h[++idx] = data[i];
		//if(data[i] === 'forward') {
		//	h[++idx] = '" class="submission_options';
		//}
		h[++idx] = '">';
		h[++idx] = localise.set["c_" + data[i]];
		h[++idx] = '</option>';
	}

	$selector.empty().append(h.join(''));

}

/*
 * Load the existing notifications from the server
 */
function getNotificationTypes() {

	addHourglass();
	$.ajax({
		url: '/surveyKPI/notifications/types',
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			window.gNotificationTypes = data;
			if(data) {
				updateNotificationTypes(data);
			}
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				console.log("Error: Failed to get list of notification types: " + err);
			}
		}
	});
}

function setupNotificationDialog() {
	// Set change function trigger
	$('#trigger').change(function() {
		var trigger = $(this).val();
		setTriggerDependencies(trigger);
		if(trigger === "task_reminder") {
			taskGroupChanged($('#task_group').val());
		}
	});
	setTriggerDependencies("submission");

	// Set change function target
	$('#target').change(function() {
		setTargetDependencies($(this).val());
	});
	setTargetDependencies("email");

	// Set change function attach
	$('#email_attach').change(function() {
		setAttachDependencies($(this).val());
	});

	// Set focus on notification name when edit notification is opened
	$('#addNotificationPopup').on('shown.bs.modal', function () {
		$('#name').focus();
	});

	/*
	 * Functions for forwarding
	 */
	$('#fwd_host').change(function(){
		var host = $(this).val();
		if(host.length === 0) {
			return false;
		} else if(host.substr(0, 4) !== "http") {
			alert(localise.set["msg_val_prot"]);
			return false;
		}
	});

	$('#fwd_password').change(function(){
		window.gUpdateFwdPassword = true;
	});

	$('#fwd_upd_rem_survey').click(function(){
		getRemoteSurveys();
	});

	$('#fwd_rem_survey').change(function(){
		remoteSurveyChanged();
	});
}

/*
 Get updated question names if the task group changes
 */
function taskGroupChanged(tgIndex, emailQuestionName, emailMetaName) {

	var tg = gTaskGroups[tgIndex];
	var language = "none";
	var qList;
	var metaList;

	if(tg.source_s_id) {
		qList = globals.gSelector.getSurveyQuestions(tg.source_s_id, language);
		metaList = globals.gSelector.getSurveyMeta(tg.source_s_id);
	} else {
		qList = [];
		metaList = [];
	}

	if(!qList) {
		getQuestionList(tg.source_s_id, language, 0, "-1", undefined, false,
			undefined, undefined, emailQuestionName);
	} else {
		setSurveyViewQuestions(qList, undefined, undefined, undefined, emailQuestionName);
	}

	if(!metaList) {
		getMetaList(tg.source_s_id, undefined);
	} else {
		setSurveyViewMeta(metaList, undefined);
	}
}

/*
 * Process a save notification when the target is "email"
 */
function saveEmail() {

	var notification = {};
	var emails = $('#notify_emails').val();
	var emailQuestionName = $('#email_question').val();
	var emailMetaItem = $('#email_meta').val();
	var emailArray;
	var i;

	// validate
	// Must specifify an email
	notification.error = false;
	if((!emails || emails.trim().length == 0) && (!emailQuestionName || emailQuestionName == "-1")
		&& (!emailMetaItem || emailMetaItem == "-1")) {
		notification.error = true;
		notification.errorMsg = localise.set["msg_inv_email"];
	}

	// Text email must be valid email addresses
	if(emails && emails.trim().length > 0) {
		emailArray = emails.split(",");
		for (i = 0; i < emailArray.length; i++) {
			if (!validateEmails(emailArray[i])) {
				notification.error = true;
				notification.errorMsg = localise.set["msg_inv_email"];
				break;
			}
		}
	}

	if(!notification.error) {
		notification.target = "email";
		notification.notifyDetails = {};
		notification.notifyDetails.emails = emailArray;
		notification.notifyDetails.emailQuestionName = emailQuestionName;
		notification.notifyDetails.emailMeta = emailMetaItem;
		notification.notifyDetails.subject = $('#email_subject').val();
		notification.notifyDetails.content = $('#email_content').val();
		notification.notifyDetails.attach = $('#email_attach').val();
		notification.notifyDetails.include_references = $('#include_references').prop('checked');
		notification.notifyDetails.launched_only = $('#launched_only').prop('checked');
	}

	return notification;
}

/*
 * Process a save notification when the target is "sms"
 */
function saveSMS() {

	var notification = {};

	notification.target = "sms";
	notification.notifyDetails = {};
	notification.notifyDetails.emails = $('#notify_sms').val().split(",");
	notification.notifyDetails.emailQuestionName = $('#sms_question').val();
	notification.notifyDetails.subject = $('#sms_sender_id').val();
	notification.notifyDetails.content = $('#sms_content').val();
	notification.notifyDetails.attach = $('#sms_attach').val();

	return notification;
}

/*
 * Process a save notification when the target is "document"
 */
function saveDocument() {

	var notification = {};

	notification.target = "document";
	notification.notifyDetails = {};


	return notification;
}

/*
 * Process a save notification when the target is "forward"
 */
function saveForward() {

	var error = false,
		remote_s_ident,
		host,
		$dialog,
		rem_survey_id,
		rem_survey_nm,
		notification = {};

	host = $('#fwd_host').val();
	remote_s_ident = $('#fwd_rem_survey :selected').val();
	remote_s_nm = $('#fwd_rem_survey :selected').text();

	// Remove any trailing slashes from the host
	if(host.substr(-1) == '/') {
		host = host.substr(0, host.length - 1);
	}

	if(typeof remote_s_ident === "undefined" || remote_s_ident.length == 0) {
		error = true;
		alert(localise.set["msg_val_rf"]);

	} else if(host.substr(0, 4) !== "http") {
		error = true;
		alert(localise.set["msg_val_prot"]);
		$('#fwd_host').focus();
	}

	if(!error) {

		notification.target = "forward";
		notification.remote_s_ident = remote_s_ident;
		notification.remote_s_name = remote_s_nm;
		notification.remote_user = $('#fwd_user').val();
		notification.remote_password = $('#fwd_password').val();
		notification.remote_host = host;
		notification.update_password = window.gUpdateFwdPassword;

		// Save the values temporarily entered by the user
		window.gRemote_host = host;
		window.gRemote_user = $('#fwd_user').val();

	} else {
		notification.error = true;
	}

	return notification;
}

/*
 * Process a save notification when the target is "webhook"
 */
function saveWebhook() {

	var error = false,
		callback_url,
		notification = {};

	callback_url = $('#callback_url').val();

	if(!error) {

		notification.target = "webhook";
		notification.remote_user = $('#fwd_user').val();
		notification.remote_password = $('#fwd_password').val();
		notification.notifyDetails = {};
		notification.notifyDetails.callback_url = callback_url;
		notification.update_password = window.gUpdateFwdPassword;

	} else {
		notification.error = true;
	}

	return notification;
}

/*
 * Process a save notification when the target is "escalate"
 */
function saveEscalate() {

	var error = false,
		callback_url,
		notification = {};

	if(!error) {

		notification.target = "escalate";
		notification.remote_user = $('#user_to_assign').val();
		//if($('#trigger').val() === "cm_alert") {
		//	notification.alert_id = $('#alerts').val();
		//}
		notification.notifyDetails = {};	// Required so that notifyDetails is not undefined

	} else {
		notification.error = true;
	}

	return notification;
}

function getTaskGroupIndex(tgId) {
	var i;
	if(gTaskGroups && gTaskGroups.length > 0 && tgId) {
		for(i = 0; i < gTaskGroups.length; i++) {
			if(gTaskGroups[i].tg_id == tgId) {
				return i;
			}
		}
	}
	return 0;
}

function surveyChangedNotification(qName, metaItem, alertId) {

	var language = "none",
		sId = $('#survey').val() || 0,
		qList,
		metaList,
		alertList;

	if(sId) {
		if(!qName) {
			qName = "-1";
		}

		getEligibleUsers();
		getOversightSurveys(sId);

		qList = globals.gSelector.getSurveyQuestions(sId, language);
		metaList = globals.gSelector.getSurveyMeta(sId);
		alertList = globals.gSelector.getSurveyAlerts(sId);

		if(!qList) {
			getQuestionList(sId, language, 0, "-1", undefined, false,
				undefined, undefined, qName);
		} else {
			setSurveyViewQuestions(qList, undefined, undefined, undefined, qName );
		}

		if(!metaList) {
			getMetaList(sId, metaItem);
		} else {
			setSurveyViewMeta(metaList, metaItem);
		}

		if(!alertList) {
			getAlertList(sId, alertId);
		} else {
			setSurveyAlerts(alertList, alertId);
		}
	}
}

function getInitialDataLink(task) {
	var tab = [];
	idx = -1;

	tab[++idx] = '<a href="';
	tab[++idx] = getWebFormUrl(task.properties.survey_ident,
		task.properties.update_id,
		task.properties.initial_data_source,
		task.properties.id,
		task.properties.a_id);
	tab[++idx] = '" target="_blank">'
	tab[++idx] = '<i class="fa fa-file-text"></i>';	// Edit existing data
	tab[++idx] = '</a>';

	return tab.join('');
}

function getWebFormUrl(form_ident, update_id, initial_data_source, taskId, assignmentId) {
	var url,
		hasParams = false;

	initial_data_souce = initial_data_source || 'none';

	url = "/webForm/" + form_ident;

	if (update_id && initial_data_source === 'survey') {
		url += "?datakey=instanceid&datakeyvalue=" + update_id;
		url += "&viewOnly=true"
		hasParams = true;
	} else {
		url += '?taskkey=';
		url += taskId;
		hasParams = true;
	}
	url += (hasParams ? '&' : '?');
	url += 'assignment_id=';
	url += assignmentId;

	return url;
}

function taskReport(taskGroup) {
	var tz = Intl.DateTimeFormat().resolvedOptions().timeZone,
		tzParam = "",
		url = '/surveyKPI/tasks/xls/' + taskGroup,
		hasParam = false,
		statusFilterArray = $('#status_filter').val(),
		period_filter = $('#period').val();

	// Add parameters
	if (tz) {
		url += (hasParam ? '&' : '?') + "tz=" + encodeURIComponent(tz);
		hasParam = true;
	}
	if(statusFilterArray) {
		url += (hasParam ? '&' : '?') + 'inc_status=' + statusFilterArray.join(',');
		hasParam = true;
	}
	if(period_filter) {
		url += (hasParam ? '&' : '?') + 'period=' + period_filter;
		hasParam = true;
	}

	downloadFile(url);
}

/*
 * Check to see if the status of the task means it should be included
 */
function includeByStatus(statusFilter, task, excludeZeroOrigin) {

	var include = statusFilter.indexOf(task.properties.status) >= 0;
	if(!include) {
		// check for late
		if(task.properties.status === 'accepted' && isLate(task.properties.to) && statusFilter.indexOf("late") >= 0) {
			include = true;
		}
	}
	if(include && excludeZeroOrigin) {
		// Remove points with 0,0 coordinates
		include = false;
		if(task.geometry) {
			include = true;
			if(task.geometry.type === "Point" && task.geometry.coordinates[0] == 0 && task.geometry.coordinates[1] == 0) {
				include = false;
			}
		}
	}

	return include;
}

/*
 * Return true if this qustion stores its data in a text type column
 */
function isTextStorageType(type) {
	return type === "string" || type === "select1" || type === "barcode" || type === "calculate"
		|| type === "child_form" || type === "parent_form";
}

/*
 * Get oversight surveys
 */
function getOversightSurveys(surveyId) {

	var url = "/surveyKPI/surveyResults/" + surveyId + "/groups",
		survey = surveyId;

	if(surveyId > 0) {

		if(window.oversightSurveys[surveyId]) {
			showOversightSurveys(window.oversightSurveys[surveyId]);
		} else {
			addHourglass();
			$.ajax({
				url: url,
				dataType: 'json',
				cache: false,
				success: function (data) {
					removeHourglass();
					window.oversightSurveys[surveyId] = data;
					showOversightSurveys(data);
				},
				error: function (xhr, textStatus, err) {
					removeHourglass();
					if (xhr.readyState == 0 || xhr.status == 0) {
						return;  // Not an error
					} else {
						console.log(localise.set["c_error"] + ": " + err);
					}
				}
			});
		}
	}
}

function showOversightSurveys(data) {
	var i,
		item,
		h = [],
		idx = -1,
		surveyId = $('#survey').val(),
		count = 0;

	$('#group_survey_questions').empty();

	for (i = 0; i < data.length; i++) {
		item = data[i];

		if (item.oversightSurvey && item.sId != surveyId) {
			h[++idx] = '<option value="';
			h[++idx] = item.surveyIdent;
			h[++idx] = '">';
			h[++idx] = htmlEncode(item.surveyName);
			h[++idx] = '</option>';

			if(count == 0) {
				if(gSelectedOversightSurvey) {
					getOversightQuestionList(gSelectedOversightSurvey);
				} else {
					getOversightQuestionList(item.surveyIdent);
				}
			}
			count++;
		}
	}

	if(count == 0) {
		$('.update_options_msg').html(localise.set["n_no_oversight"]);
		$('.update_options_msg').show();
	} else {
		$('.update_options_msg').hide();
	}
	$('#group_survey').empty().html(h.join(''));
	if(gSelectedOversightSurvey) {
		$('#group_survey').val(gSelectedOversightSurvey);
	}
}

//Function to get the question list
function getOversightQuestionList(sIdent) {

	var url = "/surveyKPI/questionListIdent/" + sIdent + "/none?exc_read_only=false&inc_meta=false";

	if(window.oversightQuestions[sIdent]) {
		showOversightQuestions(window.oversightQuestions[sIdent]);
	} else {
		addHourglass();
		$.ajax({
			url: url,
			dataType: 'json',
			cache: false,
			success: function(data) {
				removeHourglass();
				window.oversightQuestions[sIdent] = data;
				showOversightQuestions(data);

			},
			error: function(xhr, textStatus, err) {
				removeHourglass();
				if(xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert("Error: Failed to get list of questions: " + err);
				}
			}
		});
	}

}

function showOversightQuestions(data) {
	var i,
		item,
		h = [],
		idx = -1;

	for (i = 0; i < data.length; i++) {
		item = data[i];

		h[++idx] = '<option value="';
		h[++idx] = item.name;
		h[++idx] = '">';
		h[++idx] = htmlEncode(item.name);
		h[++idx] = '</option>';

	}

	$('#update_question').empty().html(h.join(''));
	if(gSelectedOversightQuestion) {
		$('#update_question').val(gSelectedOversightQuestion);
	}

}

/*
 * Convert system names for meta data into human names
 */
function translateKey(key) {
	if(key === "_device") {
		key = localise.set["c_device"];  //"Device";
	} else if (key === "_user") {
		key = localise.set["c_user"];  // "Submitted By";
	} else if (key === "_start") {
		key = localise.set["_start"] + " (" + localise.set["c_lt"] +")"; // "Start Survey";
	} else if (key === "_end") {
		key = key = localise.set["_end"] + " (" + localise.set["c_lt"] +")";  // "End Survey";
	} else if (key === "Upload Time") {
		key = key = localise.set[key] + " (" + localise.set["c_lt"] +")";
	} else if (key === "_scheduled_start") {
		key = key = localise.set[key] + " (" + localise.set["c_lt"] +")";
	} else if (key === "_bad") {
		key = localise.set["a_mb"];         // "Marked Bad";
	} else if (key === "_bad_reason") {
		key = localise.set["c_reason"];     // "Reason";
	} else if (key === "_complete") {
		key = localise.set["c_complete"];	// "Complete";
	}

	return key;
}

/*
 * Convert system names for meta values into human values
 */
function translateKeyValue(key, value) {

	if (key === "_bad") {
		if(value === "t") {
			value = localise.set["c_yes"];   // "Yes";
		} else {
			value = localise.set["c_no"];   // "No";
		}
	} else if (key === "_complete") {
		value = (value === "t") ? localise.set["c_yes"] : localise.set["c_no"];
	}

	return value;

}

function addCacheBuster(url) {
	var cb;
	if(url.indexOf("?") >= 0) {
		cb = "&";
	} else {
		cb = "?";
	}
	return cb + "_v=" + new Date().getTime().toString();
}

function getAppearanceParams(appearance) {

	var response = {};

	var idx1 = appearance.indexOf('(');
	var idx2 = appearance.lastIndexOf(')');
	var params = appearance.substring(idx1 + 1, idx2);
	var paramsArray = [];
	if(params) {
		paramsArray = params.split(',');
	}

	response.length = paramsArray.length;
	if(paramsArray.length > 0) {

		// 1. First parameter is the filename
		var filename = paramsArray[0].trim();
		response.filename = filename.replace(/'/g, "");

		response.filter = '';    // default
		if(paramsArray.length > 1) {
			// Second parameter is the filter
			response.filter = paramsArray[1].trim();
			response.filter = response.filter.replace(/'/g, "");
		}

		if(response.filter === 'eval') {
			if (paramsArray.length > 2) {
				// Third parameter for an evaluation type function is the expression
				// For an expression type filter only remove the first and last single quote if they exist
				response.expression = paramsArray[2].trim();
				if(response.expression.charAt(0) == '\'') {
					response.expression = response.expression.substring(1);
				}
				if(response.expression.charAt(response.expression.length - 1) == '\'') {
					response.expression = response.expression.substring(0, response.expression.length - 1);
				}
			}
		} else {

			if (paramsArray.length > 2) {
				// Third parameter is the filter column
				response.filter_column = paramsArray[2].trim();
				response.filter_column = response.filter_column.replace(/'/g, "");
			}

			if (paramsArray.length > 3) {
				// Fourth parameter is the filter value
				response.filter_value = paramsArray[3].trim();
				response.filter_value = response.filter_value.replace(/'/g, "");
			}

			if (paramsArray.length > 4) {
				// Fifth parameter is the second filter column
				response.second_filter_column = paramsArray[4].trim();
				response.second_filter_column = response.second_filter_column.replace(/'/g, "");
			}


			if (paramsArray.length > 5) {
				// Sixth parameter is the filter value
				response.second_filter_value = paramsArray[5].trim();
				response.second_filter_value = response.second_filter_value.replace(/'/g, "");
			}
		}

	}
	return response;
}

function getQuestionType(schema, qname) {
	var i;
	for(i = 0; i < schema.columns.length; i++) {
		if(schema.columns[i].question_name == qname) {
			return schema.columns[i].type;
		}
	}
}

function getTrailData(projectId, userId, startDate, endDate, callback, tz, mps) {

	var url = '/surveyKPI/usertrail/trail' +
		'?userId=' + userId +
		'&startDate=' + startDate +
		'&endDate=' + endDate +
		'&mps=' + mps +
		(tz ? "&tz=" + tz : "");

	addHourglass();
	$.ajax({
		url: url,
		dataType: 'json',
		cache: false,
		success: function(data) {
			removeHourglass();
			callback(data);

		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert("Error: Failed to get user trail: " + err);
			}
		}
	});
}

/*
 * Get available surveys from a remote host
 */
function getRemoteSurveys() {

	var host,
		user,
		password,
		remote = {},
		remoteString;

	remote.address = $('#fwd_host').val();
	remote.user = $('#fwd_user').val();
	remote.password = $('#fwd_password').val();


	if(!remote.address || remote.address.length == 0) {
		alert(localise.set["msg_val_rh"]);
		$('#fwd_host').focus();
		return;
	} else if(!remote.user || remote.user.length == 0) {
		alert(localise.set["msg_val_u_id"]);
		$('#fwd_user').focus();
		return;
	} else if(!remote.password || remote.user.password == 0) {
		alert(localise.set["msg_val_pass"]);
		$('#fwd_password').focus();
		return;
	}

	remoteString = JSON.stringify(remote);
	addHourglass();
	$.ajax({
		type: "POST",
		async: true,
		cache: false,
		dataType: "json",
		url: "/surveyKPI/notifications/getRemoteSurveys",
		data: { remote: remoteString },
		success: function(data, status) {
			removeHourglass();
			updateRemoteSurveys(data);
		},
		error: function(xhr, textStatus, err) {
			removeHourglass();
			$('#fwd_rem_survey').empty();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				var msg;
				if(xhr.responseText.indexOf("RSA premaster") >= 0) {
					msg = localise.set["msg_err_cert"];
				} else {
					msg = xhr.responseText;
				}
				alert(localise.set["msg_err_get_f"] + msg);
			}
		}
	});
}

/*
 * Update the list of remote survey
 */
function updateRemoteSurveys(surveyList) {

	console.log("updateRemoteSurvey");

	var $rs = $('#fwd_rem_survey'),
		i, survey,
		h = [],
		idx = -1;

	for(i = 0; i < surveyList.length; i++) {
		survey = surveyList[i];
		h[++idx] = '<option value="';
		h[++idx] = survey.formID;
		h[++idx] = '">';
		h[++idx] = htmlEncode(survey.name);
		h[++idx] = '</option>';
	}

	$rs.empty().append(h.join(''));
	remoteSurveyChanged();

}

/*
 * Reports
 */
function executeUsageReport(oId) {

	var usageMsec = $('#usageDate').data("DateTimePicker").date(),
		d = new Date(usageMsec),
		month = d.getMonth() + 1,
		year = d.getFullYear(),
		incTemp = $('#usage_inc_temp').prop('checked'),
		byProject = $('#usage_by_project').prop('checked'),
		bySurvey = $('#usage_by_survey').prop('checked'),
		byDevice = $('#usage_by_device').prop('checked'),
		i;

	var reportName = localise.set["u_usage"] + "_";

	// Add the organisation name
	if(oId > 0 && globals.gLoggedInUser.orgs.length > 0) {
		for(i = 0; i < globals.gLoggedInUser.orgs.length; i++) {
			if(globals.gLoggedInUser.orgs[i].id == oId) {
				reportName += globals.gLoggedInUser.orgs[i].name + "_";
				break;
			}
		}
	}

	if(byProject) {
		reportName += localise.set["c_project"];
	} else if(bySurvey) {
		reportName += localise.set["c_survey"];
	} else if(byDevice) {
		reportName += localise.set["c_device"];
	} else {
		reportName += localise.set["c_user"];
	}
	reportName += "_" + year + "_" + month;
	reportName = reportName.replaceAll(' ', '_');

	var reportObj = {
		report_type: 'u_usage',
		report_name: reportName,
		pId: 0,
		params: {
			oId: oId,
			byProject: byProject,
			bySurvey: bySurvey,
			byDevice: byDevice,
			month: month,
			year: year,
			incTemp: incTemp
		}
	}

	var tzString = globals.gTimezone ? "?tz=" + encodeURIComponent(globals.gTimezone) : "";

	addHourglass();
	$.ajax({
		type: "POST",
		cache: false,
		dataType: 'text',
		contentType: "application/json",
		url: "/surveyKPI/background_report" + tzString,
		data: { report: JSON.stringify(reportObj) },
		success: function(data, status) {
			removeHourglass();
			alert(localise.set["msg_ds_s_r"]);
		}, error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["msg_err_save"] + xhr.responseText);
			}

		}
	});

}

function executeAttendanceReport(oId) {

	var attendanceMsec = $('#attendanceDate').data("DateTimePicker").date(),
		d = new Date(attendanceMsec),
		day = d.getDate(),
		month = d.getMonth() + 1,
		year = d.getFullYear(),
		i;

	var reportName = localise.set["u_attendance"] + "_";

	// Add the organisation name
	if(oId > 0 && globals.gLoggedInUser.orgs.length > 0) {
		for(i = 0; i < globals.gLoggedInUser.orgs.length; i++) {
			if(globals.gLoggedInUser.orgs[i].id == oId) {
				reportName += globals.gLoggedInUser.orgs[i].name + "_";
				break;
			}
		}
	}

	reportName += "_" + year + "_" + month + "_" + day;
	reportName = reportName.replaceAll(' ', '_');

	var reportObj = {
		report_type: 'u_attendance',
		report_name: reportName,
		pId: 0,
		params: {
			oId: oId,
			month: month,
			year: year,
			day: day
		}
	}

	var tzString = globals.gTimezone ? "?tz=" + encodeURIComponent(globals.gTimezone) : "";

	addHourglass();
	$.ajax({
		type: "POST",
		cache: false,
		dataType: 'text',
		contentType: "application/json",
		url: "/surveyKPI/background_report" + tzString,
		data: { report: JSON.stringify(reportObj) },
		success: function(data, status) {
			removeHourglass();
			alert(localise.set["msg_ds_s_r"]);
		}, error: function(xhr, textStatus, err) {
			removeHourglass();
			if(xhr.readyState == 0 || xhr.status == 0) {
				return;  // Not an error
			} else {
				alert(localise.set["msg_err_save"] + xhr.responseText);
			}

		}
	});

}

/*
 * Decode escaped HTML
 * From https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
 */
function htmlDecode(input) {
	var doc = new DOMParser().parseFromString(input, "text/html");
	return doc.documentElement.textContent;
}

function htmlEncode(input) {
	if(input) {
		return $('<div>').text(input).html();
	} else {
		return;
	}
}

/*
 * Get the list of users from the server
 */
function getEligibleUsers() {

	if(globals.gCurrentSurvey && globals.gCurrentSurvey > 0) {
		addHourglass();
		$.ajax({
			url: "/surveyKPI/userList/survey/" + globals.gCurrentSurvey,
			dataType: 'json',
			cache: false,
			success: function (data) {
				removeHourglass();

				var h = [],
					idx = -1,
					$elem = $('#user_to_assign');

				$elem.empty();

				h[++idx] = '<option value="_none">';
				h[++idx] = localise.set["c_none"];
				h[++idx] = '</option>';

				if(data && data.length > 0) {
					for(i = 0; i < data.length; i++) {
						h[++idx] = '<option value="';
						h[++idx] = data[i].ident;
						h[++idx] = '">';
						h[++idx] = htmlEncode(data[i].name);
						h[++idx] = '</option>';
					}
				}
				$elem.html(h.join(''));

				if(typeof gEligibleUser !== 'undefined') {
					$elem.val(gEligibleUser);
				}

			},
			error: function (xhr, textStatus, err) {
				removeHourglass();
				if (xhr.readyState == 0 || xhr.status == 0) {
					return;  // Not an error
				} else {
					alert(localise.set["error"] + ": " + err);
				}
			}
		});
	}
}
/*
 * Return true if the passed in value is accepted by xlsFormConverter
 */
function isValidODKQuestionName(val) {

	var sqlCheck = /^[A-Za-z_][A-Za-z0-9_\-\.]*$/;
	return sqlCheck.test(val);
}

function isValidODKOptionName(val) {

	var sqlCheck = /^[A-Za-z0-9_@\-\.\+\(\),%:\/]*$/;
	return sqlCheck.test(val);
}
;
define("common", function(){});

/**
 * @license RequireJS i18n 2.0.4 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/i18n for details
 */
/*jslint regexp: true */
/*global require: false, navigator: false, define: false */

/**
 * This plugin handles i18n! prefixed modules. It does the following:
 *
 * 1) A regular module can have a dependency on an i18n bundle, but the regular
 * module does not want to specify what locale to load. So it just specifies
 * the top-level bundle, like "i18n!nls/colors".
 *
 * This plugin will load the i18n bundle at nls/colors, see that it is a root/master
 * bundle since it does not have a locale in its name. It will then try to find
 * the best match locale available in that master bundle, then request all the
 * locale pieces for that best match locale. For instance, if the locale is "en-us",
 * then the plugin will ask for the "en-us", "en" and "root" bundles to be loaded
 * (but only if they are specified on the master bundle).
 *
 * Once all the bundles for the locale pieces load, then it mixes in all those
 * locale pieces into each other, then finally sets the context.defined value
 * for the nls/colors bundle to be that mixed in locale.
 *
 * 2) A regular module specifies a specific locale to load. For instance,
 * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle
 * first, at nls/colors, then figure out what the best match locale is for fr-fr,
 * since maybe only fr or just root is defined for that locale. Once that best
 * fit is found, all of its locale pieces need to have their bundles loaded.
 *
 * Once all the bundles for the locale pieces load, then it mixes in all those
 * locale pieces into each other, then finally sets the context.defined value
 * for the nls/fr-fr/colors bundle to be that mixed in locale.
 */
(function () {
    'use strict';

    //regexp for reconstructing the master bundle name from parts of the regexp match
    //nlsRegExp.exec("foo/bar/baz/nls/en-ca/foo") gives:
    //["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
    //nlsRegExp.exec("foo/bar/baz/nls/foo") gives:
    //["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
    //so, if match[5] is blank, it means this is the top bundle definition.
    var nlsRegExp = /(^.*(^|\/)nls(\/|$))([^\/]*)\/?([^\/]*)/;

    //Helper function to avoid repeating code. Lots of arguments in the
    //desire to stay functional and support RequireJS contexts without having
    //to know about the RequireJS contexts.
    function addPart(locale, master, needed, toLoad, prefix, suffix) {
        if (master[locale]) {
            needed.push(locale);
            if (master[locale] === true || master[locale] === 1) {
                toLoad.push(prefix + locale + '/' + suffix);
            }
        }
    }

    function addIfExists(req, locale, toLoad, prefix, suffix) {
        var fullName = prefix + locale + '/' + suffix;
        if (require._fileExists(req.toUrl(fullName + '.js'))) {
            toLoad.push(fullName);
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     * This is not robust in IE for transferring methods that match
     * Object.prototype names, but the uses of mixin here seem unlikely to
     * trigger a problem related to that.
     */
    function mixin(target, source, force) {
        var prop;
        for (prop in source) {
            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {
                target[prop] = source[prop];
            } else if (typeof source[prop] === 'object') {
                if (!target[prop] && source[prop]) {
                    target[prop] = {};
                }
                mixin(target[prop], source[prop], force);
            }
        }
    }

    define('i18n',['module'], function (module) {
        var masterConfig = module.config ? module.config() : {};

        return {
            version: '2.0.4',
            /**
             * Called when a dependency needs to be loaded.
             */
            load: function (name, req, onLoad, config) {
                config = config || {};

                if (config.locale) {
                    masterConfig.locale = config.locale;
                }

                var masterName,
                    match = nlsRegExp.exec(name),
                    prefix = match[1],
                    locale = match[4],
                    suffix = match[5],
                    parts = locale.split("-"),
                    toLoad = [],
                    value = {},
                    i, part, current = "";

                //If match[5] is blank, it means this is the top bundle definition,
                //so it does not have to be handled. Locale-specific requests
                //will have a match[4] value but no match[5]
                if (match[5]) {
                    //locale-specific bundle
                    prefix = match[1];
                    masterName = prefix + suffix;
                } else {
                    //Top-level bundle.
                    masterName = name;
                    suffix = match[4];
                    locale = masterConfig.locale;
                    if (!locale) {
                        locale = masterConfig.locale =
                            typeof navigator === "undefined" ? "root" :
                            (navigator.language ||
                             navigator.userLanguage || "root").toLowerCase();
                    }
                    parts = locale.split("-");
                }

                if (config.isBuild) {
                    //Check for existence of all locale possible files and
                    //require them if exist.
                    toLoad.push(masterName);
                    addIfExists(req, "root", toLoad, prefix, suffix);
                    for (i = 0; i < parts.length; i++) {
                        part = parts[i];
                        current += (current ? "-" : "") + part;
                        addIfExists(req, current, toLoad, prefix, suffix);
                    }

                    req(toLoad, function () {
                        onLoad();
                    });
                } else {
                    //First, fetch the master bundle, it knows what locales are available.
                    req([masterName], function (master) {
                        //Figure out the best fit
                        var needed = [],
                            part;

                        //Always allow for root, then do the rest of the locale parts.
                        addPart("root", master, needed, toLoad, prefix, suffix);
                        for (i = 0; i < parts.length; i++) {
                            part = parts[i];
                            current += (current ? "-" : "") + part;
                            addPart(current, master, needed, toLoad, prefix, suffix);
                        }

                        //Load all the parts missing.
                        req(toLoad, function () {
                            var i, partBundle, part;
                            for (i = needed.length - 1; i > -1 && needed[i]; i--) {
                                part = needed[i];
                                partBundle = master[part];
                                if (partBundle === true || partBundle === 1) {
                                    partBundle = req(prefix + part + '/' + suffix);
                                }
                                mixin(value, partBundle);
                            }

                            //All done, notify the loader.
                            onLoad(value);
                        });
                    });
                }
            }
        };
    });
}());

define('lang_location/nls/lang',{
	"root": true,
	"ar": true,
	"fr": true,
	"pt": true,
	"es": true,
	"hi": true
});

define('lang_location/nls/root/lang',{
    "m_home": "Home",
    "m_admin": "Admin",
    "m_tm": "Forms",
    "m_analysis": "Analysis",
    "m_report": "Report",
    "m_reports": "Reports",
    "m_reports_def": "Default Reports",
    "m_reports_org": "Organisation Reports",
    "m_reports_leg": "Legacy Reports",
    "m_reports_new": "New Reports",
    "m_reports_public": "Public Reports",
    "m_refresh": "Refresh",
    "m_email_unsent": "Email Unsent",
	"m_email_gen": "Generate Links",
    "m_export": "Export",
    "m_export_media": "Export with Media",
    "m_backup": "Backup",
    "m_backup_media": "Backup with Media",
    "m_discuss": "Discuss",
    "m_modify": "Modify",
    "m_web_forms": "Web Forms",
    "m_docs": "Documentation",
    "m_monitor": "Monitoring",
    "m_user": "Users",
    "m_assign": "Tasks",
    "m_query": "Queries",
    "m_help": "Help",
    "m_train": "Training",
    "m_forgot_password": "Forgot Password",
    "m_register": "Register",
    "m_locations": "Locations",
    "m_section": "Section",
    "m_notify": "Notifications",
    "m_view": "View",
    "m_attach": "Load Attachments",
    "m_modules": "Modules",
    "m_lr": "Local Reports",
    "m_open": "Open",
    "m_new": "New",
    "m_import": "Import",
    "m_calculations": "Calculations",
    "m_resources": "Shared Resources",
    "m_review": "Review",
    "m_mf": "Managed Forms",
    "m_br": "Browse Results",
    "m_manage": "Manage",
    "m_dash": "Dashboard",
    "m_console": "Console",
    "m_s_m_f": "Setup Managed Forms",
    "m_task_m": "Task Management",
    "m_user_profile": "User Profile",
    "m_login": "Login",
    "m_logs": "Logs",
    "m_info": "Info",
    "m_os": "Oversight",
    "m_billing": "Billing",
    "m_rates": "Rates",
    "m_billing_server": "Server Billing",
    "m_billing_orgs": "Organisations Billing",
    "m_bill_level": "Bill Level",

    // Smap Server
    "ss_welcome": "Welcome to Smap Server Version:",
    "ss_welcome2": "Changes in this release",
    "ss_ft": "Get Field Task",
    "ss_su": "Get Smap Uploader",

    // Common
    "c_alert": "Alert",
    "c_alerts": "Alerts",
    "c_apply": "Apply",
    "c_api": "API",
    "c_api_builder": "API Builder",
    "c_audit": "Audit",
    "c_auto": "Auto",
    "c_before": "Before",
    "c_bundle": "Bundle",
    "c_cases": "Cases",
    "c_closed": "Closed",
    "c_cm": "Case Management",
    "c_crit": "Criticality",
    "c_default": "Default",
    "c_desc": "Description",
    "c_link": "Link",
    "c_links": "Links",
    "c_opened": "Opened",
    "c_url": "URL",
    "c_project": "Project",
    "c_forms": "Forms",
    "c_form": "Form",
    "c_sub_form": "Sub Form",
    "c_forward": "Forward",
    "c_webhook": "Web Hook",
    "c_forwarded": "Forwarded",
    "c_name": "Name",
    "c_company_name": "Company Name",
    "c_company_addr": "Company Address",
    "c_company_phone": "Company Phone",
    "c_company_email": "Company Email",
    "c_type": "Type",
    "c_file": "File",
    "c_host": "Host",
    "c_rank": "Rank",
    "c_user": "User",
    "c_self": "Self",
    "c_vertical": "Vertical",
    "c_projects": "Projects",
    "c_email": "Email",
    "c_escalate": "Escalate",
    "c_emails": "Emails",
    "c_sms": "SMS",
    "c_document": "Document",
    "c_twitter": "Twitter",
    "c_lang": "Language",
    "c_langs": "Languages",
    "c_pulldata": "Pulldata",
    "c_pulldata_r": "Repeating Pulldata",
    "c_orientation": "Orientation",
    "c_password": "Password",
    "c_c_p": "Confirm Password",
    "c_c_d": "Confirm Delete",
    "c_r_p": "Reset Password",
    "c_reset": "Reset",
    "c_en": "Enable",
    "c_dis": "Disable",
    "c_loc_f": "Local Form:",
    "c_rem_f": "Remote Form",
    "c_rem_u": "Remote User",
    "c_enabled": "Enabled",
    "c_edit": "Edit",
    "c_del": "Delete",
    "c_undel": "Undelete",
    "c_del_data": "Delete Data",
    "c_res_data": "Restore Data",
    "c_archive_data": "Archive Data",
    "c_download": "Download",
    "c_upload": "Upload",
    "c_done": "Done",
    "c_cancel": "Cancel",
    "c_save": "Save",
    "c_saved": "Saved",
    "c_submit": "Submit",
    "c_submitted": "Submitted",
    "c_test": "Test",
    "c_validate": "Validate",
    "c_close": "Close",
	"c_likert": "Likert",
    "c_logout": "Logout",
    "c_block": "Block",
    "c_blocked": "Blocked",
    "c_graph": "Graph",
    "c_map": "Map",
    "c_chart": "Chart",
    "c_charts": "Charts",
    "c_maps": "Maps",
    "c_map_layers": "Map Layers",
    "c_table": "Table",
    "c_tables": "Tables",
    "c_images": "Images",
    "c_title": "Title",
    "c_comment": "Comment",
    "c_country": "Country",
    "c_region": "Region",
    "c_district": "District",
    "c_community": "Community",
    "c_node": "Node",
    "c_relation": "Relation",
    "c_from": "From",
    "c_subject": "Subject",
    "c_to": "To",
    "c_properties": "Properties",
    "c_question": "Question",
    "c_questions": "Questions",
    "c_choices": "Choices",
    "c_include": "Include",
    "c_unique": "Unique",
    "c_survey": "Survey",
    "c_survey_tg": "Survey / Task Group",
    "c_date": "Date",
    "c_dateq": "Date Question",
    "c_none": "None",
    "c_period": "Period",
    "c_hour": "Hour",
    "c_day": "Day",
    "c_week": "Week",
    "c_month": "Month",
    "c_year": "Year",
    "c_matches": "matches",
    "c_filter": "Filter",
    "c_inclusive": "Inclusive",
    "c_value": "Value",
    "c_clear": "Clear",
    "c_options": "Options",
    "c_data": "Data",
    "c_layers": "Layers",
    "c_settings": "Settings",
    "c_start": "Start",
	"c_end": "End",
	"c_step": "Step",
    "c_back": "Back",
    "c_target": "Target",
    "c_trigger": "Trigger",
    "c_content": "Content",
    "c_today": "Today",
    "c_attach": "Attach",
    "c_details": "Details",
    "c_action": "Action",
    "c_actions": "Actions",
    "c_mapid": "Map Id",
    "c_zoom": "Zoom Levels",
    "c_zoom_data": "Zoom to Data",
    "c_vector_data": "Vector Data",
    "c_vector_style": "Vector Style",
    "c_style": "Style",
    "c_portrait": "Portrait",
    "c_landscape": "Landscape",
    "c_tools": "Tools",
    "c_required": "Make Required",
    "c_not_required": "Make Not Required",
    "c_del_sel": "Delete Selected",
    "c_assign_sel": "Set Selected as Assigned",
    "c_print": "Print",
    "c_repeat": "Repeat",
	"c_persist": "Persist",
    "c_repeats": "Repeats",
    "c_scheduled": "Scheduled",
    "c_t_c": "terms and conditions",
    "c_agree": "I agree to the",
    "c_select": "Select",
    "c_status": "Status",
    "c_coords": "Coordinates",
    "c_task": "Task",
    "c_rec": "(Recommended)",
    "c_source": "Source",
    "c_show": "Show",
    "c_hide": "Hide",
    "c_total": "Total",
    "c_totals": "Totals",
    "c_instances": "Instances",
    "c_device": "Device",
    "c_success": "Success",
    "c_errors": "Errors",
    "c_error": "Error",
    "c_warning": "Warning",
    "c_lt": "Local Time",
    "c_user": "User",
    "c_standard": "Standard",
    "c_simserial": "Sim Serial Number",
    "c_location": "Location",
    "c_ident": "Identifier",
    "c_version": "Version",
    "c_deleted": "Deleted",
    "c_yes": "Yes",
    "c_no": "No",
    "c_reason": "Reason",
    "c_complete": "Complete",
    "c_record": "Record",
    "c_records": "Records",
    "c_of": "of",
    "c_media": "Media",
    "c_changes": "Changes",
    "c_templates": "PDF Templates",
    "c_template": "PDF Template",
    "c_meta": "Meta Items",
    "c_calc": "Calculations",
    "c_trans": "Translate",
    "c_org": "Organisation",
    "c_orgs": "Organisations",
    "c_ent": "Enterprise",
    "c_all_s": "All Surveys",
    "c_all": "All",
    "c_event": "Event",
    "c_note": "Note",
    "c_server": "Server",
    "c_cols": "Columns",
    "c_cols_packed": "Packed Columns",
    "c_add": "Add",
    "c_create": "Create",
    "c_generate": "Generate",
    "c_imp_xls": "Import Spreadsheet",
    "c_format": "Format",
    "c_xlstype": "Excel Format",
    "c_roles": "Roles",
    "c_s_roles": "Survey Roles",
    "c_role": "Role",
    "c_id": "Id",
    "c_insert": "Insert",
    "c_tz": "Time Zone",
    "c_undef": "Not Defined",
    "c_license": "License Number",
    "c_in": "in",
	"c_notin": "not in",
    "c_rev": "Reverse",
    "c_for": "For",
    "c_normal": "Normal",
    "c_heatmap": "Heatmap",
    "c_auth": "Authorized",
    "c_merge": "Merge",
    "c_append": "Append",
    "c_discard": "Discard",
    "c_keys": "Keys",
    "c_counts": "Counts",
    "c_unsav": "You have unsaved changes are you sure you want to leave?",
    "c_off": "Off",
    "c_on": "On",
    "c_rule": "Rule",
    "c_replace": "Replace",
    "c_retry": "Retry",
    "c_alink": "Anonymous Link",
    "c_excel": "Excel",
    "c_word": "Word",
    "c_csv": "CSV",
    "c_json": "JSON",
    "c_geojson": "GeoJSON",
    "c_osm": "Openstreetmap",
    "c_shape": "Shape",
    "c_kml": "KML / KMZ",
    "c_vrt": "VRT / CSV",
    "c_stata": "Stata / CSV",
    "c_spss": "SPSS / CSV",
    "c_pdf": "PDF",
    "c_phone": "Phone Number",
	"c_photo": "Photograph",
    "c_rep_type": "Sub Form",
    "c_cl": "Copy Link",
    "c_codl": "Copy OData Link",
    "c_cb": "Copy to clipboard",
    "c_c": "Copied",
    "c_quantity": "Quantity",
    "c_after": "After",
    "c_units": "Units",
    "c_duration": "Duration",
    "c_msg": "Message",
    "c_completed": "Completed",
    "c_unsubscribed": "Unsubscribed",
    "c_unsubscribe": "Unsubscribe",
    "c_subscribe": "Subscribe",
    "c_expired": "Expired",
	"c_subscriberid": "Subscriber Id",
    "c_unsent": "Email not sent",
    "c_pending": "Pending",
    "c_ok": "OK",
    "c_move": "Move",
    "c_parent_form": "Parent Form",
    "c_child_form": "Child Form (Repeats)",
    "c_other": "Other",
    "c_random": "Randomize",
    "c_annotate": "Annotate",
    "c_draw": "Draw",
    "c_field_list": "Field List",
    "c_table_list": "Table List",
    "c_recover": "Recover Previous File",
    "c_lat": "Latitude",
    "c_lon": "Longitude",
    "c_browse": "Browse",
    "c_reject": "Reject",
    "c_history": "History",
    "c_events": "Events",
    "c_resend": "Resend",
    "c_late": "Late",
    "c_custom": "Custom",
    "c_access": "Access",
    "c_person": "Person",
    "c_people": "People",
    "c_contacts": "Contacts",
    "c_teams": "Teams",
    "c_mailouts": "Mail outs",
    "c_mailout": "Mail out",
    "c_campaigns": "Campaigns",
    "c_campaign": "Campaign",
    "c_manual": "Manual",
    "c_submitter": "Submitter",
    "c_code": "Code",
    "c_dirn": "Direction",
    "c_current": "Current",
    "c_quality": "Quality",
    "c_low": "Low",
    "c_external": "External",
    "c_preview": "Preview",
    "c_size": "Size",
    "c_meters": "Meters",

    // File Types
    "ft": "File Type",
    "ft_xls": "XLS Form",
    "ft_xls_orig": "Original file",
    "ft_xml": "XML Form",
    "ft_codebook": "Codebook",
    "ft_pdf": "Default Report Template",
    "ft_spss": "SPS File (SPSS)",

    // Template Management
    "tm_s_del": "Show deleted forms",
    "tm_s_block": "Show blocked forms",
    "tm_d_forms": "Delete Forms",
    "tm_r_forms": "Restore Forms",
    "tm_e_forms": "Erase Forms",
    "tm_c_form": "Create a Form",
    "tm_c_form_rep": "Replace a Form",
    "tm_c_xls": "Using the Spreadsheet editor",
    "tm_g_temp": "Download Template",
    "tm_g_new": "Create new Form",
    "tm_g_open": "Open a Form",
    "tm_g_temp_i1": "Download a template to create a new form on your personal computer. When you have finished, upload it to the server by clicking on the upload button below. You will first need to select the XLS file containing the form you have created and give it a name.",
    "tm_g_temp_i3": "Reference Guide",
    "tm_ul_f": "Upload the spreadsheet",
    "tm_si": "Specify survey identifier",
    "tm_up": "Upload Template",
    "tm_add": "Add Template",
    "tm_ups": "Upload Form",
    "tm_add_for": "Add Forward",
    "tm_ref_f": "Refresh Form List",
    "tm_o_u": "Original Upload Page",
    "tm_gw": "A bundle should only be specified for surveys that share tables, if in doubt select none",

    // Analysis
    "a_ref_rate": "Analysis auto refresh interval",
    "a_exp_title": "Export Results",
    "a_exp_leg1": "Select a survey",
    "a_locn": "Select a location question",
    "a_exp_leg2": "Output format:",
    "a_exp_notes": "Export notes:",
    "a_exp_meta": "Include Meta Data:",
    "a_exp_odata2": "Restrict Odata types to those supported by OData 2:",
    "a_exp_split": "Split lat / lon:",
    "a_exp_merge": "Compress select multiples:",
    "a_sel_ways": "Select ways (if any):",
    "a_sel_forms": "Select forms to include:",
    "a_sel_query": "There are no queries to export.  You will need to create one using the queries menu in the dashboard module",
    "a_sel_model": "Edit survey model",
    "a_type": "Chart Type",
    "a_showon": "Show on",
    "a_ss": "Select survey",
    "a_sq": "Select question",
    "a_gb": "Group by",
    "a_ts": "Time series",
    "a_sl": "Show Label",
    "a_g_gps": "GPS coordinates within region",
    "a_fbv": "Filter by value",
    "a_from_date": "From date",
    "a_to_date": "To date",
    "a_fq": "Filter question",
    "a_res": "Please provide a reason",
    "a_res_5": "Please provide a reason at least 5 characters long",
    "a_mb": "Marked Bad",
    "a_oo": "out of",
    "a_cm": "Cluster Members",
    "a_dv": "Show Details",
    "a_rd": "Report Definition",
    "a_rp": "Report Parameters",
    "a_lcr": "Launch Custom Report",
    "a_embed": "Embed Images in Excel File",
    "a_hxl": "HXL",
    "a_query": "Select a query",
    "a_fn": "Function",
    "a_ni": "You need to enable loading tasks for this form in the form settings in the editor page",
    "a_nx": "New XLSX",
    "a_lx": "Legacy XLSX",
	"a_lh": "Legacy XLS / HTML",
	"a_ua": "User Activity",
    "a_ul": "User Locations",
    "a_tc": "This Chart",
    "a_start_pk": "First Primary Key",
    "a_end_pk": "Last Primary Key",
    "a_inc_ro": "Include Read Only",

    "a_dd_sl": "Shows the results",
    "a_dd_ocha_map": "Shows the location of responses to %s1 in the question '%s2' in survey '%s3'.",
	"a_dd_percent_map": "Shows the percentage of responses that selected %s1 in the question '%s2' in survey '%s3'.",
	"a_dd_average_map": "Shows the average of responses to %s1 in the question '%s2' in survey '%s3'.",
	"a_dd_count_map": "Shows the count of responses to %s1 in the question '%s2' in survey '%s3'.",
	"a_dd_total_map": "Shows the total of responses to %s1 in the question '%s2' in survey '%s3'.",
	"a_dd_none_map": "Shows the responses to %s1 in the question '%s2' in survey '%s3'.",
	"a_dd_ocha_table": "Shows the location of responses to each choice in the question '%s2' in survey '%s3'.",
	"a_dd_percent_table": "Shows the percentage of responses that selected each choice in the question '%s2' in survey '%s3'.",
	"a_dd_average_table": "Shows the average of responses to each choice in the question '%s2' in survey '%s3'.",
	"a_dd_count_table": "Shows the count of responses to each choice in the question '%s2' in survey '%s3'.",
	"a_dd_total_table": "Shows the total of responses to each choice in the question '%s2' in survey '%s3'.",
	"a_dd_none_table": "Shows the responses to each choice in the question '%s2' in survey '%s3'.",
    "a_filter": "Showing %s1 records out of %s2",

    "a_dd_units": "(units are %s1)",

    "a_dd_group": "Grouped by the responses to the question '%s1'.",
	"a_dd_group_interval": "Grouped by the responses to the question '%s1' and by '%s2'.",
	"a_dd_interval": "Grouped by '%s1'",

    "a_dd_where": "<b>Where %s1 equals %s2</b>",
    "_scheduled_start": "Scheduled Start",
	"a_exp_media_msg": "Exports with media are limited to %s1 records. ",
	"a_exp_msg": "Exports without media are limited to %s1 records. ",
	"a_exp_msg2": "You are currently exporting %s2 records. Set the start and end records to conform to this limit",
	"a_exp_start": "The start record must be less than or equal to the end record",

    // Messages
    "msg_pdft": "PDF Templates are now managed on the templates page which can be accessed from the tools menu",
    "msg_pc": "The reminder interval must be greater than zero",
    "msg_pk_sel": "You can only select the record identifier if you have selected the \"Update a different question\" checkbox",
    "msg_wait": "Waiting for a response from the server. Please try again in a few seconds",
    "msg_reason": "Please provide a reason: ",
    "msg_rs": "Reminder notifications must be associated with a task group that has tasks generated from a survey.  You cannot send reminders for ad-hoc tasks",
    "msg_sel_survey": "You must select a survey",
    "msg_sel_dates": "From date is greater than To date",
	"msg_no_from": "If you specify the scheduled end date, then also specify the scheduled start date",
    "msg_sel_q": "You must select a question to show on a graph",
    "msg_val_prot": "Protocol (http:// or https://) must be specified with the hostname",
    "msg_val_p": "A project must be selected for this form",
    "msg_val_rf": "You must select a remote form",
    "msg_val_rh": "You must select a remote host",
    "msg_val_u_id": "You must specify a user id",
    "msg_val_pass": "You must specify a password",
    "msg_nv": "Please specify a new value",
    "msg_val_nm": "Name is required",
    "msg_val_dl_dist": "If set then the download distance must be greater than 100 meters",
    "msg_val_show_dist": "If set then the show distance must be greater than 10 meters",
    "msg_val_ad": "If assigning a task using collected data then you need to specify the data",
    "msg_val_ad2": "The additional role should only be specified if the first role was specified",
    "msg_val_file": "A file must be selected",
    "msg_val_let": "Name must start with a letter or underscore",
    "msg_pwd_l": "Passwords, if specified, must be longer than 1 character",
    "msg_pwd_m": "Passwords do not match",
    "msg_add_notification": "Add Notification",
    "msg_edit_notification": "Edit Notification",
    "msg_send_notification": "Send Notification",
    "msg_nn": "No notifications",
    "msg_noi": "No opt in messages",
    "msg_add_map": "Add Map",
    "msg_edit_map": "Edit Map",
    "msg_sel_form": "Select Form:",
    "msg_sel_media": "Select Media Question:",
    "msg_mfn": "Create media file name with:",
    "msg_sel_media_f": "Select Media File",
    "msg_err_save": "Error: Save failed: ",
    "msg_err_del": "Error: Delete failed: ",
    "msg_err_cr": "Error: Create failed: ",
    "msg_err_upd": "Error: Update failed: ",
    "msg_err_res": "Error: Restore failed: ",
    "msg_err_block": "Error: Block failed: ",
    "msg_err_get_f": "Error: Get forms failed: ",
    "msg_err_get_r": "Error: Get roles failed",
    "msg_err_get_a": "Error: Get alerts failed",
    "msg_err_get_q": "Error: Get questions failed",
    "msg_err_get_s": "Error: Get surveys failed",
    "msg_err_get_c": "Error: Get case management settings failed",
    "msg_err_bll": "Blank Label for language",
    "msg_upd": "Update Succeeded",
    "msg_err_nc": "Name cannot include a comma",
    "msg_err_wait": "Either waiting for the server or there are no surveys in this project to assign to a user. If the project does have surveys then try again in a few seconds",
    "msg_err_cert": "Remote server does not have a signed certificate, try using http:// instead of https://",
    "msg_no_edit_rep": "You cannot edit a record that has been replaced by another record",
    "msg_confirm_del": "Are you sure you want to delete",
	"msg_confirm_del_one": "Delete %s1 only from %s2",
	"msg_confirm_del_all": "Delete %s1 from all organisations: %s2",
    "msg_confirm_tasks": "this group and all of its tasks?",
    "msg_del_r": "Are you sure you want to delete these regions?",
    "msg_erase": "Are you sure you want to permanently erase these surveys and all of their data?",
    "msg_restore": "Are you sure you want to restore these surveys?",
    "msg_del_recs": "There are %s1 data rows submitted for %s2. Are you sure you want to delete this data?",
    "msg_del_s": "Are you sure you want to delete these surveys?",
    "msg_del_data": "Are you sure you want to delete all the data in this survey?",
    "msg_del_groups": "This survey is part of a group and deleting its data will also delete the data for these other surveys",
    "msg_res_data": "Are you sure you want to restore all the data in this survey to the original submissions?",
    "msg_del_data2": "Are you really sure?",
    "msg_del_rep": "Are you sure you want to delete this report?",
    "msg_del_users": "Are you sure you want to delete these users?",
    "msg_del_projects": "Are you sure you want to delete this project?",
    "msg_del_roles": "Are you sure you want to delete these roles?",
    "msg_del_cms": "Are you sure you want to delete this setting?",
    "msg_del_orgs": "Are you sure you want to delete these organisations?",
	"msg_del_ents": "Are you sure you want to delete these enterprises?",
    "msg_del_q": "Are you sure you want to delete this question?",
    "msg_del_cl": "Are you sure you want to delete this choice list?",
    "msg_del_c": "Are you sure you want to delete this choice?",
    "msg_rep_f": "Are you sure you want to replace this choice filter",
    "msg_del_not": "Are you sure you want to delete notification",
    "msg_n_v": "Not valid",
    "msg_u_f": "Error upload failed",
    "msg_u_nt": "No nfc tags found",
    "msg_csv": "Only CSV files and Zip files containing CSV and media files are allowed",
    "msg_inv_email": "Not a valid email address",
    "msg_dup_email": "Duplicate email. Some other user has this email.",
    "msg_email_req": "If sending an email to the user then email address must be specified",
    "msg_email_dom": "Email user name should not include the email domain.  So for an email address of example@org.com the user name would be 'example'",
    "msg_dup_ident": "Duplicate user identification. Please change the user ident.",
    "msg_cs": "Click to filter or sort on this column",
    "msg_nrf": "No results forwarded to another server",
    "msg_saf": "Select a form to view the users that have downloaded that form",
    "msg_nf": "No forms",
    "msg_ns": "No Submissions",
    "msg_us": "Unknown Source",
    "msg_tg_ns": "Task group not selected",
    "msg_tg_rd": "The task group rule has been deleted",
    "msg_no_roles": "There are no enabled roles. Hence there are no restrictions on access",
    "msg_has_roles": "Only users who have one of the following enabled roles are allowed access",
    "msg_one_f": "At least one form must be selected",
    "msg_one_f2": "A form must be selected",
    "msg_embed": "The excel type must be xls or xlsx to embed images",
    "msg_pss": "Please select a survey",
    "msg_nm": "No images, video, audio found",
    "msg_pr": "Password has been reset",
    "msg_es": "Email has been sent to",
    "msg_refresh": "You have made some changes and not saved them, are you sure you want to refresh?",
    "msg_leave": "You have made some changes and not saved them, are you sure you want to leave?",
    "msg_test": "You have made some changes and will need to save them before testing the form.",
    "msg_not_f": "was not found",
    "msg_ren": "renamed to",
    "msg_nq": "You have no queries defined, use the 'add query' button to add one",
    "msg_dup_f": "This form is already in the query",
    "msg_ui": "Spaces are not allowed in the user ident",
    "msg_sp": "Select a project to see the status of forms",
    "msg_ab_ns": "Either adding tasks from already submitted data, or adding tasks from data yet to be submitted or both should be selected",
    "msg_n1": "emails in a question",
    "msg_n2": "emails in meta item",
    "msg_sms_n1": "Send SMS to ",
    "msg_sms_n2": "numbers entered in response to a question",
    "msg_ds_s": "Download started.  If there is a lot of data then this may take some time please be patient",
    "msg_ds_s_r": "Report generation started.  You will find the generated report in the reports module",
    "msg_survey_replaced": "Survey replaced",
    "msg_survey_loaded": "Survey loaded",
    "msg_reg": "Registration accepted.  An email has been sent to %s1 with a link that you can use to set your password.",
    "msg_uns": "Unsubscribe sucessful",
    "msg_s1": "An email has been sent to the address you provided.  Click on the link to confirm your subscription",
    "msg_s2": "Subscribed sucessfully",
    "msg_s3": "Enter your email address to re-subscribe to emails",
    "msg_pd_key": "Specify a data key ",
    "msg_one_role": "At least one role must be selected",
    "msg_dup_name": "Duplicate name",
    "msg_prev_select": "There are no previous select questions to get values from. You may want to set a custom filter",
    "msg_no_proj": "The user has no projects",
    "msg_pformat": "Parameters specified in the other field must be separated by semi colons and contain an equals sign. For example:  a=x;b=y",
    "msg_filter_col": "You have specified a filter Column of '%s1', hence you need to specify a filter to apply",
    "msg_filter_expr": "You must specify an expression for an 'eval' type of search",
    "msg_numb_ts": "Thousands separator will have no affect unless numbers is also selected",
	"msg_warn_likert_n": "Likert only works with the normal select type",
    "msg_choice_value": "The choice value must be specified",
	"msg_search_source": "You must select either survey or csv as the souce of the choice data",
    "msg_search_source2": "The source file or survey must be selected",
	"msg_pdfcols_count": "The total width of all the columns must add up to 10",
    "msg_pdfinv_zoom": "Zoom must be between 1 and 20",
    "msg_pdfinv_round": "Rounding of decimal places can be between 0 and 10",
	"msg_pdfcols_width": "A column width must be between 1 and 10 inclusive",
	"msg_pe": "The number of days before password expiry must be an integer greater than 0",
    "msg_restore_started": "Restoration of the survey data has started.  Press refresh to see progress.  This process may take minutes if the files to be retrieved are in off site storage",
	"msg_persist": "Persistent tasks stay on the device even after they are completed. The user should reject the task when they have finished with it",
    "msg_no_uns_orgs": "There are no organisations where that email address is unsubscribed",
    "msg_res_name": "%s1 is a reserved name",
    "msg_trans_to": "The translation request has timed out.  However it should still be working in the background and you can view the results by refreshing the page",
    "msg_subs_bg": "If you have un-subscribed from receiving email notifications, then using this page, you can re-subscribe to receive them again. The decision to send notifications to an email address is made by an administrator so although you can un-subscribe from these and then re-subscribe on this page you cannot request email notiifcations when you are not being sent any.",
    "msg_fgt_p": "Enter the email address associated with your account. A link will be sent to that address allowing you to reset your password.",
    "msg_archive": "%s1 records on or before %s2 will be archived from the following survey(s); %s3. Do you wish to proceed?",
    "msg_archive_done": "Archiving completed",
    "msg_archive_none": "There is no data to archive",
    "msg_archive_data": "Are you sure you want to archive old submissions?",
    "msg_archive_before": "The date before which submissions will be archived must be specified",

    // Editor
    "e_b_e": "Base on existing form",
    "e_s_r": "Store results in shared table",

    // Tasks
    "t_complete": "Show Completed Tasks",
    "t_show": "Show tasks for:",
    "t_assign_type": "Assignment type",
    "t_assign": "Assign User",
    "t_assign_roles": "Assign to users with role",
    "t_fixed_role": "And this role",
    "t_add_group": "Add Task Group",
    "t_del_group": "Delete Task Group",
    "t_edit_group": "Edit Task Group",
    "t_lt_file": "Load Tasks From File",
    "t_choose_user": "Choose the user to assign to the selected tasks",
    "t_ce": "Clear Existing Tasks",
    "t_ce_warn": "This will clear all the existing data in the survey. Are you sure you want to do this?",
    "t_ceg": "Create Empty Task Group",
    "t_cfe": "Create from existing data",
    "t_ep": "Existing Project",
    "t_es": "Existing Survey",
    "t_ec": "Existing Choice",
    "t_et": "Existing Text",
    "t_nt": "New Text",
    "t_ns": "New Survey",
    "t_ft": "Filter Tasks",
    "t_aft": "Advanced Filter",
    "t_df": "Date Filter",
    "t_fq": "Filter by Question",
    "t_so": "Selected Option",
    "t_sn": "Set Numeric Value",
    "t_st": "Set Text Value",
    "t_ue": "Update Existing Results",
	"t_pp": "Pre-populate form with existing data",
    "t_nid": "No initial data",
    "t_ap": "Address Parameters",
    "t_nfc": "NFC / Location",
    "t_assigned": "Assigned",
    "t_assignments": "Assignments",
    "t_fl": "File Loaded",
    "t_tl": "Template Loaded",
    "t_efnl": "Error file not loaded",
    "t_ens": "Error not saved",
    "t_add_tasks": "Click on the map where you want to add new tasks. When finished click on 'Save Tasks' button",
    "t_add_task": "Add Task",
    "t_edit_task": "Edit Task",
    "t_add_tasks2": "Add Tasks",
    "t_save_tasks": "Save Tasks",
    "t_tasks_only": "Tasks Only",
    "t_tg": "Task Group",
    "t_tasks": "Tasks",
    "t_id": "Initial Data",
    "t_n_s": "Tasks without start time",
    "t_drag": "Drag a task and drop onto calendar",
    "t_g": "Guidance",
    "t_pol": "Complete All",
    "t_auto": "Allow users to assign themselves (if unassigned)",
    "t_auto2": "Self Assign",
    "t_ass_done": "Have you completed this assignment?",
    "t_defn": "Task Group Definition",
    "t_au": "All Users",
    "t_u": "Unassigned",
    "t_ad": "Assign from data values",
    "t_af": "Create tasks from results submitted after this task group is created",
    "t_ac": "Create tasks from results that have already been submitted",
    "t_start": "Set the start time and duration of the task relative to when it is created or a date in the source survey",
    "t_all": "All tasks",
    "t_dl_dist": "Download distance (meters)",
    "t_dl_dist_i": "The user will need to be within this distance from the geographic center of the tasks in this task group before they will be downloaded onto their device",
    "t_show_dist": "Show distance (meters)",
    "t_show_dist_i": "The user will need to be within this distance from the task before it is displayed on their device",
    "t_show_console": "Show in console",
    "new": "Unassigned",
    "accepted": "Assigned",
    "submitted": "Complete",
    "rejected": "Rejected",
    "cancelled": "Cancelled",
    "deleted": "Deleted",
    "unsent": "Not Sent",
    "unsubscribed": "Unsubscribed",

    // template load errors
    "e_u_err": "Form Upload Error",
    "e_u_exists": "exists in project",
    "e_h_rename": "Change the name of the form or delete the old form",
    "e_u_sm_no_list": "select_multiple question without list name",
    "e_h_sm_no_list": "Check the survey sheet. Make sure you have specified a list name for all the select_multiple questions",
    "e_u_so_no_list": "select_one question without list name",
    "e_h_so_no_list": "Check the survey sheet. Make sure you have specified a list name for all the select_one questions",
    "e_unknown": "Unknown error",
    "e_get_help": "Contact the help desk",
    "e_calc": "Calculation error",
    "e_h_calc1": "Check the 'calculation' column for an invalid formula (A valid formula results in either true or false)",
    "e_h_calc2": "Otherwise check the 'relevant' column for a formula that does not result in a true or false result",
    "e_inv_f": "Invalid Function",
    "e_h_f1": "Check for capital letters, all letters should be lower case",
    "e_h_f2": "Check for spelling mistakes in the name of the function",
    "e_val": "Validation error",
    "e_circ": "Check for circular references",
    "e_in_q": "in question",
    "e_h_c1": "A 'relevant or calculation or choice filter' for question is referring to  itself instead of referring to another question",
    "e_h_c2": "Relevant statements are evaluated before a question is asked so they cannot refer to their own questions",
    "e_brackets": "Mismatched brackets in function",
    "e_text": "Error with the following text:",

    // Register
    "r_o_n": "Organisation Name",
    "r_y_n": "Your Name",
    "r_y_e": "Your Email",
    "r_y_o": "Organisation Website",
    "r_f": "Registration Form",
    "r_s": "Email Subscriptions",

    // Monitor
    "mon_l200": "(last 200)",
    "mon_gtb": "Group Totals by",
    "mon_nl": "Not Loaded",
    "mon_ue": "Upload Errors",
    "mon_dup": "Duplicates",
    "mon_att": "Extra Attachments",
    "mon_sa": "Show As",
    "mon_zoom_grid": "Zoom to Grids",
    "mon_show_grid": "Show Grids",
    "mon_clear_grid": "Clear Grids",
    "mon_create_grid": "Create Grid",
    "mon_del_grid": "Delete Grids",
    "mon_sel_layer": "Select a layer to add to the map as an overlay",
    "mon_c_reg": "Create a new region",
    "mon_c_reg_i": "Enter a name for the region and the width of each cell in meters. Click on the map to set the centre of one of the cells. Press the \"shift\"button and drag the mouse to set the bounds.",
    "mon_name_cond": "(lowercase, no spaces or numbers)",
    "mon_cw": "Cell Width (in Meters. greater than 10)",
    "mon_centre": "Centre: (click on map)",
    "mon_bounds": "Boundary: (click and drag on map while pressing shift key)",
    "mon_sel_del": "Select the regions that you want to delete",
    "mon_ud": "Upload Date",
    "mon_pi": "Phone Identifier",
    "mon_fr": "Failure Reason",
    "mon_file": "File with raw results",
    "mon_optin_msg": "Opt in",
    "mon_send_count": "Send Count",
    "mon_pending_count": "Pending Messages",
    "mon_ignore_old": "Ignore issues older than 100 days",
    "error": "Error",
    "success": "Success",
    "mon_retry": "Re-apply failed uploads",
    "mon_page": "Page %s1 from %s2 to %s3",
    "mon_uid": "Upload Id",

    // Analysis, reports, modify
    "an_auth": "Author",
    "an_published": "Published",
    "an_publish": "Publish",
    "an_dr": "Date Range",
    "an_csel": "Clear Selection",
    "r_add": "Add Report",
    "r_ed": "Edit Report",
    "r_del": "Delete Reports",
    "an_nd": "No data available",
    "an_nmd": "No data matches the filter",
    "an_mod_hint": "The modify page allows you to make bulk changes to text.  You can select a specific text value and then change all occurences of that to another value.  This is very useful for fixing spelling inconsistencies. You can also change text values in \"other\" questions into one of the select choices. You can also update barcode and calculate questions. Other question types are not supported as, for example, it would make no sense to do a bulk change of an integer age from 25 to 26 wherever it occured. You can review modifications by selecting the review page.<br/><br/> You can however update integer, decimal and select1 questions by selecting the checkbox \"Update a different question\". In this case the change will be applied to all questions that match the existing values of the two questions. In most cases you will not need this option.",

    // Server Strings and direct word conversions
    "Upload Time": "Upload",
    "_start": "Start Time",
    "_end": "End Time",
    "percent": "Percentage",
    "count": "Count",
    "none": "None",
    "average": "Average",
    "max": "Max",
    "min": "Min",
    "sum": "Sum",
    "changes": "Update",
    "task": "Task",
    "notification": "Notification",
    "created": "Created",

    // Web forms
    "wf_sig": "Signature",

    // Editor
    "ed_ba": "Background Audio",
    "ed_map_zoom": "Map Zoom",
    "ed_round": "Decimal places",
	"ed_hidden": "Hide in form",
	"ed_selfie": "Open camera in selfie mode",
    "ed_new": "Require a new picture be taken",
	"ed_read_nfc": "Read an NFC tag instead of a barcode",
    "ed_gt_0": "must be greater than 0, or not set",
	"ed_add_to": "Append to question",
    "ed_app": "Put in an appendix",
	"ed_barcode": "Show as a barcode",
    "ed_si": "Show choice images instead of label text",
    "ed_stretch": "Stretch images to take up all space allocated",
	"ed_hyperlink": "Show a hyperlink to the image",
	"ed_col_width": "width of column %s1",
	"ed_place_map": "Allow the user to select their location from a map",
	"ed_l_bold": "Make label bold",
	"ed_caps": "Make label all capitals",
	"ed_npb": "New Page Before",
	"ed_sa": "Spacing above",
	"ed_bgc": "Label Background Colour",
	"ed_vbgc": "Value Background Colour",
    "ed_mc": "Marker Colour",
	"ed_height": "Height allowed for answer",
    "ed_lw": "Width of label",
    "ed_pdfcols_help": "There can be a maximum of 10 columns. The widths of the columns must add up to 10.",
	"ed_pdf_layout": "PDF Layout",
	"ed_pdfno": "Hide question in pdf export",
	"ed_date_type": "Date Type",
	"ed_select_type": "Select Type",
    "ed_nc": "No Calendar",
	"ed_my": "Month and Year",
	"ed_bikram": "Bikram Sambat",
	"ed_coptic": "Coptic",
	"ed_ethiopian": "Ethiopian",
	"ed_islamic": "Islamic",
    "ed_myanmar": "Myanmar",
    "ed_persian": "Persian",
    "ed_r": "Rating",
	"ed_bear": "Bearing",
	"ed_sep": "Thousands Separator",
    "ed_sn": "Show numbers keyboard",
    "ed_numb_cols": "Number of Columns",
	"ed_min": "Minimal",
	"ed_adv": "Auto Advance",
	"ed_ac": "Auto Complete",
	"ed_compact": "Compact",
	"ed_compact_adv": "Compact with auto advance",
	"ed_image_map": "Image Map",
	"ed_pick": "Picker",
    "ed_as": "Add Search",
    "ed_rf": "Reference Form",
    "ed_in": "Instance Name",
	"ed_io": "Instance Order",
	"ed_ic": "Instance Count",
    "ed_ep": "Existing Project",
    "ed_es": "Existing Survey",
    "e_b_e": "Base on existing form",
    "e_s_r": "Store results in shared table",
    "ed_qt": "Question Text",
	"ed_dn": "Display Name",
    "ed_ct": "Choice Text",
    "ed_qh": "Question Hint",
    "ed_cl": "Choice List",
    "ed_appearance": "Appearance",
    "ed_parameters": "Parameters",
    "ed_con": "Constraint",
    "ed_con_msg": "Constraint Message",
    "ed_sct": "Save changes before running auto translate",
    "ed_rel": "Relevant",
    "ed_req": "Required",
    "ed_req_msg": "Required Message",
    "ed_nreq": "Not Required",
    "ed_ap": "Auto play",
    "ed_al": "Automatically Annotate",
	"ed_mat": "Medical Audio Type",
	"ed_mat_c": "Conversation",
	"ed_mat_d": "Dictation",
    "ed_al2": "Use in oversight forms to automatically annotate or translate text, images, audio and video",
	"ed_am": "Medical",
	"ed_am2": "Use when transcribing audio that contains medical terms",
    "ed_at": "GPS Accuracy Threshold",
    "ed_ls": "Linked Survey",
    "ed_ro": "Read Only",
    "ed_ls_add": "Add link",
    "ed_l": "Linked",
    "ed_nl": "Not Linked",
    "ed_r_msg": "Required Text Message",
	"ed_f_l": "The form to be launched must be specified as a parameter",
	"ed_emp_rep": "Sub forms and groups should have at least one visible question.  Calculate questions are not considered visible.",
    "ed_hrk": "Unique Key",
    "ed_dk": "Data Key",
    "ed_csv": "CSV File",
    "ed_c_s": "Source of Choices",
    "ed_p_q": "Source question",
    "ed_cws": "Choices Worksheet",
    "ed_i_c": "Created",
    "ed_st": "Shared Table",
    "ed_ld": "Allow Loading data from file",
    "ed_pd": "Pull data from another survey",
    "ed_i_bo": "Based On",
    "ed_i_tn": "Table Names",
    "ed_tlf": "Top Level Form",
    "ed_namedia": "Media cannot be used with this question",
    "ed_ab": "Add Before",
    "ed_aa": "Add After",
    "ed_aq": "Add New Question",
    "ed_ancl": "Add New Choice List",
    "ed_anc": "Add New Choice",
    "ed_cs": "Cascading Select",
    "ed_cspq": "Previous Select Question",
    "ed_csp": "Previous Selection",
    "ed_cf": "Custom Filter",
    "ed_afc": "Add Filter Column",
	"ed_clabs": "Choice Labels",
    "ed_clab": "Choice Label",
    "ed_cval": "Choice Value",
    "ed_fv": "Filter Value",
	"ed_sfv": "Second Filter Value",
    "ed_choice_f": "Choice Filter",
	"ed_vc": "Choice names must only contain letters, numbers. underscores, dashes and periods",
	"ed_vq": "The question name must start with a letter, underscore or colon and only contain letters, numbers, underscores, dashes and periods",
    "ed_ns": "Add a new survey using the 'File' menu before adding questions",
    "ed_kp": "Key Policy",
    "ed_s1": "Select One",
    "ed_s": "Select Multiple",
    "ed_image": "Image",
    "ed_image_type": "Image Type",
    "ed_int": "Integer",
    "ed_gps": "GPS Point",
    "ed_calc": "Calculation",
    "ed_s_calc": "Server Calculation",
    "ed_ci": "Server Compound PDF Image",
    "ed_cm": "Compound Map",
    "ed_audio": "Audio",
    "ed_video": "Video",
    "ed_bc": "Barcode",
    "ed_dt": "Date and Time",
    "ed_t": "Time",
    "ed_dec": "Decimal",
    "ed_gps_line": "GPS Line",
    "ed_gps_area": "GPS Area",
    "ed_ack": "Acknowledge",
    "ed_range": "Range",
    "ed_graph": "Graph",
    "ed_qs": "Questions set ",
    "ed_ee": "Don't include empty answers in reports",
    "ed_cpdf": "Compress PDF (images will have lower resolution that should be adequate for printing)",
    "ed_er": "Cannot save until errors are fixed",
    "ed_blocked": "The survey has been blocked. Changes cannot be saved.  You can unblock the survey on the form management page.",
    "ed_cml": "Cannot modify languages while there are unsaved changes",
    "ed_cx": "Cannot export to an xlsForm while there are unsaved changes",
    "ed_csr": "Cannot set questions required, or not required, while there are unsaved changes",
    "ed_fi": "Form Identifier",
    "ed_dl": "Default Language",
    "ed_td": "Timing Data",
    "ed_rl": "Record location with questions",
    "ed_rc": "Audit changes to questions",
	"ed_hod": "Hide the form on devices",
    "ed_sld": "Lookup local, unsent, data on device",
    "ed_s_g": "Grid (Web Forms)",
    "ed_s_p": "Pages",
    "ed_c_sr": "All questions set to <span style=\"color:blue;\">required</span>",
    "ed_c_snr": "All questions set to <span style=\"color:red;\">not required</span>",
    "ed_c_del_q": "Deleted question",
    "ed_c_del_o": "Deleted choice %s1 from option list %s2",
    "ed_c_chg_p":  "%s1 property of question %s2 changed to: %s3 from: %s4",
    "ed_c_add_q": "Added question %s1 with type %s2",
    "ed_c_add_o": "Added choice %s1 to choice list: %s2",
    "ed_c_settings": "Settings changed",
    "ed_c_languages": "Languages changed",
    "ed_c_template": "PDF template changed",
    "ed_a_template": "PDF template added",
    "ed_d_template": "PDF template deleted",
    "ed_s_templates": "PDF templates added using the settings dialog cannot be set as 'not available' nor set as default",
    "ed_mmf": "Manage Media Files For this Form",
    "ed_sl": "Survey to launch",
    "ed_slu": "Survey lookup",
    "ed_gsi": "Get Survey Ident",
    "ed_qk": "Question to store the returned key",
	"ed_qkc": "Question in the launched form to get this forms key",
    "ed_pl": "Page Layout",
	"ed_w": "Width in webform grid",
    "ed_m": "Filter",
    "ed_fc": "Filter Column",
	"ed_sfc": "Second Filter Column",
    "ed_addcalc": "Add calculation here",
    "contains": "contains",
    "startsWith": "startsWith",
    "endsWith": "endsWith",
    "ed_ds": "Data Survey",
    "ed_os": "Oversight Survey",
    "ed_nb": "No Buttons",
    "ed_offline": "Offline and Online",
    "ed_online": "Online Only",
    "ed_csa": "changes successfully applied",
    "ed_csf": "changes failed",
    "ed_transd": "Translations done from language %s1 to language %s2",
    "ed_ow": "Overwrite existing translations",
    "ed_fe": "Filter Expression",
    "ed_e": "Expression",
    "ed_drl": "Default report logo",
    "ed_voice": "Voice only",
    "ed_na": "Not available",

    // Managed Forms
    "mf_id": "Include Deleted",
    "mf_cc": "Include Completed Cases",
    "mf_fd": "Form Data",
    "mf_md": "Management Data",
    "mf_sc": "Visible Columns",
    "mf_sc_i": "Select the columns that you want to see in the table then press the 'Apply' button. You can then sort on these columns",
    "mf_qr": "QR Columns",
    "mf_bc_i": "Select the columns that you want to see as barcodes in the table and in reports",
    "mf_st": "Submission Tracking",
    "mf_gr": "Get related",
    "mf_of": "Oversight Survey",
    "mf_no": "There are no oversight forms. They can be added in the \"Available Oversight Forms\" tab",
    "mf_sel": "Select the form that you want to manage and the oversight form that you want to manage it with.",
    "mf_ao": "Available oversight forms",
    "mf_mf": "Managed forms",
    "mf_ld": "Layer details",
    "mf_tr": "A title is required",
    "mf_sr": "Summary Report",
    "mf_lock": "Lock for editing",
    "mf_rel": "Release",
    "mf_mr": "My records",
    "mf_ur": "Unassigned records",
    "mf_or": "Other records",
    "mf_max": "Max records",
    "mf_clear": "Clear single record view",
    "mf_sc": "Show Controls",
    "mf_hc": "Hide Controls",
    "mf_ts": "Table Settings",

    // User trail
    "ut_mps": "Max point separation to include in a single line",
    "ut_mps_err": "Max point separation must be greater than 0",

    // Logout
    "lo_back": "Back",
    "lo_out": "You are logged out of ",
    "lo_lo": "Logged Out",
    "lo_loa": "You should now close your browser in order to ensure cached log in details are removed",

    // Users
    "u_show_u": "Show users with security group",
    "u_show_p": "Show users in project",
    "u_show_r": "Show users with role",
	"u_show_o": "Show users with organisation",
    "u_add": "Add User",
    "u_del": "Delete User",
    "u_mv": "Move To Organisation",
    "u_cms": "Case management Settings",
	"u_mv_ent": "Move To Enterprise",
    "u_add_p": "Add Project",
    "u_del_p": "Delete Project",
    "u_add_o": "Add Organisation",
    "u_del_o": "Delete Organisation",
	"u_add_e": "Add Enterprise",
	"u_del_e": "Delete Enterprise",
    "u_add_r": "Add Role",
    "u_add_s": "Add Setting",
    "u_edit_r": "Edit Role",
    "u_del_r": "Delete Role",
    "u_det": "User Details",
    "u_ident": "Ident (lowercase, no spaces or an email address)",
    "u_email": "Send email to new user",
    "u_set_p": "Specify password",
    "u_sg": "Security Groups",
    "u_det_p": "Project Details",
    "u_det_ur": "User Role Details",
    "u_det_o": "Organisation Details",
    "u_det_e": "Enterprise Details",
    "u_det_o_rep": "Report Publishing Options",
    "u_det_o_ft": "Mobile App Options",
	"u_det_o_wf": "Webform Options",
    "u_det_pbc": "Page background color",
	"u_det_paperbc": "Paper background color",
    "u_det_buttonbc": "Button color",
    "u_det_buttontc": "Button text colors",
    "u_det_headertc": "Heading text colors",
	"u_det_fp": "Footer position (from right in pixels)",
    "u_wf_hd": "Hide 'save as draft' checkbox",
    "u_ft_del": "Delete submitted results from the phone",
    "u_ft_prev_track_dis": "Prevent the disabling of location tracking",
    "u_ft_img_size": "Maximum pixels of the long edge of an image",
    "u_ft_img_camera": "Original size from camera",
    "u_ft_vs": "Very small (640px)",
    "u_ft_s": "Small (1024px)",
    "u_ft_m": "Medium (2048px)",
    "u_ft_l": "Large (3072px)",
    "u_ft_ld": "Send location data on path of user",
    "u_ft_os": "Enable ODK style menus to delete, submit, edit and get new forms",
    "u_ft_am": "Enable ODK Admin menu",
    "u_ft_ex": "Disable exit menu",
    "u_ft_bgs": "Prevent background audio from being disabled",
    "u_ft_in": "Allow user to set instance name",
    "u_ft_mf": "Allow user to mark  forms as not finalized",
    "u_ft_rv": "Allow finalised forms to be opened for review",
    "u_ft_as": "Automatically Synchronise",
    "u_ft_ms": "Manual Synchronisation",
    "u_ft_sw": "WIFI",
    "u_ft_hrv": "High Resolution Video",
    "u_ft_sw_c": "WIFI and cellular network",
    "u_ft_sop": "Set on phone",
    "u_ft_tasks": "Maximum number of tasks to download",
	"u_ft_back_nav": "Backward navigation",
	"u_ft_nav": "Screen Navigation",
	"u_ft_pw_timeout": "Number of days before password expiry",
    "u_ft_pw_policy": "Password policy",
	"u_ft_never": "Never require logon",
	"u_ft_always": "Always require logon on application start",
	"u_ft_periodically": "Require logon periodically",
    "u_ft_swipes": "Use horizontal swipes",
    "u_ft_buttons": "Use forward/backward buttons",
    "u_ft_swipes_buttons": "Use swipes and buttons",
    "u_ft_sa": "Yes - always shown",
    "u_ft_sc": "Yes - collapsed",
    "u_ft_ss": "Enable server settings menu",
    "u_ft_md": "Enable user and identity menu",
	"u_ft_eg": "Enable Geo-fence",
    "u_det_o_email": "Email Options",
    "u_det_o_other": "Other Options",
    "u_det_o_limits": "Monthly Usage Limits",
    "u_other_edit": "Allow editing of results",
    "u_email_tasks": "Allow sending of task emails",
	"u_use_api": "Allow API access",
	"u_submissions": "Allow submissions",
	"u_notifications": "Allow notifications",
    "u_sms": "Allow SMS",
    "u_mb_k": "Mapbox Key",
    "u_mb_a": "Mapbox Account",
    "u_mb_s": "Mapbox Style Id",
    "u_g_k": "Google Maps Key",
    "u_smtp": "Smtp Host",
    "u_e_dom": "Email Domain",
    "u_e_nm": "Email user name",
    "u_e_si": "Server Identifier",
    "u_e_p": "Email password",
    "u_e_port": "Email Server port",
    "u_h_e": "Email to get Help",
    "u_rap": "Restrict access",
    "u_rap_d": "Administrators will be able to assign the selected users only to this project",
    "u_chg": "Changed by",
	"u_usage": "Usage Report",
    "u_attendance": "Attendance Report",
    "u_notification": "Notification Report",
	"u_access": "Form Access Report",
    "u_r_u": "Resource Usage Report",
    "u_sms_url": "SMS Url",
    "u_sens_data": "Sensitive Data",
    "u_sens_ao": "Admin Only",
    "u_sens_sq": "Signature Questions",
    "u_sens_nr": "No restrictions",
    "u_org_admin": "Organisation Administrator",
    "u_ent_admin": "Enterprise Administator",
    "u_server_owner": "Server Owner",
	"u_check_mv_p": "Are you sure you want to move the following projects (%s1) to %s2",
	"u_check_mv_o": "Are you sure you want to move organisation \"%s1\" to enterprise \"%s2\"",
    "u_only_one_ent": "Only one enterprise has been created.  You need to create another one to move an organisation there",
    "u_co": "Current Organisation",
    "u_gr": "Get report",
    "u_sat": "Set as Theme",
    "u_bl": "WebForm Banner Logo (Height 50px)",
    "u_ml": "Main Logo",
    "u_nbc": "Navigation bar color",
    "u_nbtc": "Navigation bar text color",
    "u_eoi": "Enable Opt In",
    "admin": "Administrator",
    "analyst": "Analyst",
    "enterprise admin": "Enterprise Admin",
    "enum": "Enumerator",
    "manage": "Manage Data",
    "org admin": "Organisational Admin",
    "security": "Security Manager",
    "view data": "View Data",
    "manage tasks": "Manage Tasks",
    "view own data": "View Own Data",
    "dashboard": "Dashboard",
    "u_css_f": "CSS file",
    "u_css": "Upload a CSS style sheet",
    "u_css_ss": "Upload a new CSS style sheet for the server",
    "u_css_ss_org": "Upload a new CSS style sheet for the current organisation",
    "u_css_del": "Delete CSS style sheet",
    "u_css_sel": "Select a style sheet",
    "u_css_info": "Create a custom style sheet using <a href='https://themestr.app/theme' target='_blank'>this website</a> and then upload to the server",
    "u_clear_p": "Clear existing empty imported projects",
    "u_clear_u": "Clear existing imported users",
    "u_clear_r": "Clear existing imported roles",
    "u_api_rl": "Rate limit for data API",
    "u_api_rlm": "Minimum number of milli seconds between API Data requests. Any requests received less than this time since the previous request will be rejected. Applies to both json and csv data requests. The smaller the number the higher the volume of API requests allowed",
    "u_mps": "Minimum password strength",

    // Browse Results
    "br_ci": "Case Insensitive",
    "br_exact": "Exact Match",
    "br_cc": "Select the columns that you want to test for similarities in the data. For each column that you want to test you can select a function to broaden the range of values that will match.",
    "br_s": "Search",
    "br_sdx": "Soundex",
    "br_cd": "Use the table of data for this survey view",
    "br_tf": "for text questions, including select and select_one",
    "br_nf": "for numeric questions, including integer and decimal",

    // Shared Resources
    "sr_res": "Images Video Audio and CSV Files",
    "sr_nfc": "NFC Tags",
    "sr_uid": "NFC UID",
    "sr_geo": "Geographic locations",
    "ar_af": "Add Files",
    "sr_g": "Group",
    "sr_fn": "File Name",
    "sr_m_ph": "Enter a name for your map",
    "sr_m_d": "Enter a description for this map (optional)",
    "sr_m_mb": "For Mapbox this identifies the map, for example: mapbox/light-v10",
    "sr_cr": "Custom Reports",
    "sr_al": "Use Anonymous Location in Task",
    "sr_ul": "Update Existing Location",
    "sr_nl": "Save as New Location",
    "sr_sl": "Save Location",
    "sr_si": "The NFC UID and GPS coordinates that you specify here can be saves as a named location or used in the task as an anonymous location",

    // languages
    "ar": "Arabic",
    "en": "English",
    "fr": "French",
    "hi": "Hindi",
    "pt": "Portuguese",
    "es": "Spanish",

    // Notifications
    "n_wf": "Web Form",
    "n_pdfp": "PDF (Portrait)",
    "n_pdfl": "PDF (Landscape)",
    "n_eq": "Email Question",
    "n_ep": "Email Meta Item",
    "n_smsq": "SMS Question",
    "n_share": "Get link",
    "n_cs_e": "Comma separated list of email addresses",
    "n_ea": "Email addresses",
    "n_eq": "Email question",
    "n_eqc": "Question that will contain the email addresses to use",
    "n_esc": "Subject for the email (optional)",
    "n_inc_ref": "Include referenced surveys",
	"n_lo": "Only reference data from forms that were launched from this form",
    "task_reminder": "Task Reminder",
    "submission": "Submission",
    "console_update": "Console Update",
    "n_p": "Send reminder after",
    "n_oa": "Email original assignee",
    "n_ap": "Add placeholder",
    "n_si": "SMS Sender Id",
    "n_sms_n_tt": "Comma separated list of phone numbers in format +ccnnnnnnnnnn",
    "n_sms_q_tt": "Question that will contain the SMS numbers to use",
    "n_e_p_tt": "Meta item or preload that will contain an email address to use",
    "n_uq": "Update Question",
    "n_uv": "Update Value",
    "n_no_oversight": "There are no oversight surveys that can be used to update the data in the console",
    "n_nv": "A value for the update must be specified",
    "n_nq": "An update question must be specified",
    "n_curl": "Callback URL",

    // Roles
    "ro_fr": "Filter rows",
    "ro_fc": "Filter columns",
    "ro_fr_rule": "Rows to be shown",
    "ro_aq": "Available Questions",
    "ro_fr_i": "Enter a rule that determines which rows will be shown for this role. Enclose question names in ${...}. Enclose text in single quotes. Make sure there are spaces between the question names and operators such as =.<br/>Example 1: ${region} = 'northern'<br/>Example 2: ${age} > 16. If no rule is specified then all rows will be shown.",
    "ro_fc_i": "Select the columns to show with this filter. If no columns are selected then all columns will be shown.",
    "ro_transform": "Long to wide data transformation",

    // Intervals
    "i_m": "minutes",
    "i_h": "hours",
    "i_d": "days",
    "i_sec": "second ago",
    "i_secs": "seconds ago",
    "i_min": "minute ago",
    "i_mins": "minutes ago",
    "i_hour": "hour ago",
    "i_hours": "hours ago",
    "i_day": "day ago",
    "i_days": "days ago",

    // Dashboard
    "d_sound": "Play sound on new alert",
    "d_rep_def_freq": "Frequency Report",
    "bar_h": "Horizontal Bar Chart",
    "bar_v": "Vertical Bar Chart",
    "stacked": "Stacked",
    "normalized": "Normalized",
    "pie": "Pie Chart",
    "line": "Line Chart",
    "wordcloud": "Word Cloud",
    "length": "Count",
    "d_qtr": "25%",
    "d_half": "50%",
    "d_3qtr": "75%",
    "d_full": "100%",
    "d_sec": "Seconds",
    "d_min": "Minutes",
    "d_hour": "Hours",
    "d_day": "Days",
    "d_c_day": "Count by day",
    "d_c_month": "Coount by month",
    "d_c_year": "Count by year",
    "d_add": "Add",
    "d_add_c": "Add Chart",
    "d_add_q": "Add New Query",
    "d_add_f": "Add New Form",
    "d_from_f": "Link From Form",
    "d_from_q": "Link From Question",
    "d_edit_web": "Edit in Web Form",
    "d_d_pdf": "Download PDF",
    "d_layers": "Map Layers",

    // Review
    "rev_upd_diff": "Update a different question to the source question",
    "rev_sel_pk": "Select data to change using a primary key",
    "rev_q_upd": "Question to update",
    "rev_text": "Text",
    "rev_upd": "Update",
    "rev_upd_t": "Update target question",
    "rev_upd_text": "Update Text Questions",
    "rev_rt": "Replace text",
    "rev_rc": "records with choice",
    "rev_fq": "from question",
    "rev_rw": "records with",
    "rev_rdm": "Review Data Modifications",
    "rev_ci": "Change Id",
    "rev_rb": "Reversed By",
    "rev_cb": "Changed By",
    "rev_rcn": "Reverse Change Number",
    "rev_det": "Details for change number",
    "rev_cq": "Changed Question",
    "rev_sc": "Selcted Choice",
    "rev_usc": "Un-Selected Choice",

    // Chart Questions
    "ch_ds": "Chart Data",

    // Billing
    "quantity": "Quantity",
    "free": "Free",
    "unitCost": "Unit Cost",
    "amount": "Amount",
    "server": "Server",
    "submissions": "Submissions",
    "submissions_i": "A limit of zero is unlimited",
    "disk": "Disk",
    "rekognition": "AWS Rekognition",
    "rekognition_i": "images",
    "translate": "AWS Translate",
    "translate_i": "letters",
	"transcribe_medical": "AWS Transcribe Medical",
	"transcribe_medical_i": "seconds of audio",
    "transcribe": "AWS Transcribe",
    "transcribe_i": "seconds of audio",
	"static_map": "Mapbox Static Map",
	"monthly": "Monthly Charge",
    "org_bill_rpt": "Organisation Usage Report",
    "bill_enable": "Enable Billing",
    "bill_from": "Applies From",
    "bill_chg_date": "Date Changed",
    "bill_norates": "No rates have been set for this %s1. If billing is enabled then the rates for the %s2 will be used",
	"billing_disabled_msg": "Billing has been disabled",

	// Reports
	"rep_usage_project": "Usage by project",
	"rep_usage_survey": "Usage by survey",
    "rep_usage_device": "Usage by device",
    "rep_values_question": "Values Question",
    "rep_values": "Values",
    "rep_wide_columns": "Wide Columns",
    "rep_msg_min_keys": "You must specify at least one key question if transform is enabled",
    "rep_msg_v_q": "You must specify a values question if transform is enabled",
	"rep_msg_min_values": "You must specify at least one value if transform is enabled",
	"rep_msg_min_wc": "You must specify at least one wide column if transform is enabled",
    "rep_ch": "Column Heading",
    "rep_inc_temp": "Include temporary users",
    "rep_gen": "Generated Reports",
    "rep_gen_ov": "Reports generated by a background process can be downloaded from here.  They will be kept for 2 weeks and then automatically deleted",
    "locations_distance": "Distance travelled",
    "locations_kml": "KML",
    "rep_au": "Include all users in project",
    "rep_d": "Generation time (seconds)",
    "rep_my": "Month and year of the report",

    // Console
    "co_dd": "Drill Down",
    "co_up": "Up",
    "co_tid": "Include text value in Download",
    "co_b": "Bulk Change",

    // Mailouts
    "mo_ce": "Clear Existing Unsent Emails",
    "mo_ns": "Mailout not selected",
    "mo_na": "Not Authorised",
    "mo_nf": "The survey form was not found",
    "mo_ss": "This survey form has been sucessfully submitted",
    "mo_exp": "This survey form has expired",
    "mo_del_done": "This survey form has been deleted",
    "mo_se": "System Error",
    "mo_del": "Are you sure that you want to delete mailout \"%s1\".  Recipients who have already been sent emails will no longer be able to respond. ",
    "mo_blocked": "This survey form has been blocked.  Try again later or contact the administrator to unblock",
    "mo_import": "Import Emails",
    "mo_export": "Export Emails",
    "mo_subject": "Email Subject",
    "mo_content": "Email Content",
    "mo_sent": "Sent",
    "mo_sd": "Status Details",
    "mo_ms": "Multiple Submissions",
    "mo_send": "Are you sure you are ready to send the emails?",
    "mo_gen": "Are you sure you are want to generate the links now?  They are created automatically when you use the email unsent button however you can generate them now if you want to send them via a different channel. For single submission links, once created they will expire in 30 days.",

    // AWS Services
    "svc_at": "Auto Translate",
    "svc_from_l": "From Language",
    "svc_to_l": "To Language",

    // Logs
    "log_hr": "Hourly Summary",
    "log_sd": "Survey Details",

    // Login
    "li_success": "Login successful",
    "li_failure": "Login failure",
    "li_continue": "Return to applications",

    // Case Management
    "cm_fs": "Final status",
    "cm_sq": "Status Question",
    "cm_cq": "Criticality Question",
    "cm_aa": "Add an Alert",
    "cm_dcms": "There is already a case management event with that name for this survey group",
    "cm_alert_a": "Alert if not finalised within",
    "cm_a": "Case management alert",
    "cm_bar": "Bar",
    "cm_col": "Column",
    "cm_pie": "Pie",
    "cm_alert": "Case Management Alert",
    "cm_ns": "Select a survey to see case data",
    "cm_oc": "Count of cases opened and closed per day",
    "cm_p": "Show data for last",
    "cm_7days": "7 days",
    "cm_14days": "14 days",
    "cm_30days": "30 days"

});


/*
This file is part of SMAP.

SMAP is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SMAP is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

*/

define('localise',['jquery', 'i18n!lang_location/nls/lang'], function($, lang) {
	
	var dtLangFiles = {
			en: "",
			es: "/js/libs/DataTables.i18n/es.json",
			ar: "/js/libs/DataTables.i18n/ar.json",
			fr: "/js/libs/DataTables.i18n/fr.json",
			pt: "/js/libs/DataTables.i18n/pt.json",
			hi: "/js/libs/DataTables.i18n/hi.json"
	}
	
	window.localise = {	// Set global while migrating app to AMD
		
		
		setlang: function () {

			// Content
			$(".lang").each(function(index) {
				var $this = $(this);
				var code = $this.data("lang");
				if(code) {		
					$this.html(lang[code]);
				}
			});

			// tooltips
			$(".lang_tt").each(function(index) {
				var $this = $(this);
				var code = $this.data("lang_tt");
				if(code) {
					$this.prop("title", lang[code]);
				}
			});

			// placeholders
			$(".lang_ph").each(function(index) {
				var $this = $(this);
				var code = $this.data("lang_ph");
				if(code) {
					$this.prop("placeholder", lang[code]);
				}
			});

			if(typeof responsiveMobileMenu === "function") {
				rmmResizeLabels();		// Resize menus
			}
		},
		set: lang,
		dt: function() {
			return dtLangFiles[gUserLocale];
		}
	}
	
	return localise;
});
/*
 This file is part of SMAP.

 SMAP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 SMAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

 */

/*
 * Quick solution to issue of legacy globals after migrating to AMD / require.js
 */
define('globals',[],function () {
    window.globals = {

        // Security groups
        GROUP_ADMIN: 1,
        GROUP_ANALYST: 2,
        GROUP_ENUM: 3,
        GROUP_ORG_ADMIN : 4,
        GROUP_MANAGE: 5,
        GROUP_SECURITY: 6,
        GROUP_VIEW_DATA: 7,
        GROUP_ENTERPRISE : 8,
        GROUP_OWNER : 9,
		GROUP_VIEW_OWN_DATA : 10,
	    GROUP_MANAGE_TASKS : 11,
	    GROUP_DASHBOARD : 12,

        REC_LIMIT: 200,     // Page size for table views in analysis
	    MAP_REC_LIMIT: 1000,    // Max size for map views in analysis

        gProjectList: undefined,
        gRoleList: undefined,
        gCmSettings: undefined,
        gCurrentProject: 0,
        gCurrentSurvey: 0,
	    gGroupSurveys: {},
	    gSubForms: {},
        gCurrentForm: 0,
        gCurrentLayer: undefined,
        gLoggedInUser: undefined,
        gEditingReportProject: undefined,   		// Set if fieldAnalysis called to edit a report
        gIsAdministrator: false,
        gIsEnum: false,
        gIsAnalyst: false,
	    gIsDashboard: false,
        gIsManage: false,
        gIsOrgAdministrator: false,
        gIsSecurityAdministrator: false,
        gIsEnterpriseAdministrator: false,
        gIsServerOwner: false,
        gViewData: false,
	    gManageTasks: false,
        gBillingData: false,
        gOrgBillingData: false,
        gSendTrail: 'off',
        gViewIdx: 0,
        gSelector: new Selector(),
        gOrgId: 0,
        gTimezone: undefined,
	    gEnterpriseName: undefined,
	    gSetAsTheme: undefined,
	    gNavbarColor: undefined,

        gRegions: undefined,
        gRegion: {},

        gServerCanSendEmail: false,

        // Reports
        gEmailEnabled: false,
        gFacebookEnabled: false,
        gTwitterEnabled: false,

        // Tasks
        gCurrentUserId: undefined,
        gCurrentUserName: undefined,
        gAssignmentsLayer: undefined,
        gPendingUpdates: [],
        gCurrentTaskGroup: undefined,
	    gCurrentMailout: undefined,
        gTaskList: undefined,
        gCurrentSurveyIndex: 0,
	    gCurrentInstance: undefined,
        gAlertSeen: false,
        gLastAlertTime: undefined,

        // Editor
        gExistingSurvey: false,		// Set true if modifying an existing survey
        gElementIndex: 0,			// Manage creation of unique identifier for each element (question, option) in editor
        gHasItems: false,			// Set true if there are questions or choice lists in the survey
        gNewQuestionButtonIndex: 0,	// Manage creation of unique identifier for buttons that add new questions
        gNewOptionButtonIndex: 0,
        gSId: 0,
        gLanguage: 0,
        gLanguage1: 0,
        gLanguage2: 0,
        errors: [],
        changes: [],
        gErrorPosition: 0,
        gSelProperty: 'label',
        gSelLabel: 'Question Text',
        gSelQuestionProperty: 'label',
        gSelQuestionLabel: 'Question Text',
        gSelChoiceProperty: 'label',
        gSelChoiceLabel: 'Question Text',
        gIsQuestionView: true,
        gShowingChoices: false,
        gMaxOptionList: 0,
        gLatestOptionList: undefined,	// Hack to record the last option list name added
	    gCsvFiles: undefined,

        gListName: undefined,					// Choice Modal parameters, Set if started from choice list view
        gOptionList: undefined,					// The option list name applying to this set of choices
        gSelOptionId: undefined,				// Selected option index
        gFormIndex: undefined,					// Selected form index
        gItemIndex: undefined,					// Selected question index
        gSelectedFilters: undefined,
        gFilterArray: undefined,

        gSaveInProgress: false,

        // Dashboard
        gMainTable: undefined,			// Data tables
        gReports: undefined,			// reports
        gCharts: {},					// charts
	    gRecordMaps: [],                // Maps shown when editing a record
	    gRecordChangeMaps: [],          // Maps shown when viewing change history
        gMapLayersShown: false,
        gViewId: 0,						// Current survey view

	    gTraining: undefined,
	    gRefreshRate: 0,

        gMapboxDefault: undefined,		// Mapbox key
        
        model: new Model()

    }

    return window.globals;

    function Selector() {

        this.dataItems = new Object();
        this.surveys = new Object();
        this.surveysExtended = new Object();
        this.surveyLanguages = new Object();
        this.surveyQuestions = new Object();
        this.surveyMeta = new Object();
        this.surveyAlerts = new Object();
        this.questions = new Object();
        this.allSurveys;				// Simple list of surveys
        this.allRegions;
        this.sharedMaps;
        this.views = [];			// Simple list of views
        this.maps = {};				// map panels indexed by the panel id
        this.changed = false;
        this.SURVEY_KEY_PREFIX = "surveys";
        this.TASK_KEY = "tasks";
        this.TASK_COLOR = "#dd00aa";
        this.SURVEY_COLOR = "#00aa00";
        this.SELECTED_COLOR = "#0000aa";
        this.currentPanel = "map";

        /*
         * Get Functions
         */
        this.getAll = function () {
            return this.dataItems;
        };

        this.getItem = function (key) {
            return this.dataItems[key];
        };

        // Return all the table data available for a survey
        this.getFormItems = function (sId) {
            var tableItems = new Object();
            for (var key in this.dataItems) {
                var item = this.dataItems[key];
                if (item.table == true && item.sId == sId) {
                    tableItems[key] = item;
                }
            }
            return tableItems;
        };

        this.getSurvey = function (key) {
            return this.surveys[key];
        };

        this.getSurveyExtended = function (key) {
            return this.surveysExtended[key];
        };

        this.getSurveyQuestions = function (sId, language) {
            var langQ = this.surveyQuestions[sId];
            if (langQ) {
                return langQ[language];
            } else {
                return null;
            }
        };

        this.getSurveyMeta = function (key) {
            return this.surveyMeta[key];
        };

        this.getSurveyAlerts = function (key) {
            return this.surveyAlerts[key];
        };

        this.getSurveyLanguages = function (key) {
            return this.surveyLanguages[key];
        };

        // Returns the list of surveys on the home server
        this.getSurveyList = function () {
            return this.allSurveys;
        };

        this.getRegionList = function () {
            return this.allRegions;
        };

        this.getSharedMaps = function () {
            return this.sharedMaps;
        };

        // deprecate question meta should be replaced by all question details in the question list
        this.getQuestion = function (qId, language) {
            var langQ = this.questions[qId];
            if (langQ) {
                return langQ[language];
            } else {
                return null;
            }
        };

        /*
         * Get the question details that came with the question list
         * This approach should replace the concept of "question meta"
         */
        this.getQuestionDetails = function (sId, qId, language) {
            var qList = this.getSurveyQuestions(sId, language),
                i;

            if (qList) {
                for (i = 0; i < qList.length; i++) {
                    if (qList[i].id == qId) {
                        return qList[i];
                    }
                }
            }
            return null;
        };

        this.hasQuestion = function (key) {
            if (this.questions[key] != undefined) {
                return true;
            } else {
                return false;
            }
        };

        // Return the list of current views
        this.getViews = function () {
            return this.views;
        };

        // Return a map if it exists
        this.getMap = function (key) {
            return this.maps[key];
        };


        /*
         * Set Functions
         */
        this.addDataItem = function (key, value) {
            this.dataItems[key] = value;
            this.changed = true;
        };

        this.clearDataItems = function () {
            this.dataItems = new Object();
        };

        this.clearSurveys = function () {
            this.surveys = new Object();
            this.surveyLanguages = new Object();
            this.surveyQuestions = new Object();
            this.surveyMeta = new Object();
            this.surveyAlerts = new Object();
            this.questions = new Object();
            this.allSurveys = undefined;
            this.allRegions = undefined;
        };

        this.setSurveyList = function (list) {
            this.allSurveys = list;
            if (typeof list[0] !== "undefined") {
                this.selectedSurvey = list[0].sId;
            }
        };

        this.setSurveyLanguages = function (key, value) {
            this.surveyLanguages[key] = value;
        };

        this.setSurveyQuestions = function (sId, language, value) {
            var langQ = new Object();
            langQ[language] = value;
            this.surveyQuestions[sId] = langQ;
        };

        this.setSurveyMeta = function (key, value) {
            this.surveyMeta[key] = value;
        };

        this.setSurveyAlerts = function (key, value) {
            this.surveyAlerts[key] = value;
        };

        this.setRegionList = function (list) {
            this.allRegions = list;
        };

        this.setSharedMaps = function (list) {
            this.sharedMaps = list;
        };

        this.addSurvey = function (key, value) {
            this.surveys[key] = value;
        };

        this.addSurveyExtended = function (key, value) {
            this.surveysExtended[key] = value;
        };

        this.setSelectedSurvey = function (survey) {
            this.selectedSurvey = survey;
        };

        this.setSelectedQuestion = function (id) {
            this.selectedQuestion = id;
        };

        this.addQuestion = function (qId, language, value) {
            var langQ = this.questions[qId];
            if (!langQ) {
                this.questions[qId] = new Object();
                langQ = this.questions[qId];
            }
            langQ[language] = value;
        };

        // Set the list of views to the passed in array
        this.setViews = function (list) {
            this.views = list;
        };

        // Set the passed in map into the maps object indexed by key
        this.setMap = function (key, value) {
            this.maps[key] = value;
        };

    }

    /*
     * Model for Survey editing
     */
    function Model() {

        this.survey = undefined;
        this.translateChanges = [];
        this.currentTranslateChange = 0;
        this.savedSettings = undefined;
        this.forceSettingsChange = false;

	    // A list of valid appearances for each question type
	    this.qAppearances = {
		    'begin group': ['page', 'w'],
		    string: ['numbers', 'thousands-sep', 'w', 'url'],
		    note: ['w'],
            select1: ['select1_type', 'search', 'likert', 'no-buttons', 'w'],
            select: ['select_type', 'search', 'no-buttons', 'w'],
            image: ['image_type', 'selfie', 'new', 'w'],
            int:['thousands-sep', 'w'],
		    geopoint:['placement-map', 'w'],
		    audio:['w', 'new'],
		    video:['selfie', 'w', 'new'],
		    barcode:['read_nfc', 'w'],
		    date:['date_type', 'w'],
		    dateTime:['date_type', 'no-calendar', 'w'],
		    time:['w'],
            decimal:['thousands-sep', 'bearing', 'w'],
		    geotrace:['placement-map', 'w'],
		    geoshape:['placement-map', 'w'],
		    acknowledge:['w'],
		    range:['w', 'rating', 'vertical', 'picker'],
		    file:['w'],
		    rank:['w'],
            geocompound:['w', 'placement-map']
	    };

	    this.appearanceDetails = {
		    'page': {
			    field: 'a_page',
			    type: 'select',
                rex: 'field-list|table-list',
                valIsAppearance: true,
			    value_offset: 0,
                undef_value: ''
		    },
		    'image_type': {
			    field: 'a_image_type',
			    type: 'select',
			    rex: 'annotate|draw|signature',
			    valIsAppearance: true,
			    value_offset: 0,
			    undef_value: ''
		    },
		    'select1_type': {
			    field: 'a_select1_type',
			    type: 'form',
			    rex: 'minimal|quick$|autocomplete|columns|quickcompact|image-map'
		    },
		    'select_type': {
			    field: 'a_select_type',
			    type: 'form',
			    rex: 'minimal|autocomplete|columns|image-map'
		    },
		    'date_type': {
			    field: 'a_date_type',
			    type: 'select',
			    rex: 'no-calendar|month-year|year|coptic|ethiopian|islamic|myanmar|persian|bikram-sambat',
			    valIsAppearance: true,
			    value_offset: 0,
			    undef_value: ''
		    },
		    'no-calendar': {
			    field: 'a_no_calendar',
			    type: 'boolean',
			    rex: 'no-calendar'
		    },
		    'placement-map': {
			    field: 'a_placement-map',
			    type: 'boolean',
			    rex: 'placement-map'
		    },
		    'search': {
			    field: 'a_search',
			    type: 'form',
			    rex: 'search\\(|lookup_choices\\('
		    },
		    'rating': {
			    field: 'a_rating',
			    type: 'boolean',
			    rex: 'rating'
		    },
		    'likert': {
			    field: 'a_likert',
			    type: 'boolean',
			    rex: 'likert'
		    },
		    'no-buttons': {
			    field: 'a_no_buttons',
			    type: 'boolean',
			    rex: 'no-buttons'
		    },
		    'selfie': {
			    field: 'a_selfie',
			    type: 'boolean',
			    rex: 'selfie'
		    },
		    'new': {
			    field: 'a_new',
			    type: 'boolean',
			    rex: 'new'
		    },
		    'read_nfc': {
			    field: 'a_read_nfc',
			    type: 'boolean',
			    rex: 'read_nfc'
		    },
		    'vertical': {
			    field: 'a_vertical',
			    type: 'boolean',
			    rex: 'vertical'
		    },
		    'picker': {
			    field: 'a_picker',
			    type: 'boolean',
			    rex: 'picker'
		    },
		    'bearing': {
			    field: 'a_bearing',
			    type: 'boolean',
			    rex: 'bearing'
		    },
		    'thousands-sep': {
			    field: 'a_sep',
			    type: 'boolean',
			    rex: 'thousands-sep'
		    },
		    'numbers': {
			    field: 'a_numbers',
			    type: 'boolean',
			    rex: 'numbers'
		    },
		    'url': {
			    field: 'a_url',
			    type: 'boolean',
			    rex: 'url'
		    },
		    'w': {
			    field: 'a_width',
			    type: 'select',
                rex: 'w[1-9]|w1[0-2]',
                value_offset: 1,
                undef_value: ''
		    }
	    };

        // A list of valid parameters for each question type
        this.qParams = {
            string: ['rows', 'auto_annotate', 'source', 'from_lang', 'to_lang', 'medical', 'med_type'],
	        calculate: ['auto_annotate', 'source', 'from_lang', 'to_lang', 'medical', 'med_type'],
	        barcode: ['auto'],
            image: ['max-pixels', 'auto'],
	        video: ['auto'],
	        audio: ['auto', 'quality'],
            range: ['start', 'end', 'step'],
            select: ['randomize'],
            select1: ['randomize'],
            rank: ['randomize'],
            parent_form: ['form_identifier', 'key_question', 'auto'],
	        child_form: ['form_identifier', 'key_question', 'auto'],
	        geopoint: ['auto'],
            'begin repeat':['ref', 'instance_order', 'instance_count', 'key_policy'],
	        chart: ['chart_type', 'stacked', 'normalized']
        };

        this.paramDetails = {
	        rows: {
	            field: 'p_rows',
                type: 'integer'
            },
            'max-pixels': {
	            field: 'p_max_pixels',
                type: 'integer'
            },
            start: {
	            field: 'p_start',
                type: 'number'
            },
	        end: {
		        field: 'p_end',
		        type: 'number'
	        },
	        step: {
		        field: 'p_step',
		        type: 'number'
	        },
	        randomize: {
		        field: 'p_randomize',
		        type: 'boolean'
	        },
	        auto: {
		        field: 'p_auto',
		        type: 'boolean'
	        },
	        quality: {
		        field: 'p_quality',
		        type: 'select'
	        },
	        auto_annotate: {
		        field: 'p_auto_annotate',
		        type: 'boolean'
	        },
	        medical: {
		        field: 'p_medical',
		        type: 'boolean'
	        },
	        med_type: {
		        field: 'p_med_type',
		        type: 'select'
	        },
	        source: {
		        field: 'p_source',
		        type: 'select'
	        },
	        from_lang: {
		        field: 'from_lang',
		        type: 'select'
	        },
	        to_lang: {
		        field: 'to_lang',
		        type: 'select'
	        },
	        form_identifier: {
		        field: 'p_form_identifier',
		        type: 'select'
	        },
	        key_question: {
		        field: 'p_key_question',
		        type: 'select'
	        },
	        ref: {
		        field: 'p_ref',
		        type: 'select'
	        },
	        instance_order: {
		        field: 'p_instance_order',
		        type: 'select'
	        },
	        instance_count: {
		        field: 'p_instance_count',
		        type: 'integer'
	        },
	        key_policy: {
		        field: 'p_key_policy',
		        type: 'select'
	        },
	        chart_type: {
		        field: 'p_chart_type',
		        type: 'select'
	        },
	        stacked: {
		        field: 'p_stacked',
		        type: 'boolean'
	        },
	        normalized: {
		        field: 'p_normalized',
		        type: 'boolean'
	        },
	        _other: {
		        field: 'p_other',
		        type: 'text'
	        }
        };

        this.qTypes = [{
	            name: "Text",
	            trans: "rev_text",
	            type: "string",
	            glyphicon: "font",
	            canSelect: true,
	            visible: true,
		        source: "user",
		        compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Note",
                type: "note",
                trans: "c_note",
                glyphicon: "pencil",
                canSelect: true,
                visible: true,
                source: "user",
	            compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Select One",
                type: "select1",
                trans: "ed_s1",
                image: "/images/select1_64.png",
                canSelect: true,
                visible: true,
				source: "user",
	            compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Select Multiple",
                type: "select",
                trans: "ed_s",
                image: "/images/select_64.png",
                canSelect: true,
                visible: true,
                source: "user",
	            compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Form",
                type: "begin repeat",
                trans: "c_rep_type",
                glyphicon: "repeat",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Group",
                type: "begin group",
                trans: "sr_g",
                glyphicon: "folder-open",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Image",
                type: "image",
                trans: "ed_image",
                glyphicon: "camera",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Integer",
                type: "int",
                trans: "ed_int",
                text: "#",
                canSelect: true,
                visible: true,
                source: "user",
                compatTypes: ["pdf_field"]
            },
            {
                name: "GPS Point",
                type: "geopoint",
                trans: "ed_gps",
                glyphicon: "map-marker",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Calculation",
                type: "calculate",
                trans: "ed_calc",
                calculation: true,
                image: "/images/calc_64.png",
                canSelect: true,
                visible: true,
                source: "user",
	            compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Audio",
                type: "audio",
                trans: "ed_audio",
                glyphicon: "volume-up",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Video",
                type: "video",
                trans: "ed_video",
                glyphicon: "facetime-video",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Barcode",
                type: "barcode",
                trans: "ed_bc",
                glyphicon: "barcode",
                canSelect: true,
                visible: true,
                source: "user",
                compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Date",
                type: "date",
                trans: "c_date",
                glyphicon: "calendar",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Date and Time",
                type: "dateTime",
                trans: "ed_dt",
                glyphicon: "calendar, time",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Time",
                type: "time",
                trans: "ed_t",
                glyphicon: "time",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Decimal",
                type: "decimal",
                trans: "ed_dec",
                text: "#.#",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "GPS Line",
                type: "geotrace",
                trans: "ed_gps_line",
                image: "/images/linestring_64.png",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "GPS Area",
                type: "geoshape",
                trans: "ed_gps_area",
                image: "/images/polygon_64.png",
                canSelect: true,
                visible: true,
                source: "user"
            },
            {
                name: "Acknowledge",
                type: "acknowledge",
                trans: "ed_ack",
                text: "OK",
                canSelect: true,
                visible: true,
                source: "user",
                compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Range",
                type: "range",
                trans: "ed_range",
                glyphicon: "resize-horizontal",
                text: "Range",
                canSelect: true,
                visible: true,
                source: "user",
	            compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Chart",
                type: "chart",
                trans: "c_chart",
                glyphicon: "stats",
                text: "Chart",
                canSelect: true,
                visible: true,
                source: "user",
                compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
	        {
		        name: "Parent Form",
		        type: "parent_form",
		        trans: "c_parent_form",
		        glyphicon: "open-file",
		        text: "Parent Form",
		        canSelect: true,
		        visible: true,
		        source: "user"
	        },
	        {
		        name: "Child Form",
		        type: "child_form",
		        trans: "c_child_form",
		        glyphicon: "save-file",
		        text: "Child Form",
		        canSelect: true,
		        visible: true,
		        source: "user"
	        },
            {
                name: "File",
                type: "file",
                trans: "c_file",
                glyphicon: "file",
                canSelect: true,
                visible: true,
                source: "user",
                compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
            {
                name: "Rank",
                type: "rank",
                trans: "c_rank",
                glyphicon: "sort-by-attributes",
                canSelect: true,
                visible: true,
                source: "user",
                compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
            },
	        {
		        name: "Server Calculation",
		        type: "server_calculate",
		        trans: "ed_s_calc",
		        calculation: true,
		        image: "/images/server_calc_64.png",
		        canSelect: true,
		        visible: true,
		        source: "user",
		        compatTypes: ["string", "select1", "select", "calculate", "rank", "calculate_server", "note", "pdf_field"]
	        },
            {
                name: "Compound Pdf Image",
                type: "pdf_field",
                trans: "ed_ci",
                calculation: false,
                glyphicon: "object-align-vertical",
                canSelect: true,
                visible: false,
            },
            {
                name: "Compound map",
                type: "geocompound",
                trans: "ed_cm",
                calculation: false,
                glyphicon: "pushpin",
                canSelect: true,
                visible: false,
                compatTypes: ["geotrace"]
            },
            {
                name: "Unknown Type",
                glyphicon: "record",
                canSelect: false
            }
        ];

        // Set the survey model
        this.setSurveyData = function (data) {
            this.survey = data;
            this.survey.forms_orig = $.extend(true, {}, data.forms);
            this.survey.optionLists_orig = $.extend(true, {}, data.optionLists);
        }

        // Save the settings for the survey
        this.save_settings = function () {

            var settings = JSON.stringify(this.getSettings(true));
            $('#pdfSettings').val(settings);
            var f = document.forms.namedItem("pdftemplate");
            var formData = new FormData(f);

            addHourglass();
            $.ajax({
                type: "POST",
                data: formData,
                cache: false,
                contentType: false,
                processData: false,
                url: "/surveyKPI/surveys/save_settings/" + globals.gCurrentSurvey,
                success: function (data, status) {
                    removeHourglass();
                    globals.model.savedSettings = settings;
                    globals.model.survey.pdfTemplateName = data;
                    globals.model.forceSettingsChange = false;
                    $('#save_settings, #save_keys').prop("disabled", true);

                    $('.formName').text(globals.model.survey.displayName);
                    $('#settingsModal, #keysModal').modal("hide");
                },
                error: function (xhr, textStatus, err) {
                    removeHourglass();
                    if (xhr.readyState == 0 || xhr.status == 0) {
                        return;  // Not an error
                    } else {
                        bootbox.alert("Error saving settings. " + xhr.responseText);
                    }
                }
            });

        };

        // Modify a label for a question or an option called from translate where multiple questions can be modified at once if the text is the same
        this.modLabel = function (language, changedQ, newVal, element, prop) {

            var labelMod = {
                changeType: prop,
                action: "update",
                items: []
            }

            var i,
                label = {},
                item,
                item_orig,
                qname,
                translation;


            for (i = 0; i < changedQ.length; i++) {
                translation = {
                    changeType: prop,
                    action: "update",
                    source: "editor"

                };

                // For questions
                if (typeof changedQ[i].form !== "undefined") {

                    label.formIndex = changedQ[i].form;
                    label.itemIndex = changedQ[i].question;
                    item = this.survey.forms[label.formIndex].questions[label.itemIndex];
                    item_orig = this.survey.forms_orig[label.formIndex].questions[label.itemIndex];

                    label.type = "question";
                    label.name = item.name;
                    label.prop = "label";
                    label.qId = item.id;

	                if(changedQ[i].constraint_msg) {
		                label.propType = "constraint_msg";
		                label.oldVal = item_orig.labels[language][label.propType];
	                } else if(changedQ[i].required_msg) {
		                label.propType = "required_msg";
		                label.oldVal = item_orig.labels[language][label.propType];
	                } else if(changedQ[i].guidance_hint) {
		                label.propType = "guidance_hint";
		                label.oldVal = item_orig.labels[language][label.propType];
	                } else if(changedQ[i].hint) {
		                label.propType = "hint";
		                label.oldVal = item_orig.labels[language][label.propType];
	                } else {
		                label.propType = "text";
		                label.oldVal = item_orig.labels[language][element];
	                }

                } else {
	                // For options
                    label.optionList = changedQ[i].optionList;
                    label.optionIdx = changedQ[i].option;

                    item = this.survey.optionLists[label.optionList].options[label.optionIdx];
                    item_orig = this.survey.optionLists_orig[label.optionList].options[label.optionIdx];

                    label.type = "option";
                    label.name = item.value;
	                label.propType = "text";
	                label.oldVal = item_orig.labels[language][element];
                }

                label.newVal = newVal;

                label.element = element;
                label.languageName = language;
                label.allLanguages = false;

                label.languageName = this.survey.languages[language].name;			// For logging the event
                var form = this.survey.forms[label.formIdx];

                if (item.text_id) {
                    label.key = item.text_id;
                } else {
                    // Create reference for this new Label
                    if (typeof changedQ[i].form !== "undefined") {
                        label.key = "/" + form.name + "/" + item.name + ":label";	// TODO hint
                    } else {
                        label.key = "/" + form.name + "/" + qname + "/" + item.name + ":label";
                    }
                }

                translation.property = label;

                labelMod.items.push(translation);
            }

            this.removeDuplicateTranslateChange(this.translateChanges, labelMod);
            if (labelMod.items[0].property.newVal !== labelMod.items[0].property.oldVal) {		// Add if the value has changed
                this.currentTranslateChange = this.translateChanges.push(labelMod) - 1;
                //this.doChange();				// Apply the current change
            }

            $('.m_save_survey').find('.badge').html(this.translateChanges.length);
            if (this.translateChanges.length > 0) {
                $('.m_save_survey').removeClass('disabled').prop('disabled', false);
	            $('#m_auto_translate').closest('li').addClass("disabled").prop("disabled", true);
            } else {
                $('.m_save_survey').addClass('disabled').prop('disabled', true);
	            $('#m_auto_translate').closest('li').removeClass("disabled").prop("disabled", false);
            }
        }

        // Clear the change list
        this.clearChanges = function () {
            this.translateChanges = [];
            $('.m_save_survey').find('.badge').html(this.translateChanges.length);
            if (this.translateChanges.length > 0) {
                $('.m_save_survey').removeClass('disabled').prop('disabled', false);
            } else {
                $('.m_save_survey').addClass('disabled').prop('disabled', true);
	            $('#m_auto_translate').closest('li').removeClass("disabled").prop("disabled", false);
            }
        }

        /*
         * If the label has been modified before then remove it from the change list
         */
        this.removeDuplicateTranslateChange = function () {
            // TODO
        }

        /*
         * Functions for managing settings
         */
        this.getSettings = function (save) {
            var current = this.createSettingsObject(
                $('#set_survey_name').val(),
                $('#set_instance_name').val(),
                $('#set_style').val(),
                $('#set_project_name option:selected').val(),
                $('#set_default_language option:selected').text(),
                $('#task_file').prop('checked'),
                $('#timing_data').prop('checked'),
	            $('#audit_location_data').prop('checked'),
	            $('#track_changes').prop('checked'),
	            $('#hide_on_device').prop('checked'),
	            $('#search_local_data').prop('checked'),
	            $('#data_survey').prop('checked'),
	            $('#oversight_survey').prop('checked'),
                $('#exclude_empty').prop('checked'),
                $('#compress_pdf').prop('checked'),
                $('#set_hrk').val(),
                $('#set_key_policy').val(),
	            $('#default_logo').val()
            );

            // Update the model to reflect the current values
            if (save) {
                this.survey.displayName = current.displayName;
                this.survey.instanceNameDefn = current.instanceNameDefn;
                this.survey.surveyClass = current.surveyClass;
                this.survey.p_id = current.p_id;
                this.survey.def_lang = current.def_lang;
                this.survey.task_file = current.task_file;
                this.survey.timing_data = current.timing_data;
	            this.survey.audit_location_data = current.audit_location_data;
	            this.survey.track_changes = current.track_changes;
	            this.survey.hideOnDevice = current.hideOnDevice;
	            this.survey.searchLocalData = current.searchLocalData;
	            this.survey.dataSurvey = current.dataSurvey;
	            this.survey.oversightSurvey = current.oversightSurvey;
                this.survey.exclude_empty = current.exclude_empty;
                this.survey.compress_pdf = current.compress_pdf;
                this.survey.hrk = current.hrk;
                this.survey.key_policy = current.key_policy;
	            this.survey.default_logo = current.default_logo;
            }

            return current;
        }

        this.setSettings = function () {
            this.savedSettings = JSON.stringify(
                this.createSettingsObject(
                    this.survey.displayName,
                    this.survey.instanceNameDefn,
                    this.survey.surveyClass,
                    this.survey.p_id,
                    this.survey.def_lang,
                    this.survey.task_file,
                    this.survey.timing_data,
	                this.survey.audit_location_data,
	                this.survey.track_changes,
                    this.survey.hideOnDevice,
	                this.survey.searchLocalData,
	                this.survey.dataSurvey,
	                this.survey.oversightSurvey,
                    this.survey.exclude_empty,
                    this.survey.compress_pdf,
                    this.survey.hrk,
                    this.survey.key_policy,
	                this.survey.default_logo
                ));

            this.forceSettingsChange = false;
        }

        this.createSettingsObject = function (displayName, instanceNameDefn,
                                              surveyClass,
                                              p_id,
                                              def_lang,
                                              task_file,
                                              timing_data,
                                              audit_location_data,
                                              track_changes,
                                              hideOnDevice,
                                              searchLocalData,
                                              dataSurvey,
                                              oversightSurvey,
                                              exclude_empty,
                                              compress_pdf,
                                              hrk,
                                              key_policy,
                                              default_logo) {

            var projId;
            if (typeof p_id === "string") {
                projId = parseInt(p_id);
            } else {
                projId = p_id;
            }
            return {
                displayName: displayName,
                instanceNameDefn: instanceNameDefn,
                surveyClass: surveyClass,
                p_id: projId,
                def_lang: def_lang,
                task_file: task_file,
                timing_data: timing_data,
	            audit_location_data: audit_location_data,
	            track_changes: track_changes,
                hideOnDevice: hideOnDevice,
                searchLocalData: searchLocalData,
	            dataSurvey: dataSurvey,
	            oversightSurvey: oversightSurvey,
                exclude_empty: exclude_empty,
                compress_pdf: compress_pdf,
                hrk: hrk,
                key_policy: key_policy,
	            default_logo: default_logo
            }
        }

        this.settingsChange = function () {
            var current = globals.model.getSettings(false);

            if (JSON.stringify(current) !== globals.model.savedSettings || globals.model.forceSettingsChange) {
                $('#save_settings, #save_keys').prop("disabled", false);
            } else {
                $('#save_settings, #save_keys').prop("disabled", true);
            }
        }

        /*
         * If the user select a pdfTemplate that has been modified but its name has not changed then
         * the settings values will not be different but we want to enable an upload of the new template.
         * Hence set the forceSettingChange flag.
         */
        this.settingsAddPdfClicked = function () {
            globals.model.forceSettingsChange = true;
            $('#save_settings').prop("disabled", false);
        }
    }
});

;(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define('moment',factory) :
			global.moment = factory()
}(this, (function () { 'use strict';

	var hookCallback;

	function hooks () {
		return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
		hookCallback = callback;
	}

	function isArray(input) {
		return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}

	function isObject(input) {
		// IE8 will treat undefined and null as object if it wasn't for
		// input != null
		return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}

	function isObjectEmpty(obj) {
		if (Object.getOwnPropertyNames) {
			return (Object.getOwnPropertyNames(obj).length === 0);
		} else {
			var k;
			for (k in obj) {
				if (obj.hasOwnProperty(k)) {
					return false;
				}
			}
			return true;
		}
	}

	function isUndefined(input) {
		return input === void 0;
	}

	function isNumber(input) {
		return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}

	function isDate(input) {
		return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}

	function map(arr, fn) {
		var res = [], i;
		for (i = 0; i < arr.length; ++i) {
			res.push(fn(arr[i], i));
		}
		return res;
	}

	function hasOwnProp(a, b) {
		return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
		for (var i in b) {
			if (hasOwnProp(b, i)) {
				a[i] = b[i];
			}
		}

		if (hasOwnProp(b, 'toString')) {
			a.toString = b.toString;
		}

		if (hasOwnProp(b, 'valueOf')) {
			a.valueOf = b.valueOf;
		}

		return a;
	}

	function createUTC (input, format, locale, strict) {
		return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
		// We need to deep clone this object.
		return {
			empty           : false,
			unusedTokens    : [],
			unusedInput     : [],
			overflow        : -2,
			charsLeftOver   : 0,
			nullInput       : false,
			invalidMonth    : null,
			invalidFormat   : false,
			userInvalidated : false,
			iso             : false,
			parsedDateParts : [],
			meridiem        : null,
			rfc2822         : false,
			weekdayMismatch : false
		};
	}

	function getParsingFlags(m) {
		if (m._pf == null) {
			m._pf = defaultParsingFlags();
		}
		return m._pf;
	}

	var some;
	if (Array.prototype.some) {
		some = Array.prototype.some;
	} else {
		some = function (fun) {
			var t = Object(this);
			var len = t.length >>> 0;

			for (var i = 0; i < len; i++) {
				if (i in t && fun.call(this, t[i], i, t)) {
					return true;
				}
			}

			return false;
		};
	}

	function isValid(m) {
		if (m._isValid == null) {
			var flags = getParsingFlags(m);
			var parsedParts = some.call(flags.parsedDateParts, function (i) {
				return i != null;
			});
			var isNowValid = !isNaN(m._d.getTime()) &&
				flags.overflow < 0 &&
				!flags.empty &&
				!flags.invalidMonth &&
				!flags.invalidWeekday &&
				!flags.weekdayMismatch &&
				!flags.nullInput &&
				!flags.invalidFormat &&
				!flags.userInvalidated &&
				(!flags.meridiem || (flags.meridiem && parsedParts));

			if (m._strict) {
				isNowValid = isNowValid &&
					flags.charsLeftOver === 0 &&
					flags.unusedTokens.length === 0 &&
					flags.bigHour === undefined;
			}

			if (Object.isFrozen == null || !Object.isFrozen(m)) {
				m._isValid = isNowValid;
			}
			else {
				return isNowValid;
			}
		}
		return m._isValid;
	}

	function createInvalid (flags) {
		var m = createUTC(NaN);
		if (flags != null) {
			extend(getParsingFlags(m), flags);
		}
		else {
			getParsingFlags(m).userInvalidated = true;
		}

		return m;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];

	function copyConfig(to, from) {
		var i, prop, val;

		if (!isUndefined(from._isAMomentObject)) {
			to._isAMomentObject = from._isAMomentObject;
		}
		if (!isUndefined(from._i)) {
			to._i = from._i;
		}
		if (!isUndefined(from._f)) {
			to._f = from._f;
		}
		if (!isUndefined(from._l)) {
			to._l = from._l;
		}
		if (!isUndefined(from._strict)) {
			to._strict = from._strict;
		}
		if (!isUndefined(from._tzm)) {
			to._tzm = from._tzm;
		}
		if (!isUndefined(from._isUTC)) {
			to._isUTC = from._isUTC;
		}
		if (!isUndefined(from._offset)) {
			to._offset = from._offset;
		}
		if (!isUndefined(from._pf)) {
			to._pf = getParsingFlags(from);
		}
		if (!isUndefined(from._locale)) {
			to._locale = from._locale;
		}

		if (momentProperties.length > 0) {
			for (i = 0; i < momentProperties.length; i++) {
				prop = momentProperties[i];
				val = from[prop];
				if (!isUndefined(val)) {
					to[prop] = val;
				}
			}
		}

		return to;
	}

	var updateInProgress = false;

	// Moment prototype object
	function Moment(config) {
		copyConfig(this, config);
		this._d = new Date(config._d != null ? config._d.getTime() : NaN);
		if (!this.isValid()) {
			this._d = new Date(NaN);
		}
		// Prevent infinite loop in case updateOffset creates new moment
		// objects.
		if (updateInProgress === false) {
			updateInProgress = true;
			hooks.updateOffset(this);
			updateInProgress = false;
		}
	}

	function isMoment (obj) {
		return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}

	function absFloor (number) {
		if (number < 0) {
			// -0 -> 0
			return Math.ceil(number) || 0;
		} else {
			return Math.floor(number);
		}
	}

	function toInt(argumentForCoercion) {
		var coercedNumber = +argumentForCoercion,
			value = 0;

		if (coercedNumber !== 0 && isFinite(coercedNumber)) {
			value = absFloor(coercedNumber);
		}

		return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
		var len = Math.min(array1.length, array2.length),
			lengthDiff = Math.abs(array1.length - array2.length),
			diffs = 0,
			i;
		for (i = 0; i < len; i++) {
			if ((dontConvert && array1[i] !== array2[i]) ||
				(!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
				diffs++;
			}
		}
		return diffs + lengthDiff;
	}

	function warn(msg) {
		if (hooks.suppressDeprecationWarnings === false &&
			(typeof console !==  'undefined') && console.warn) {
			console.warn('Deprecation warning: ' + msg);
		}
	}

	function deprecate(msg, fn) {
		var firstTime = true;

		return extend(function () {
			if (hooks.deprecationHandler != null) {
				hooks.deprecationHandler(null, msg);
			}
			if (firstTime) {
				var args = [];
				var arg;
				for (var i = 0; i < arguments.length; i++) {
					arg = '';
					if (typeof arguments[i] === 'object') {
						arg += '\n[' + i + '] ';
						for (var key in arguments[0]) {
							arg += key + ': ' + arguments[0][key] + ', ';
						}
						arg = arg.slice(0, -2); // Remove trailing comma and space
					} else {
						arg = arguments[i];
					}
					args.push(arg);
				}
				warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
				firstTime = false;
			}
			return fn.apply(this, arguments);
		}, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
		if (hooks.deprecationHandler != null) {
			hooks.deprecationHandler(name, msg);
		}
		if (!deprecations[name]) {
			warn(msg);
			deprecations[name] = true;
		}
	}

	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;

	function isFunction(input) {
		return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}

	function set (config) {
		var prop, i;
		for (i in config) {
			prop = config[i];
			if (isFunction(prop)) {
				this[i] = prop;
			} else {
				this['_' + i] = prop;
			}
		}
		this._config = config;
		// Lenient ordinal parsing accepts just a number in addition to
		// number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
		// TODO: Remove "ordinalParse" fallback in next major release.
		this._dayOfMonthOrdinalParseLenient = new RegExp(
			(this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
			'|' + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
		var res = extend({}, parentConfig), prop;
		for (prop in childConfig) {
			if (hasOwnProp(childConfig, prop)) {
				if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
					res[prop] = {};
					extend(res[prop], parentConfig[prop]);
					extend(res[prop], childConfig[prop]);
				} else if (childConfig[prop] != null) {
					res[prop] = childConfig[prop];
				} else {
					delete res[prop];
				}
			}
		}
		for (prop in parentConfig) {
			if (hasOwnProp(parentConfig, prop) &&
				!hasOwnProp(childConfig, prop) &&
				isObject(parentConfig[prop])) {
				// make sure changes to properties don't modify parent config
				res[prop] = extend({}, res[prop]);
			}
		}
		return res;
	}

	function Locale(config) {
		if (config != null) {
			this.set(config);
		}
	}

	var keys;

	if (Object.keys) {
		keys = Object.keys;
	} else {
		keys = function (obj) {
			var i, res = [];
			for (i in obj) {
				if (hasOwnProp(obj, i)) {
					res.push(i);
				}
			}
			return res;
		};
	}

	var defaultCalendar = {
		sameDay : '[Today at] LT',
		nextDay : '[Tomorrow at] LT',
		nextWeek : 'dddd [at] LT',
		lastDay : '[Yesterday at] LT',
		lastWeek : '[Last] dddd [at] LT',
		sameElse : 'L'
	};

	function calendar (key, mom, now) {
		var output = this._calendar[key] || this._calendar['sameElse'];
		return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
		LTS  : 'h:mm:ss A',
		LT   : 'h:mm A',
		L    : 'MM/DD/YYYY',
		LL   : 'MMMM D, YYYY',
		LLL  : 'MMMM D, YYYY h:mm A',
		LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};

	function longDateFormat (key) {
		var format = this._longDateFormat[key],
			formatUpper = this._longDateFormat[key.toUpperCase()];

		if (format || !formatUpper) {
			return format;
		}

		this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
			return val.slice(1);
		});

		return this._longDateFormat[key];
	}

	var defaultInvalidDate = 'Invalid date';

	function invalidDate () {
		return this._invalidDate;
	}

	var defaultOrdinal = '%d';
	var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	function ordinal (number) {
		return this._ordinal.replace('%d', number);
	}

	var defaultRelativeTime = {
		future : 'in %s',
		past   : '%s ago',
		s  : 'a few seconds',
		ss : '%d seconds',
		m  : 'a minute',
		mm : '%d minutes',
		h  : 'an hour',
		hh : '%d hours',
		d  : 'a day',
		dd : '%d days',
		M  : 'a month',
		MM : '%d months',
		y  : 'a year',
		yy : '%d years'
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
		var output = this._relativeTime[string];
		return (isFunction(output)) ?
			output(number, withoutSuffix, string, isFuture) :
			output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
		var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases = {};

	function addUnitAlias (unit, shorthand) {
		var lowerCase = unit.toLowerCase();
		aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
		return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
		var normalizedInput = {},
			normalizedProp,
			prop;

		for (prop in inputObject) {
			if (hasOwnProp(inputObject, prop)) {
				normalizedProp = normalizeUnits(prop);
				if (normalizedProp) {
					normalizedInput[normalizedProp] = inputObject[prop];
				}
			}
		}

		return normalizedInput;
	}

	var priorities = {};

	function addUnitPriority(unit, priority) {
		priorities[unit] = priority;
	}

	function getPrioritizedUnits(unitsObj) {
		var units = [];
		for (var u in unitsObj) {
			units.push({unit: u, priority: priorities[u]});
		}
		units.sort(function (a, b) {
			return a.priority - b.priority;
		});
		return units;
	}

	function zeroFill(number, targetLength, forceSign) {
		var absNumber = '' + Math.abs(number),
			zerosToFill = targetLength - absNumber.length,
			sign = number >= 0;
		return (sign ? (forceSign ? '+' : '') : '-') +
			Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
		var func = callback;
		if (typeof callback === 'string') {
			func = function () {
				return this[callback]();
			};
		}
		if (token) {
			formatTokenFunctions[token] = func;
		}
		if (padded) {
			formatTokenFunctions[padded[0]] = function () {
				return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
			};
		}
		if (ordinal) {
			formatTokenFunctions[ordinal] = function () {
				return this.localeData().ordinal(func.apply(this, arguments), token);
			};
		}
	}

	function removeFormattingTokens(input) {
		if (input.match(/\[[\s\S]/)) {
			return input.replace(/^\[|\]$/g, '');
		}
		return input.replace(/\\/g, '');
	}

	function makeFormatFunction(format) {
		var array = format.match(formattingTokens), i, length;

		for (i = 0, length = array.length; i < length; i++) {
			if (formatTokenFunctions[array[i]]) {
				array[i] = formatTokenFunctions[array[i]];
			} else {
				array[i] = removeFormattingTokens(array[i]);
			}
		}

		return function (mom) {
			var output = '', i;
			for (i = 0; i < length; i++) {
				output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
			}
			return output;
		};
	}

	// format date using native date object
	function formatMoment(m, format) {
		if (!m.isValid()) {
			return m.localeData().invalidDate();
		}

		format = expandFormat(format, m.localeData());
		formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

		return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
		var i = 5;

		function replaceLongDateFormatTokens(input) {
			return locale.longDateFormat(input) || input;
		}

		localFormattingTokens.lastIndex = 0;
		while (i >= 0 && localFormattingTokens.test(format)) {
			format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
			localFormattingTokens.lastIndex = 0;
			i -= 1;
		}

		return format;
	}

	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

	var regexes = {};

	function addRegexToken (token, regex, strictRegex) {
		regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
			return (isStrict && strictRegex) ? strictRegex : regex;
		};
	}

	function getParseRegexForToken (token, config) {
		if (!hasOwnProp(regexes, token)) {
			return new RegExp(unescapeFormat(token));
		}

		return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
		return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
			return p1 || p2 || p3 || p4;
		}));
	}

	function regexEscape(s) {
		return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}

	var tokens = {};

	function addParseToken (token, callback) {
		var i, func = callback;
		if (typeof token === 'string') {
			token = [token];
		}
		if (isNumber(callback)) {
			func = function (input, array) {
				array[callback] = toInt(input);
			};
		}
		for (i = 0; i < token.length; i++) {
			tokens[token[i]] = func;
		}
	}

	function addWeekParseToken (token, callback) {
		addParseToken(token, function (input, array, config, token) {
			config._w = config._w || {};
			callback(input, config._w, config, token);
		});
	}

	function addTimeToArrayFromToken(token, input, config) {
		if (input != null && hasOwnProp(tokens, token)) {
			tokens[token](input, config._a, config, token);
		}
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	// FORMATTING

	addFormatToken('Y', 0, 0, function () {
		var y = this.year();
		return y <= 9999 ? '' + y : '+' + y;
	});

	addFormatToken(0, ['YY', 2], 0, function () {
		return this.year() % 100;
	});

	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	// ALIASES

	addUnitAlias('year', 'y');

	// PRIORITIES

	addUnitPriority('year', 1);

	// PARSING

	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);

	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
		array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
		array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
		array[YEAR] = parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
		return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
		return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear = function (input) {
		return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear = makeGetSet('FullYear', true);

	function getIsLeapYear () {
		return isLeapYear(this.year());
	}

	function makeGetSet (unit, keepTime) {
		return function (value) {
			if (value != null) {
				set$1(this, unit, value);
				hooks.updateOffset(this, keepTime);
				return this;
			} else {
				return get(this, unit);
			}
		};
	}

	function get (mom, unit) {
		return mom.isValid() ?
			mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
		if (mom.isValid() && !isNaN(value)) {
			if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
				mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
			}
			else {
				mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
			}
		}
	}

	// MOMENTS

	function stringGet (units) {
		units = normalizeUnits(units);
		if (isFunction(this[units])) {
			return this[units]();
		}
		return this;
	}


	function stringSet (units, value) {
		if (typeof units === 'object') {
			units = normalizeObjectUnits(units);
			var prioritized = getPrioritizedUnits(units);
			for (var i = 0; i < prioritized.length; i++) {
				this[prioritized[i].unit](units[prioritized[i].unit]);
			}
		} else {
			units = normalizeUnits(units);
			if (isFunction(this[units])) {
				return this[units](value);
			}
		}
		return this;
	}

	function mod(n, x) {
		return ((n % x) + x) % x;
	}

	var indexOf;

	if (Array.prototype.indexOf) {
		indexOf = Array.prototype.indexOf;
	} else {
		indexOf = function (o) {
			// I know
			var i;
			for (i = 0; i < this.length; ++i) {
				if (this[i] === o) {
					return i;
				}
			}
			return -1;
		};
	}

	function daysInMonth(year, month) {
		if (isNaN(year) || isNaN(month)) {
			return NaN;
		}
		var modMonth = mod(month, 12);
		year += (month - modMonth) / 12;
		return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
	}

	// FORMATTING

	addFormatToken('M', ['MM', 2], 'Mo', function () {
		return this.month() + 1;
	});

	addFormatToken('MMM', 0, 0, function (format) {
		return this.localeData().monthsShort(this, format);
	});

	addFormatToken('MMMM', 0, 0, function (format) {
		return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias('month', 'M');

	// PRIORITY

	addUnitPriority('month', 8);

	// PARSING

	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
		return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
		return locale.monthsRegex(isStrict);
	});

	addParseToken(['M', 'MM'], function (input, array) {
		array[MONTH] = toInt(input) - 1;
	});

	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
		var month = config._locale.monthsParse(input, token, config._strict);
		// if we didn't find a month name, mark the date as invalid.
		if (month != null) {
			array[MONTH] = month;
		} else {
			getParsingFlags(config).invalidMonth = input;
		}
	});

	// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
		if (!m) {
			return isArray(this._months) ? this._months :
				this._months['standalone'];
		}
		return isArray(this._months) ? this._months[m.month()] :
			this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}

	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
		if (!m) {
			return isArray(this._monthsShort) ? this._monthsShort :
				this._monthsShort['standalone'];
		}
		return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
			this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
		var i, ii, mom, llc = monthName.toLocaleLowerCase();
		if (!this._monthsParse) {
			// this is not used
			this._monthsParse = [];
			this._longMonthsParse = [];
			this._shortMonthsParse = [];
			for (i = 0; i < 12; ++i) {
				mom = createUTC([2000, i]);
				this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
				this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
			}
		}

		if (strict) {
			if (format === 'MMM') {
				ii = indexOf.call(this._shortMonthsParse, llc);
				return ii !== -1 ? ii : null;
			} else {
				ii = indexOf.call(this._longMonthsParse, llc);
				return ii !== -1 ? ii : null;
			}
		} else {
			if (format === 'MMM') {
				ii = indexOf.call(this._shortMonthsParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._longMonthsParse, llc);
				return ii !== -1 ? ii : null;
			} else {
				ii = indexOf.call(this._longMonthsParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._shortMonthsParse, llc);
				return ii !== -1 ? ii : null;
			}
		}
	}

	function localeMonthsParse (monthName, format, strict) {
		var i, mom, regex;

		if (this._monthsParseExact) {
			return handleStrictParse.call(this, monthName, format, strict);
		}

		if (!this._monthsParse) {
			this._monthsParse = [];
			this._longMonthsParse = [];
			this._shortMonthsParse = [];
		}

		// TODO: add sorting
		// Sorting makes sure if one month (or abbr) is a prefix of another
		// see sorting in computeMonthsParse
		for (i = 0; i < 12; i++) {
			// make the regex if we don't have it already
			mom = createUTC([2000, i]);
			if (strict && !this._longMonthsParse[i]) {
				this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
				this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
			}
			if (!strict && !this._monthsParse[i]) {
				regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
				this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
			}
			// test the regex
			if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
				return i;
			} else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
				return i;
			} else if (!strict && this._monthsParse[i].test(monthName)) {
				return i;
			}
		}
	}

	// MOMENTS

	function setMonth (mom, value) {
		var dayOfMonth;

		if (!mom.isValid()) {
			// No op
			return mom;
		}

		if (typeof value === 'string') {
			if (/^\d+$/.test(value)) {
				value = toInt(value);
			} else {
				value = mom.localeData().monthsParse(value);
				// TODO: Another silent failure?
				if (!isNumber(value)) {
					return mom;
				}
			}
		}

		dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
		mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
		return mom;
	}

	function getSetMonth (value) {
		if (value != null) {
			setMonth(this, value);
			hooks.updateOffset(this, true);
			return this;
		} else {
			return get(this, 'Month');
		}
	}

	function getDaysInMonth () {
		return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
		if (this._monthsParseExact) {
			if (!hasOwnProp(this, '_monthsRegex')) {
				computeMonthsParse.call(this);
			}
			if (isStrict) {
				return this._monthsShortStrictRegex;
			} else {
				return this._monthsShortRegex;
			}
		} else {
			if (!hasOwnProp(this, '_monthsShortRegex')) {
				this._monthsShortRegex = defaultMonthsShortRegex;
			}
			return this._monthsShortStrictRegex && isStrict ?
				this._monthsShortStrictRegex : this._monthsShortRegex;
		}
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
		if (this._monthsParseExact) {
			if (!hasOwnProp(this, '_monthsRegex')) {
				computeMonthsParse.call(this);
			}
			if (isStrict) {
				return this._monthsStrictRegex;
			} else {
				return this._monthsRegex;
			}
		} else {
			if (!hasOwnProp(this, '_monthsRegex')) {
				this._monthsRegex = defaultMonthsRegex;
			}
			return this._monthsStrictRegex && isStrict ?
				this._monthsStrictRegex : this._monthsRegex;
		}
	}

	function computeMonthsParse () {
		function cmpLenRev(a, b) {
			return b.length - a.length;
		}

		var shortPieces = [], longPieces = [], mixedPieces = [],
			i, mom;
		for (i = 0; i < 12; i++) {
			// make the regex if we don't have it already
			mom = createUTC([2000, i]);
			shortPieces.push(this.monthsShort(mom, ''));
			longPieces.push(this.months(mom, ''));
			mixedPieces.push(this.months(mom, ''));
			mixedPieces.push(this.monthsShort(mom, ''));
		}
		// Sorting makes sure if one month (or abbr) is a prefix of another it
		// will match the longer piece.
		shortPieces.sort(cmpLenRev);
		longPieces.sort(cmpLenRev);
		mixedPieces.sort(cmpLenRev);
		for (i = 0; i < 12; i++) {
			shortPieces[i] = regexEscape(shortPieces[i]);
			longPieces[i] = regexEscape(longPieces[i]);
		}
		for (i = 0; i < 24; i++) {
			mixedPieces[i] = regexEscape(mixedPieces[i]);
		}

		this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		this._monthsShortRegex = this._monthsRegex;
		this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
		this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}

	function createDate (y, m, d, h, M, s, ms) {
		// can't just apply() to create a date:
		// https://stackoverflow.com/q/181348
		var date;
		// the date constructor remaps years 0-99 to 1900-1999
		if (y < 100 && y >= 0) {
			// preserve leap years using a full 400 year cycle, then reset
			date = new Date(y + 400, m, d, h, M, s, ms);
			if (isFinite(date.getFullYear())) {
				date.setFullYear(y);
			}
		} else {
			date = new Date(y, m, d, h, M, s, ms);
		}

		return date;
	}

	function createUTCDate (y) {
		var date;
		// the Date.UTC function remaps years 0-99 to 1900-1999
		if (y < 100 && y >= 0) {
			var args = Array.prototype.slice.call(arguments);
			// preserve leap years using a full 400 year cycle, then reset
			args[0] = y + 400;
			date = new Date(Date.UTC.apply(null, args));
			if (isFinite(date.getUTCFullYear())) {
				date.setUTCFullYear(y);
			}
		} else {
			date = new Date(Date.UTC.apply(null, arguments));
		}

		return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
		var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
			fwd = 7 + dow - doy,
			// first-week day local weekday -- which local weekday is fwd
			fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

		return -fwdlw + fwd - 1;
	}

	// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
		var localWeekday = (7 + weekday - dow) % 7,
			weekOffset = firstWeekOffset(year, dow, doy),
			dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
			resYear, resDayOfYear;

		if (dayOfYear <= 0) {
			resYear = year - 1;
			resDayOfYear = daysInYear(resYear) + dayOfYear;
		} else if (dayOfYear > daysInYear(year)) {
			resYear = year + 1;
			resDayOfYear = dayOfYear - daysInYear(year);
		} else {
			resYear = year;
			resDayOfYear = dayOfYear;
		}

		return {
			year: resYear,
			dayOfYear: resDayOfYear
		};
	}

	function weekOfYear(mom, dow, doy) {
		var weekOffset = firstWeekOffset(mom.year(), dow, doy),
			week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
			resWeek, resYear;

		if (week < 1) {
			resYear = mom.year() - 1;
			resWeek = week + weeksInYear(resYear, dow, doy);
		} else if (week > weeksInYear(mom.year(), dow, doy)) {
			resWeek = week - weeksInYear(mom.year(), dow, doy);
			resYear = mom.year() + 1;
		} else {
			resYear = mom.year();
			resWeek = week;
		}

		return {
			week: resWeek,
			year: resYear
		};
	}

	function weeksInYear(year, dow, doy) {
		var weekOffset = firstWeekOffset(year, dow, doy),
			weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
		return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	// ALIASES

	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');

	// PRIORITIES

	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);

	// PARSING

	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);

	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
		week[token.substr(0, 1)] = toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
		return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
		dow : 0, // Sunday is the first day of the week.
		doy : 6  // The week that contains Jan 6th is the first week of the year.
	};

	function localeFirstDayOfWeek () {
		return this._week.dow;
	}

	function localeFirstDayOfYear () {
		return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
		var week = this.localeData().week(this);
		return input == null ? week : this.add((input - week) * 7, 'd');
	}

	function getSetISOWeek (input) {
		var week = weekOfYear(this, 1, 4).week;
		return input == null ? week : this.add((input - week) * 7, 'd');
	}

	// FORMATTING

	addFormatToken('d', 0, 'do', 'day');

	addFormatToken('dd', 0, 0, function (format) {
		return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken('ddd', 0, 0, function (format) {
		return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken('dddd', 0, 0, function (format) {
		return this.localeData().weekdays(this, format);
	});

	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');

	// ALIASES

	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');

	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);

	// PARSING

	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
		return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
		return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
		return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
		var weekday = config._locale.weekdaysParse(input, token, config._strict);
		// if we didn't get a weekday name, mark the date as invalid
		if (weekday != null) {
			week.d = weekday;
		} else {
			getParsingFlags(config).invalidWeekday = input;
		}
	});

	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
		week[token] = toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
		if (typeof input !== 'string') {
			return input;
		}

		if (!isNaN(input)) {
			return parseInt(input, 10);
		}

		input = locale.weekdaysParse(input);
		if (typeof input === 'number') {
			return input;
		}

		return null;
	}

	function parseIsoWeekday(input, locale) {
		if (typeof input === 'string') {
			return locale.weekdaysParse(input) % 7 || 7;
		}
		return isNaN(input) ? null : input;
	}

	// LOCALES
	function shiftWeekdays (ws, n) {
		return ws.slice(n, 7).concat(ws.slice(0, n));
	}

	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
		var weekdays = isArray(this._weekdays) ? this._weekdays :
			this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
		return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
			: (m) ? weekdays[m.day()] : weekdays;
	}

	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
		return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
			: (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
		return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
			: (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
		var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
		if (!this._weekdaysParse) {
			this._weekdaysParse = [];
			this._shortWeekdaysParse = [];
			this._minWeekdaysParse = [];

			for (i = 0; i < 7; ++i) {
				mom = createUTC([2000, 1]).day(i);
				this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
				this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
				this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
			}
		}

		if (strict) {
			if (format === 'dddd') {
				ii = indexOf.call(this._weekdaysParse, llc);
				return ii !== -1 ? ii : null;
			} else if (format === 'ddd') {
				ii = indexOf.call(this._shortWeekdaysParse, llc);
				return ii !== -1 ? ii : null;
			} else {
				ii = indexOf.call(this._minWeekdaysParse, llc);
				return ii !== -1 ? ii : null;
			}
		} else {
			if (format === 'dddd') {
				ii = indexOf.call(this._weekdaysParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._shortWeekdaysParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._minWeekdaysParse, llc);
				return ii !== -1 ? ii : null;
			} else if (format === 'ddd') {
				ii = indexOf.call(this._shortWeekdaysParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._weekdaysParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._minWeekdaysParse, llc);
				return ii !== -1 ? ii : null;
			} else {
				ii = indexOf.call(this._minWeekdaysParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._weekdaysParse, llc);
				if (ii !== -1) {
					return ii;
				}
				ii = indexOf.call(this._shortWeekdaysParse, llc);
				return ii !== -1 ? ii : null;
			}
		}
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
		var i, mom, regex;

		if (this._weekdaysParseExact) {
			return handleStrictParse$1.call(this, weekdayName, format, strict);
		}

		if (!this._weekdaysParse) {
			this._weekdaysParse = [];
			this._minWeekdaysParse = [];
			this._shortWeekdaysParse = [];
			this._fullWeekdaysParse = [];
		}

		for (i = 0; i < 7; i++) {
			// make the regex if we don't have it already

			mom = createUTC([2000, 1]).day(i);
			if (strict && !this._fullWeekdaysParse[i]) {
				this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
				this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
				this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
			}
			if (!this._weekdaysParse[i]) {
				regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
				this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
			}
			// test the regex
			if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
				return i;
			} else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
				return i;
			} else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
				return i;
			} else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
				return i;
			}
		}
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
		var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		if (input != null) {
			input = parseWeekday(input, this.localeData());
			return this.add(input - day, 'd');
		} else {
			return day;
		}
	}

	function getSetLocaleDayOfWeek (input) {
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
		var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
		return input == null ? weekday : this.add(input - weekday, 'd');
	}

	function getSetISODayOfWeek (input) {
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}

		// behaves the same as moment#day except
		// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
		// as a setter, sunday should belong to the previous week.

		if (input != null) {
			var weekday = parseIsoWeekday(input, this.localeData());
			return this.day(this.day() % 7 ? weekday : weekday - 7);
		} else {
			return this.day() || 7;
		}
	}

	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
		if (this._weekdaysParseExact) {
			if (!hasOwnProp(this, '_weekdaysRegex')) {
				computeWeekdaysParse.call(this);
			}
			if (isStrict) {
				return this._weekdaysStrictRegex;
			} else {
				return this._weekdaysRegex;
			}
		} else {
			if (!hasOwnProp(this, '_weekdaysRegex')) {
				this._weekdaysRegex = defaultWeekdaysRegex;
			}
			return this._weekdaysStrictRegex && isStrict ?
				this._weekdaysStrictRegex : this._weekdaysRegex;
		}
	}

	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
		if (this._weekdaysParseExact) {
			if (!hasOwnProp(this, '_weekdaysRegex')) {
				computeWeekdaysParse.call(this);
			}
			if (isStrict) {
				return this._weekdaysShortStrictRegex;
			} else {
				return this._weekdaysShortRegex;
			}
		} else {
			if (!hasOwnProp(this, '_weekdaysShortRegex')) {
				this._weekdaysShortRegex = defaultWeekdaysShortRegex;
			}
			return this._weekdaysShortStrictRegex && isStrict ?
				this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
		}
	}

	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
		if (this._weekdaysParseExact) {
			if (!hasOwnProp(this, '_weekdaysRegex')) {
				computeWeekdaysParse.call(this);
			}
			if (isStrict) {
				return this._weekdaysMinStrictRegex;
			} else {
				return this._weekdaysMinRegex;
			}
		} else {
			if (!hasOwnProp(this, '_weekdaysMinRegex')) {
				this._weekdaysMinRegex = defaultWeekdaysMinRegex;
			}
			return this._weekdaysMinStrictRegex && isStrict ?
				this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
		}
	}


	function computeWeekdaysParse () {
		function cmpLenRev(a, b) {
			return b.length - a.length;
		}

		var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
			i, mom, minp, shortp, longp;
		for (i = 0; i < 7; i++) {
			// make the regex if we don't have it already
			mom = createUTC([2000, 1]).day(i);
			minp = this.weekdaysMin(mom, '');
			shortp = this.weekdaysShort(mom, '');
			longp = this.weekdays(mom, '');
			minPieces.push(minp);
			shortPieces.push(shortp);
			longPieces.push(longp);
			mixedPieces.push(minp);
			mixedPieces.push(shortp);
			mixedPieces.push(longp);
		}
		// Sorting makes sure if one weekday (or abbr) is a prefix of another it
		// will match the longer piece.
		minPieces.sort(cmpLenRev);
		shortPieces.sort(cmpLenRev);
		longPieces.sort(cmpLenRev);
		mixedPieces.sort(cmpLenRev);
		for (i = 0; i < 7; i++) {
			shortPieces[i] = regexEscape(shortPieces[i]);
			longPieces[i] = regexEscape(longPieces[i]);
			mixedPieces[i] = regexEscape(mixedPieces[i]);
		}

		this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		this._weekdaysShortRegex = this._weekdaysRegex;
		this._weekdaysMinRegex = this._weekdaysRegex;

		this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
		this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
		this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	function hFormat() {
		return this.hours() % 12 || 12;
	}

	function kFormat() {
		return this.hours() || 24;
	}

	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);

	addFormatToken('hmm', 0, 0, function () {
		return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken('hmmss', 0, 0, function () {
		return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
			zeroFill(this.seconds(), 2);
	});

	addFormatToken('Hmm', 0, 0, function () {
		return '' + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken('Hmmss', 0, 0, function () {
		return '' + this.hours() + zeroFill(this.minutes(), 2) +
			zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
		addFormatToken(token, 0, 0, function () {
			return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
		});
	}

	meridiem('a', true);
	meridiem('A', false);

	// ALIASES

	addUnitAlias('hour', 'h');

	// PRIORITY
	addUnitPriority('hour', 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
		return locale._meridiemParse;
	}

	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('k',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);
	addRegexToken('kk', match1to2, match2);

	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);

	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['k', 'kk'], function (input, array, config) {
		var kInput = toInt(input);
		array[HOUR] = kInput === 24 ? 0 : kInput;
	});
	addParseToken(['a', 'A'], function (input, array, config) {
		config._isPm = config._locale.isPM(input);
		config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
		array[HOUR] = toInt(input);
		getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
		var pos = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos));
		array[MINUTE] = toInt(input.substr(pos));
		getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
		var pos1 = input.length - 4;
		var pos2 = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos1));
		array[MINUTE] = toInt(input.substr(pos1, 2));
		array[SECOND] = toInt(input.substr(pos2));
		getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
		var pos = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos));
		array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
		var pos1 = input.length - 4;
		var pos2 = input.length - 2;
		array[HOUR] = toInt(input.substr(0, pos1));
		array[MINUTE] = toInt(input.substr(pos1, 2));
		array[SECOND] = toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
		// IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
		// Using charAt should be more compatible.
		return ((input + '').toLowerCase().charAt(0) === 'p');
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
		if (hours > 11) {
			return isLower ? 'pm' : 'PM';
		} else {
			return isLower ? 'am' : 'AM';
		}
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour they want. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);

	var baseConfig = {
		calendar: defaultCalendar,
		longDateFormat: defaultLongDateFormat,
		invalidDate: defaultInvalidDate,
		ordinal: defaultOrdinal,
		dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
		relativeTime: defaultRelativeTime,

		months: defaultLocaleMonths,
		monthsShort: defaultLocaleMonthsShort,

		week: defaultLocaleWeek,

		weekdays: defaultLocaleWeekdays,
		weekdaysMin: defaultLocaleWeekdaysMin,
		weekdaysShort: defaultLocaleWeekdaysShort,

		meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;

	function normalizeLocale(key) {
		return key ? key.toLowerCase().replace('_', '-') : key;
	}

	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
		var i = 0, j, next, locale, split;

		while (i < names.length) {
			split = normalizeLocale(names[i]).split('-');
			j = split.length;
			next = normalizeLocale(names[i + 1]);
			next = next ? next.split('-') : null;
			while (j > 0) {
				locale = loadLocale(split.slice(0, j).join('-'));
				if (locale) {
					return locale;
				}
				if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
					//the next array item is better than a shallower substring of this one
					break;
				}
				j--;
			}
			i++;
		}
		return globalLocale;
	}

	function loadLocale(name) {
		var oldLocale = null;
		// TODO: Find a better way to register and load all the locales in Node
		if (!locales[name] && (typeof module !== 'undefined') &&
			module && module.exports) {
			try {
				oldLocale = globalLocale._abbr;
				var aliasedRequire = require;
				aliasedRequire('./locale/' + name);
				getSetGlobalLocale(oldLocale);
			} catch (e) {}
		}
		return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
		var data;
		if (key) {
			if (isUndefined(values)) {
				data = getLocale(key);
			}
			else {
				data = defineLocale(key, values);
			}

			if (data) {
				// moment.duration._locale = moment._locale = data;
				globalLocale = data;
			}
			else {
				if ((typeof console !==  'undefined') && console.warn) {
					//warn user if arguments are passed but the locale could not be set
					console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
				}
			}
		}

		return globalLocale._abbr;
	}

	function defineLocale (name, config) {
		if (config !== null) {
			var locale, parentConfig = baseConfig;
			config.abbr = name;
			if (locales[name] != null) {
				deprecateSimple('defineLocaleOverride',
					'use moment.updateLocale(localeName, config) to change ' +
					'an existing locale. moment.defineLocale(localeName, ' +
					'config) should only be used for creating a new locale ' +
					'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
				parentConfig = locales[name]._config;
			} else if (config.parentLocale != null) {
				if (locales[config.parentLocale] != null) {
					parentConfig = locales[config.parentLocale]._config;
				} else {
					locale = loadLocale(config.parentLocale);
					if (locale != null) {
						parentConfig = locale._config;
					} else {
						if (!localeFamilies[config.parentLocale]) {
							localeFamilies[config.parentLocale] = [];
						}
						localeFamilies[config.parentLocale].push({
							name: name,
							config: config
						});
						return null;
					}
				}
			}
			locales[name] = new Locale(mergeConfigs(parentConfig, config));

			if (localeFamilies[name]) {
				localeFamilies[name].forEach(function (x) {
					defineLocale(x.name, x.config);
				});
			}

			// backwards compat for now: also set the locale
			// make sure we set the locale AFTER all child locales have been
			// created, so we won't end up with the child locale set.
			getSetGlobalLocale(name);


			return locales[name];
		} else {
			// useful for testing
			delete locales[name];
			return null;
		}
	}

	function updateLocale(name, config) {
		if (config != null) {
			var locale, tmpLocale, parentConfig = baseConfig;
			// MERGE
			tmpLocale = loadLocale(name);
			if (tmpLocale != null) {
				parentConfig = tmpLocale._config;
			}
			config = mergeConfigs(parentConfig, config);
			locale = new Locale(config);
			locale.parentLocale = locales[name];
			locales[name] = locale;

			// backwards compat for now: also set the locale
			getSetGlobalLocale(name);
		} else {
			// pass null for config to unupdate, useful for tests
			if (locales[name] != null) {
				if (locales[name].parentLocale != null) {
					locales[name] = locales[name].parentLocale;
				} else if (locales[name] != null) {
					delete locales[name];
				}
			}
		}
		return locales[name];
	}

	// returns locale data
	function getLocale (key) {
		var locale;

		if (key && key._locale && key._locale._abbr) {
			key = key._locale._abbr;
		}

		if (!key) {
			return globalLocale;
		}

		if (!isArray(key)) {
			//short-circuit everything else
			locale = loadLocale(key);
			if (locale) {
				return locale;
			}
			key = [key];
		}

		return chooseLocale(key);
	}

	function listLocales() {
		return keys(locales);
	}

	function checkOverflow (m) {
		var overflow;
		var a = m._a;

		if (a && getParsingFlags(m).overflow === -2) {
			overflow =
				a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
					a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
						a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
							a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
								a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
									a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
										-1;

			if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
				overflow = DATE;
			}
			if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
				overflow = WEEK;
			}
			if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
				overflow = WEEKDAY;
			}

			getParsingFlags(m).overflow = overflow;
		}

		return m;
	}

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
		if (a != null) {
			return a;
		}
		if (b != null) {
			return b;
		}
		return c;
	}

	function currentDateArray(config) {
		// hooks is actually the exported moment object
		var nowValue = new Date(hooks.now());
		if (config._useUTC) {
			return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
		}
		return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
		var i, date, input = [], currentDate, expectedWeekday, yearToUse;

		if (config._d) {
			return;
		}

		currentDate = currentDateArray(config);

		//compute day of the year from weeks and weekdays
		if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
			dayOfYearFromWeekInfo(config);
		}

		//if the day of the year is set, figure out what it is
		if (config._dayOfYear != null) {
			yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

			if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
				getParsingFlags(config)._overflowDayOfYear = true;
			}

			date = createUTCDate(yearToUse, 0, config._dayOfYear);
			config._a[MONTH] = date.getUTCMonth();
			config._a[DATE] = date.getUTCDate();
		}

		// Default to current date.
		// * if no year, month, day of month are given, default to today
		// * if day of month is given, default month and year
		// * if month is given, default only year
		// * if year is given, don't default anything
		for (i = 0; i < 3 && config._a[i] == null; ++i) {
			config._a[i] = input[i] = currentDate[i];
		}

		// Zero out whatever was not defaulted, including time
		for (; i < 7; i++) {
			config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
		}

		// Check for 24:00:00.000
		if (config._a[HOUR] === 24 &&
			config._a[MINUTE] === 0 &&
			config._a[SECOND] === 0 &&
			config._a[MILLISECOND] === 0) {
			config._nextDay = true;
			config._a[HOUR] = 0;
		}

		config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
		expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

		// Apply timezone offset from input. The actual utcOffset can be changed
		// with parseZone.
		if (config._tzm != null) {
			config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
		}

		if (config._nextDay) {
			config._a[HOUR] = 24;
		}

		// check for mismatching day of week
		if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
			getParsingFlags(config).weekdayMismatch = true;
		}
	}

	function dayOfYearFromWeekInfo(config) {
		var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

		w = config._w;
		if (w.GG != null || w.W != null || w.E != null) {
			dow = 1;
			doy = 4;

			// TODO: We need to take the current isoWeekYear, but that depends on
			// how we interpret now (local, utc, fixed offset). So create
			// a now version of current config (take local/utc/offset flags, and
			// create now).
			weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
			week = defaults(w.W, 1);
			weekday = defaults(w.E, 1);
			if (weekday < 1 || weekday > 7) {
				weekdayOverflow = true;
			}
		} else {
			dow = config._locale._week.dow;
			doy = config._locale._week.doy;

			var curWeek = weekOfYear(createLocal(), dow, doy);

			weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

			// Default to current week.
			week = defaults(w.w, curWeek.week);

			if (w.d != null) {
				// weekday -- low day numbers are considered next week
				weekday = w.d;
				if (weekday < 0 || weekday > 6) {
					weekdayOverflow = true;
				}
			} else if (w.e != null) {
				// local weekday -- counting starts from beginning of week
				weekday = w.e + dow;
				if (w.e < 0 || w.e > 6) {
					weekdayOverflow = true;
				}
			} else {
				// default to beginning of week
				weekday = dow;
			}
		}
		if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
			getParsingFlags(config)._overflowWeeks = true;
		} else if (weekdayOverflow != null) {
			getParsingFlags(config)._overflowWeekday = true;
		} else {
			temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
			config._a[YEAR] = temp.year;
			config._dayOfYear = temp.dayOfYear;
		}
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
		['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
		['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
		['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
		['GGGG-[W]WW', /\d{4}-W\d\d/, false],
		['YYYY-DDD', /\d{4}-\d{3}/],
		['YYYY-MM', /\d{4}-\d\d/, false],
		['YYYYYYMMDD', /[+-]\d{10}/],
		['YYYYMMDD', /\d{8}/],
		// YYYYMM is NOT allowed by the standard
		['GGGG[W]WWE', /\d{4}W\d{3}/],
		['GGGG[W]WW', /\d{4}W\d{2}/, false],
		['YYYYDDD', /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes = [
		['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
		['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
		['HH:mm:ss', /\d\d:\d\d:\d\d/],
		['HH:mm', /\d\d:\d\d/],
		['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
		['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
		['HHmmss', /\d\d\d\d\d\d/],
		['HHmm', /\d\d\d\d/],
		['HH', /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
		var i, l,
			string = config._i,
			match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
			allowTime, dateFormat, timeFormat, tzFormat;

		if (match) {
			getParsingFlags(config).iso = true;

			for (i = 0, l = isoDates.length; i < l; i++) {
				if (isoDates[i][1].exec(match[1])) {
					dateFormat = isoDates[i][0];
					allowTime = isoDates[i][2] !== false;
					break;
				}
			}
			if (dateFormat == null) {
				config._isValid = false;
				return;
			}
			if (match[3]) {
				for (i = 0, l = isoTimes.length; i < l; i++) {
					if (isoTimes[i][1].exec(match[3])) {
						// match[2] should be 'T' or space
						timeFormat = (match[2] || ' ') + isoTimes[i][0];
						break;
					}
				}
				if (timeFormat == null) {
					config._isValid = false;
					return;
				}
			}
			if (!allowTime && timeFormat != null) {
				config._isValid = false;
				return;
			}
			if (match[4]) {
				if (tzRegex.exec(match[4])) {
					tzFormat = 'Z';
				} else {
					config._isValid = false;
					return;
				}
			}
			config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
			configFromStringAndFormat(config);
		} else {
			config._isValid = false;
		}
	}

	// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
		var result = [
			untruncateYear(yearStr),
			defaultLocaleMonthsShort.indexOf(monthStr),
			parseInt(dayStr, 10),
			parseInt(hourStr, 10),
			parseInt(minuteStr, 10)
		];

		if (secondStr) {
			result.push(parseInt(secondStr, 10));
		}

		return result;
	}

	function untruncateYear(yearStr) {
		var year = parseInt(yearStr, 10);
		if (year <= 49) {
			return 2000 + year;
		} else if (year <= 999) {
			return 1900 + year;
		}
		return year;
	}

	function preprocessRFC2822(s) {
		// Remove comments and folding whitespace and replace multiple-spaces with a single space
		return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	}

	function checkWeekday(weekdayStr, parsedInput, config) {
		if (weekdayStr) {
			// TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
			var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
				weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
			if (weekdayProvided !== weekdayActual) {
				getParsingFlags(config).weekdayMismatch = true;
				config._isValid = false;
				return false;
			}
		}
		return true;
	}

	var obsOffsets = {
		UT: 0,
		GMT: 0,
		EDT: -4 * 60,
		EST: -5 * 60,
		CDT: -5 * 60,
		CST: -6 * 60,
		MDT: -6 * 60,
		MST: -7 * 60,
		PDT: -7 * 60,
		PST: -8 * 60
	};

	function calculateOffset(obsOffset, militaryOffset, numOffset) {
		if (obsOffset) {
			return obsOffsets[obsOffset];
		} else if (militaryOffset) {
			// the only allowed military tz is Z
			return 0;
		} else {
			var hm = parseInt(numOffset, 10);
			var m = hm % 100, h = (hm - m) / 100;
			return h * 60 + m;
		}
	}

	// date and time from ref 2822 format
	function configFromRFC2822(config) {
		var match = rfc2822.exec(preprocessRFC2822(config._i));
		if (match) {
			var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
			if (!checkWeekday(match[1], parsedArray, config)) {
				return;
			}

			config._a = parsedArray;
			config._tzm = calculateOffset(match[8], match[9], match[10]);

			config._d = createUTCDate.apply(null, config._a);
			config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

			getParsingFlags(config).rfc2822 = true;
		} else {
			config._isValid = false;
		}
	}

	// date from iso format or fallback
	function configFromString(config) {
		var matched = aspNetJsonRegex.exec(config._i);

		if (matched !== null) {
			config._d = new Date(+matched[1]);
			return;
		}

		configFromISO(config);
		if (config._isValid === false) {
			delete config._isValid;
		} else {
			return;
		}

		configFromRFC2822(config);
		if (config._isValid === false) {
			delete config._isValid;
		} else {
			return;
		}

		// Final attempt, use Input Fallback
		hooks.createFromInputFallback(config);
	}

	hooks.createFromInputFallback = deprecate(
		'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
		'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
		'discouraged and will be removed in an upcoming major release. Please refer to ' +
		'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
		function (config) {
			config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
		}
	);

	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};

	// constant that refers to the RFC 2822 form
	hooks.RFC_2822 = function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
		// TODO: Move this to another part of the creation flow to prevent circular deps
		if (config._f === hooks.ISO_8601) {
			configFromISO(config);
			return;
		}
		if (config._f === hooks.RFC_2822) {
			configFromRFC2822(config);
			return;
		}
		config._a = [];
		getParsingFlags(config).empty = true;

		// This array is used to make a Date, either with `new Date` or `Date.UTC`
		var string = '' + config._i,
			i, parsedInput, tokens, token, skipped,
			stringLength = string.length,
			totalParsedInputLength = 0;

		tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

		for (i = 0; i < tokens.length; i++) {
			token = tokens[i];
			parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
			// console.log('token', token, 'parsedInput', parsedInput,
			//         'regex', getParseRegexForToken(token, config));
			if (parsedInput) {
				skipped = string.substr(0, string.indexOf(parsedInput));
				if (skipped.length > 0) {
					getParsingFlags(config).unusedInput.push(skipped);
				}
				string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
				totalParsedInputLength += parsedInput.length;
			}
			// don't parse if it's not a known token
			if (formatTokenFunctions[token]) {
				if (parsedInput) {
					getParsingFlags(config).empty = false;
				}
				else {
					getParsingFlags(config).unusedTokens.push(token);
				}
				addTimeToArrayFromToken(token, parsedInput, config);
			}
			else if (config._strict && !parsedInput) {
				getParsingFlags(config).unusedTokens.push(token);
			}
		}

		// add remaining unparsed input length to the string
		getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
		if (string.length > 0) {
			getParsingFlags(config).unusedInput.push(string);
		}

		// clear _12h flag if hour is <= 12
		if (config._a[HOUR] <= 12 &&
			getParsingFlags(config).bigHour === true &&
			config._a[HOUR] > 0) {
			getParsingFlags(config).bigHour = undefined;
		}

		getParsingFlags(config).parsedDateParts = config._a.slice(0);
		getParsingFlags(config).meridiem = config._meridiem;
		// handle meridiem
		config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

		configFromArray(config);
		checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
		var isPm;

		if (meridiem == null) {
			// nothing to do
			return hour;
		}
		if (locale.meridiemHour != null) {
			return locale.meridiemHour(hour, meridiem);
		} else if (locale.isPM != null) {
			// Fallback
			isPm = locale.isPM(meridiem);
			if (isPm && hour < 12) {
				hour += 12;
			}
			if (!isPm && hour === 12) {
				hour = 0;
			}
			return hour;
		} else {
			// this is not supposed to happen
			return hour;
		}
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
		var tempConfig,
			bestMoment,

			scoreToBeat,
			i,
			currentScore;

		if (config._f.length === 0) {
			getParsingFlags(config).invalidFormat = true;
			config._d = new Date(NaN);
			return;
		}

		for (i = 0; i < config._f.length; i++) {
			currentScore = 0;
			tempConfig = copyConfig({}, config);
			if (config._useUTC != null) {
				tempConfig._useUTC = config._useUTC;
			}
			tempConfig._f = config._f[i];
			configFromStringAndFormat(tempConfig);

			if (!isValid(tempConfig)) {
				continue;
			}

			// if there is any input that was not parsed add a penalty for that format
			currentScore += getParsingFlags(tempConfig).charsLeftOver;

			//or tokens
			currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

			getParsingFlags(tempConfig).score = currentScore;

			if (scoreToBeat == null || currentScore < scoreToBeat) {
				scoreToBeat = currentScore;
				bestMoment = tempConfig;
			}
		}

		extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
		if (config._d) {
			return;
		}

		var i = normalizeObjectUnits(config._i);
		config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
			return obj && parseInt(obj, 10);
		});

		configFromArray(config);
	}

	function createFromConfig (config) {
		var res = new Moment(checkOverflow(prepareConfig(config)));
		if (res._nextDay) {
			// Adding is smart enough around DST
			res.add(1, 'd');
			res._nextDay = undefined;
		}

		return res;
	}

	function prepareConfig (config) {
		var input = config._i,
			format = config._f;

		config._locale = config._locale || getLocale(config._l);

		if (input === null || (format === undefined && input === '')) {
			return createInvalid({nullInput: true});
		}

		if (typeof input === 'string') {
			config._i = input = config._locale.preparse(input);
		}

		if (isMoment(input)) {
			return new Moment(checkOverflow(input));
		} else if (isDate(input)) {
			config._d = input;
		} else if (isArray(format)) {
			configFromStringAndArray(config);
		} else if (format) {
			configFromStringAndFormat(config);
		}  else {
			configFromInput(config);
		}

		if (!isValid(config)) {
			config._d = null;
		}

		return config;
	}

	function configFromInput(config) {
		var input = config._i;
		if (isUndefined(input)) {
			config._d = new Date(hooks.now());
		} else if (isDate(input)) {
			config._d = new Date(input.valueOf());
		} else if (typeof input === 'string') {
			configFromString(config);
		} else if (isArray(input)) {
			config._a = map(input.slice(0), function (obj) {
				return parseInt(obj, 10);
			});
			configFromArray(config);
		} else if (isObject(input)) {
			configFromObject(config);
		} else if (isNumber(input)) {
			// from milliseconds
			config._d = new Date(input);
		} else {
			hooks.createFromInputFallback(config);
		}
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
		var c = {};

		if (locale === true || locale === false) {
			strict = locale;
			locale = undefined;
		}

		if ((isObject(input) && isObjectEmpty(input)) ||
			(isArray(input) && input.length === 0)) {
			input = undefined;
		}
		// object construction must be done this way.
		// https://github.com/moment/moment/issues/1423
		c._isAMomentObject = true;
		c._useUTC = c._isUTC = isUTC;
		c._l = locale;
		c._i = input;
		c._f = format;
		c._strict = strict;

		return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
		return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
		'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
		function () {
			var other = createLocal.apply(null, arguments);
			if (this.isValid() && other.isValid()) {
				return other < this ? this : other;
			} else {
				return createInvalid();
			}
		}
	);

	var prototypeMax = deprecate(
		'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
		function () {
			var other = createLocal.apply(null, arguments);
			if (this.isValid() && other.isValid()) {
				return other > this ? this : other;
			} else {
				return createInvalid();
			}
		}
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
		var res, i;
		if (moments.length === 1 && isArray(moments[0])) {
			moments = moments[0];
		}
		if (!moments.length) {
			return createLocal();
		}
		res = moments[0];
		for (i = 1; i < moments.length; ++i) {
			if (!moments[i].isValid() || moments[i][fn](res)) {
				res = moments[i];
			}
		}
		return res;
	}

	// TODO: Use [].sort instead?
	function min () {
		var args = [].slice.call(arguments, 0);

		return pickBy('isBefore', args);
	}

	function max () {
		var args = [].slice.call(arguments, 0);

		return pickBy('isAfter', args);
	}

	var now = function () {
		return Date.now ? Date.now() : +(new Date());
	};

	var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	function isDurationValid(m) {
		for (var key in m) {
			if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
				return false;
			}
		}

		var unitHasDecimal = false;
		for (var i = 0; i < ordering.length; ++i) {
			if (m[ordering[i]]) {
				if (unitHasDecimal) {
					return false; // only allow non-integers for smallest unit
				}
				if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
					unitHasDecimal = true;
				}
			}
		}

		return true;
	}

	function isValid$1() {
		return this._isValid;
	}

	function createInvalid$1() {
		return createDuration(NaN);
	}

	function Duration (duration) {
		var normalizedInput = normalizeObjectUnits(duration),
			years = normalizedInput.year || 0,
			quarters = normalizedInput.quarter || 0,
			months = normalizedInput.month || 0,
			weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
			days = normalizedInput.day || 0,
			hours = normalizedInput.hour || 0,
			minutes = normalizedInput.minute || 0,
			seconds = normalizedInput.second || 0,
			milliseconds = normalizedInput.millisecond || 0;

		this._isValid = isDurationValid(normalizedInput);

		// representation for dateAddRemove
		this._milliseconds = +milliseconds +
			seconds * 1e3 + // 1000
			minutes * 6e4 + // 1000 * 60
			hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
		// Because of dateAddRemove treats 24 hours as different from a
		// day when working around DST, we need to store them separately
		this._days = +days +
			weeks * 7;
		// It is impossible to translate months into days without knowing
		// which months you are are talking about, so we have to store
		// it separately.
		this._months = +months +
			quarters * 3 +
			years * 12;

		this._data = {};

		this._locale = getLocale();

		this._bubble();
	}

	function isDuration (obj) {
		return obj instanceof Duration;
	}

	function absRound (number) {
		if (number < 0) {
			return Math.round(-1 * number) * -1;
		} else {
			return Math.round(number);
		}
	}

	// FORMATTING

	function offset (token, separator) {
		addFormatToken(token, 0, 0, function () {
			var offset = this.utcOffset();
			var sign = '+';
			if (offset < 0) {
				offset = -offset;
				sign = '-';
			}
			return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
		});
	}

	offset('Z', ':');
	offset('ZZ', '');

	// PARSING

	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
		config._useUTC = true;
		config._tzm = offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
		var matches = (string || '').match(matcher);

		if (matches === null) {
			return null;
		}

		var chunk   = matches[matches.length - 1] || [];
		var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
		var minutes = +(parts[1] * 60) + toInt(parts[2]);

		return minutes === 0 ?
			0 :
			parts[0] === '+' ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
		var res, diff;
		if (model._isUTC) {
			res = model.clone();
			diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
			// Use low-level api, because this fn is low-level api.
			res._d.setTime(res._d.valueOf() + diff);
			hooks.updateOffset(res, false);
			return res;
		} else {
			return createLocal(input).local();
		}
	}

	function getDateOffset (m) {
		// On Firefox.24 Date#getTimezoneOffset returns a floating point.
		// https://github.com/moment/moment/pull/1871
		return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};

	// MOMENTS

	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime, keepMinutes) {
		var offset = this._offset || 0,
			localAdjust;
		if (!this.isValid()) {
			return input != null ? this : NaN;
		}
		if (input != null) {
			if (typeof input === 'string') {
				input = offsetFromString(matchShortOffset, input);
				if (input === null) {
					return this;
				}
			} else if (Math.abs(input) < 16 && !keepMinutes) {
				input = input * 60;
			}
			if (!this._isUTC && keepLocalTime) {
				localAdjust = getDateOffset(this);
			}
			this._offset = input;
			this._isUTC = true;
			if (localAdjust != null) {
				this.add(localAdjust, 'm');
			}
			if (offset !== input) {
				if (!keepLocalTime || this._changeInProgress) {
					addSubtract(this, createDuration(input - offset, 'm'), 1, false);
				} else if (!this._changeInProgress) {
					this._changeInProgress = true;
					hooks.updateOffset(this, true);
					this._changeInProgress = null;
				}
			}
			return this;
		} else {
			return this._isUTC ? offset : getDateOffset(this);
		}
	}

	function getSetZone (input, keepLocalTime) {
		if (input != null) {
			if (typeof input !== 'string') {
				input = -input;
			}

			this.utcOffset(input, keepLocalTime);

			return this;
		} else {
			return -this.utcOffset();
		}
	}

	function setOffsetToUTC (keepLocalTime) {
		return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
		if (this._isUTC) {
			this.utcOffset(0, keepLocalTime);
			this._isUTC = false;

			if (keepLocalTime) {
				this.subtract(getDateOffset(this), 'm');
			}
		}
		return this;
	}

	function setOffsetToParsedOffset () {
		if (this._tzm != null) {
			this.utcOffset(this._tzm, false, true);
		} else if (typeof this._i === 'string') {
			var tZone = offsetFromString(matchOffset, this._i);
			if (tZone != null) {
				this.utcOffset(tZone);
			}
			else {
				this.utcOffset(0, true);
			}
		}
		return this;
	}

	function hasAlignedHourOffset (input) {
		if (!this.isValid()) {
			return false;
		}
		input = input ? createLocal(input).utcOffset() : 0;

		return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime () {
		return (
			this.utcOffset() > this.clone().month(0).utcOffset() ||
			this.utcOffset() > this.clone().month(5).utcOffset()
		);
	}

	function isDaylightSavingTimeShifted () {
		if (!isUndefined(this._isDSTShifted)) {
			return this._isDSTShifted;
		}

		var c = {};

		copyConfig(c, this);
		c = prepareConfig(c);

		if (c._a) {
			var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
			this._isDSTShifted = this.isValid() &&
				compareArrays(c._a, other.toArray()) > 0;
		} else {
			this._isDSTShifted = false;
		}

		return this._isDSTShifted;
	}

	function isLocal () {
		return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
		return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
		return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
		var duration = input,
			// matching against regexp is expensive, do it on demand
			match = null,
			sign,
			ret,
			diffRes;

		if (isDuration(input)) {
			duration = {
				ms : input._milliseconds,
				d  : input._days,
				M  : input._months
			};
		} else if (isNumber(input)) {
			duration = {};
			if (key) {
				duration[key] = input;
			} else {
				duration.milliseconds = input;
			}
		} else if (!!(match = aspNetRegex.exec(input))) {
			sign = (match[1] === '-') ? -1 : 1;
			duration = {
				y  : 0,
				d  : toInt(match[DATE])                         * sign,
				h  : toInt(match[HOUR])                         * sign,
				m  : toInt(match[MINUTE])                       * sign,
				s  : toInt(match[SECOND])                       * sign,
				ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
			};
		} else if (!!(match = isoRegex.exec(input))) {
			sign = (match[1] === '-') ? -1 : 1;
			duration = {
				y : parseIso(match[2], sign),
				M : parseIso(match[3], sign),
				w : parseIso(match[4], sign),
				d : parseIso(match[5], sign),
				h : parseIso(match[6], sign),
				m : parseIso(match[7], sign),
				s : parseIso(match[8], sign)
			};
		} else if (duration == null) {// checks for null or undefined
			duration = {};
		} else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
			diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

			duration = {};
			duration.ms = diffRes.milliseconds;
			duration.M = diffRes.months;
		}

		ret = new Duration(duration);

		if (isDuration(input) && hasOwnProp(input, '_locale')) {
			ret._locale = input._locale;
		}

		return ret;
	}

	createDuration.fn = Duration.prototype;
	createDuration.invalid = createInvalid$1;

	function parseIso (inp, sign) {
		// We'd normally use ~~inp for this, but unfortunately it also
		// converts floats to ints.
		// inp may be undefined, so careful calling replace on it.
		var res = inp && parseFloat(inp.replace(',', '.'));
		// apply sign while we're at it
		return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
		var res = {};

		res.months = other.month() - base.month() +
			(other.year() - base.year()) * 12;
		if (base.clone().add(res.months, 'M').isAfter(other)) {
			--res.months;
		}

		res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

		return res;
	}

	function momentsDifference(base, other) {
		var res;
		if (!(base.isValid() && other.isValid())) {
			return {milliseconds: 0, months: 0};
		}

		other = cloneWithOffset(other, base);
		if (base.isBefore(other)) {
			res = positiveMomentsDifference(base, other);
		} else {
			res = positiveMomentsDifference(other, base);
			res.milliseconds = -res.milliseconds;
			res.months = -res.months;
		}

		return res;
	}

	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
		return function (val, period) {
			var dur, tmp;
			//invert the arguments, but complain about it
			if (period !== null && !isNaN(+period)) {
				deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
					'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
				tmp = val; val = period; period = tmp;
			}

			val = typeof val === 'string' ? +val : val;
			dur = createDuration(val, period);
			addSubtract(this, dur, direction);
			return this;
		};
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
		var milliseconds = duration._milliseconds,
			days = absRound(duration._days),
			months = absRound(duration._months);

		if (!mom.isValid()) {
			// No op
			return;
		}

		updateOffset = updateOffset == null ? true : updateOffset;

		if (months) {
			setMonth(mom, get(mom, 'Month') + months * isAdding);
		}
		if (days) {
			set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
		}
		if (milliseconds) {
			mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
		}
		if (updateOffset) {
			hooks.updateOffset(mom, days || months);
		}
	}

	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');

	function getCalendarFormat(myMoment, now) {
		var diff = myMoment.diff(now, 'days', true);
		return diff < -6 ? 'sameElse' :
			diff < -1 ? 'lastWeek' :
				diff < 0 ? 'lastDay' :
					diff < 1 ? 'sameDay' :
						diff < 2 ? 'nextDay' :
							diff < 7 ? 'nextWeek' : 'sameElse';
	}

	function calendar$1 (time, formats) {
		// We want to compare the start of today, vs this.
		// Getting start-of-today depends on whether we're local/utc/offset or not.
		var now = time || createLocal(),
			sod = cloneWithOffset(now, this).startOf('day'),
			format = hooks.calendarFormat(this, sod) || 'sameElse';

		var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

		return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
		return new Moment(this);
	}

	function isAfter (input, units) {
		var localInput = isMoment(input) ? input : createLocal(input);
		if (!(this.isValid() && localInput.isValid())) {
			return false;
		}
		units = normalizeUnits(units) || 'millisecond';
		if (units === 'millisecond') {
			return this.valueOf() > localInput.valueOf();
		} else {
			return localInput.valueOf() < this.clone().startOf(units).valueOf();
		}
	}

	function isBefore (input, units) {
		var localInput = isMoment(input) ? input : createLocal(input);
		if (!(this.isValid() && localInput.isValid())) {
			return false;
		}
		units = normalizeUnits(units) || 'millisecond';
		if (units === 'millisecond') {
			return this.valueOf() < localInput.valueOf();
		} else {
			return this.clone().endOf(units).valueOf() < localInput.valueOf();
		}
	}

	function isBetween (from, to, units, inclusivity) {
		var localFrom = isMoment(from) ? from : createLocal(from),
			localTo = isMoment(to) ? to : createLocal(to);
		if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
			return false;
		}
		inclusivity = inclusivity || '()';
		return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
			(inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
	}

	function isSame (input, units) {
		var localInput = isMoment(input) ? input : createLocal(input),
			inputMs;
		if (!(this.isValid() && localInput.isValid())) {
			return false;
		}
		units = normalizeUnits(units) || 'millisecond';
		if (units === 'millisecond') {
			return this.valueOf() === localInput.valueOf();
		} else {
			inputMs = localInput.valueOf();
			return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
		}
	}

	function isSameOrAfter (input, units) {
		return this.isSame(input, units) || this.isAfter(input, units);
	}

	function isSameOrBefore (input, units) {
		return this.isSame(input, units) || this.isBefore(input, units);
	}

	function diff (input, units, asFloat) {
		var that,
			zoneDelta,
			output;

		if (!this.isValid()) {
			return NaN;
		}

		that = cloneWithOffset(input, this);

		if (!that.isValid()) {
			return NaN;
		}

		zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

		units = normalizeUnits(units);

		switch (units) {
			case 'year': output = monthDiff(this, that) / 12; break;
			case 'month': output = monthDiff(this, that); break;
			case 'quarter': output = monthDiff(this, that) / 3; break;
			case 'second': output = (this - that) / 1e3; break; // 1000
			case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
			case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
			case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
			case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
			default: output = this - that;
		}

		return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
		// difference in months
		var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
			// b is in (anchor - 1 month, anchor + 1 month)
			anchor = a.clone().add(wholeMonthDiff, 'months'),
			anchor2, adjust;

		if (b - anchor < 0) {
			anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
			// linear across the month
			adjust = (b - anchor) / (anchor - anchor2);
		} else {
			anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
			// linear across the month
			adjust = (b - anchor) / (anchor2 - anchor);
		}

		//check for negative zero, return zero if negative zero
		return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	function toString () {
		return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}

	function toISOString(keepOffset) {
		if (!this.isValid()) {
			return null;
		}
		var utc = keepOffset !== true;
		var m = utc ? this.clone().utc() : this;
		if (m.year() < 0 || m.year() > 9999) {
			return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
		}
		if (isFunction(Date.prototype.toISOString)) {
			// native implementation is ~50x faster, use it when we can
			if (utc) {
				return this.toDate().toISOString();
			} else {
				return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
			}
		}
		return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
		if (!this.isValid()) {
			return 'moment.invalid(/* ' + this._i + ' */)';
		}
		var func = 'moment';
		var zone = '';
		if (!this.isLocal()) {
			func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
			zone = 'Z';
		}
		var prefix = '[' + func + '("]';
		var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
		var datetime = '-MM-DD[T]HH:mm:ss.SSS';
		var suffix = zone + '[")]';

		return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
		if (!inputString) {
			inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
		}
		var output = formatMoment(this, inputString);
		return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
		if (this.isValid() &&
			((isMoment(time) && time.isValid()) ||
				createLocal(time).isValid())) {
			return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
		} else {
			return this.localeData().invalidDate();
		}
	}

	function fromNow (withoutSuffix) {
		return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
		if (this.isValid() &&
			((isMoment(time) && time.isValid()) ||
				createLocal(time).isValid())) {
			return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
		} else {
			return this.localeData().invalidDate();
		}
	}

	function toNow (withoutSuffix) {
		return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
		var newLocaleData;

		if (key === undefined) {
			return this._locale._abbr;
		} else {
			newLocaleData = getLocale(key);
			if (newLocaleData != null) {
				this._locale = newLocaleData;
			}
			return this;
		}
	}

	var lang = deprecate(
		'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
		function (key) {
			if (key === undefined) {
				return this.localeData();
			} else {
				return this.locale(key);
			}
		}
	);

	function localeData () {
		return this._locale;
	}

	var MS_PER_SECOND = 1000;
	var MS_PER_MINUTE = 60 * MS_PER_SECOND;
	var MS_PER_HOUR = 60 * MS_PER_MINUTE;
	var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

	// actual modulo - handles negative numbers (for dates before 1970):
	function mod$1(dividend, divisor) {
		return (dividend % divisor + divisor) % divisor;
	}

	function localStartOfDate(y, m, d) {
		// the date constructor remaps years 0-99 to 1900-1999
		if (y < 100 && y >= 0) {
			// preserve leap years using a full 400 year cycle, then reset
			return new Date(y + 400, m, d) - MS_PER_400_YEARS;
		} else {
			return new Date(y, m, d).valueOf();
		}
	}

	function utcStartOfDate(y, m, d) {
		// Date.UTC remaps years 0-99 to 1900-1999
		if (y < 100 && y >= 0) {
			// preserve leap years using a full 400 year cycle, then reset
			return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
		} else {
			return Date.UTC(y, m, d);
		}
	}

	function startOf (units) {
		var time;
		units = normalizeUnits(units);
		if (units === undefined || units === 'millisecond' || !this.isValid()) {
			return this;
		}

		var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		switch (units) {
			case 'year':
				time = startOfDate(this.year(), 0, 1);
				break;
			case 'quarter':
				time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
				break;
			case 'month':
				time = startOfDate(this.year(), this.month(), 1);
				break;
			case 'week':
				time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
				break;
			case 'isoWeek':
				time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
				break;
			case 'day':
			case 'date':
				time = startOfDate(this.year(), this.month(), this.date());
				break;
			case 'hour':
				time = this._d.valueOf();
				time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
				break;
			case 'minute':
				time = this._d.valueOf();
				time -= mod$1(time, MS_PER_MINUTE);
				break;
			case 'second':
				time = this._d.valueOf();
				time -= mod$1(time, MS_PER_SECOND);
				break;
		}

		this._d.setTime(time);
		hooks.updateOffset(this, true);
		return this;
	}

	function endOf (units) {
		var time;
		units = normalizeUnits(units);
		if (units === undefined || units === 'millisecond' || !this.isValid()) {
			return this;
		}

		var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		switch (units) {
			case 'year':
				time = startOfDate(this.year() + 1, 0, 1) - 1;
				break;
			case 'quarter':
				time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
				break;
			case 'month':
				time = startOfDate(this.year(), this.month() + 1, 1) - 1;
				break;
			case 'week':
				time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
				break;
			case 'isoWeek':
				time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
				break;
			case 'day':
			case 'date':
				time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
				break;
			case 'hour':
				time = this._d.valueOf();
				time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
				break;
			case 'minute':
				time = this._d.valueOf();
				time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
				break;
			case 'second':
				time = this._d.valueOf();
				time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
				break;
		}

		this._d.setTime(time);
		hooks.updateOffset(this, true);
		return this;
	}

	function valueOf () {
		return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
		return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
		return new Date(this.valueOf());
	}

	function toArray () {
		var m = this;
		return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
		var m = this;
		return {
			years: m.year(),
			months: m.month(),
			date: m.date(),
			hours: m.hours(),
			minutes: m.minutes(),
			seconds: m.seconds(),
			milliseconds: m.milliseconds()
		};
	}

	function toJSON () {
		// new Date(NaN).toJSON() === null
		return this.isValid() ? this.toISOString() : null;
	}

	function isValid$2 () {
		return isValid(this);
	}

	function parsingFlags () {
		return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
		return getParsingFlags(this).overflow;
	}

	function creationData() {
		return {
			input: this._i,
			format: this._f,
			locale: this._locale,
			isUTC: this._isUTC,
			strict: this._strict
		};
	}

	// FORMATTING

	addFormatToken(0, ['gg', 2], 0, function () {
		return this.weekYear() % 100;
	});

	addFormatToken(0, ['GG', 2], 0, function () {
		return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
		addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	// ALIASES

	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');

	// PRIORITY

	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);


	// PARSING

	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);

	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
		week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
		week[token] = hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
		return getSetWeekYearHelper.call(this,
			input,
			this.week(),
			this.weekday(),
			this.localeData()._week.dow,
			this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
		return getSetWeekYearHelper.call(this,
			input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
		return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
		var weekInfo = this.localeData()._week;
		return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
		var weeksTarget;
		if (input == null) {
			return weekOfYear(this, dow, doy).year;
		} else {
			weeksTarget = weeksInYear(input, dow, doy);
			if (week > weeksTarget) {
				week = weeksTarget;
			}
			return setWeekAll.call(this, input, week, weekday, dow, doy);
		}
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
		var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
			date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

		this.year(date.getUTCFullYear());
		this.month(date.getUTCMonth());
		this.date(date.getUTCDate());
		return this;
	}

	// FORMATTING

	addFormatToken('Q', 0, 'Qo', 'quarter');

	// ALIASES

	addUnitAlias('quarter', 'Q');

	// PRIORITY

	addUnitPriority('quarter', 7);

	// PARSING

	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
		array[MONTH] = (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
		return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken('D', ['DD', 2], 'Do', 'date');

	// ALIASES

	addUnitAlias('date', 'D');

	// PRIORITY
	addUnitPriority('date', 9);

	// PARSING

	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
		// TODO: Remove "ordinalParse" fallback in next major release.
		return isStrict ?
			(locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
			locale._dayOfMonthOrdinalParseLenient;
	});

	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
		array[DATE] = toInt(input.match(match1to2)[0]);
	});

	// MOMENTS

	var getSetDayOfMonth = makeGetSet('Date', true);

	// FORMATTING

	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	// ALIASES

	addUnitAlias('dayOfYear', 'DDD');

	// PRIORITY
	addUnitPriority('dayOfYear', 4);

	// PARSING

	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
		config._dayOfYear = toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
		var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
		return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}

	// FORMATTING

	addFormatToken('m', ['mm', 2], 0, 'minute');

	// ALIASES

	addUnitAlias('minute', 'm');

	// PRIORITY

	addUnitPriority('minute', 14);

	// PARSING

	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);

	// MOMENTS

	var getSetMinute = makeGetSet('Minutes', false);

	// FORMATTING

	addFormatToken('s', ['ss', 2], 0, 'second');

	// ALIASES

	addUnitAlias('second', 's');

	// PRIORITY

	addUnitPriority('second', 15);

	// PARSING

	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);

	// MOMENTS

	var getSetSecond = makeGetSet('Seconds', false);

	// FORMATTING

	addFormatToken('S', 0, 0, function () {
		return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, ['SS', 2], 0, function () {
		return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
		return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
		return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
		return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
		return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
		return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
		return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias('millisecond', 'ms');

	// PRIORITY

	addUnitPriority('millisecond', 16);

	// PARSING

	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);

	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
		addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
		array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}

	for (token = 'S'; token.length <= 9; token += 'S') {
		addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond = makeGetSet('Milliseconds', false);

	// FORMATTING

	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');

	// MOMENTS

	function getZoneAbbr () {
		return this._isUTC ? 'UTC' : '';
	}

	function getZoneName () {
		return this._isUTC ? 'Coordinated Universal Time' : '';
	}

	var proto = Moment.prototype;

	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$2;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;
	proto.quarter = proto.quarters = getSetQuarter;
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;
	proto.hour = proto.hours = getSetHour;
	proto.minute = proto.minutes = getSetMinute;
	proto.second = proto.seconds = getSetSecond;
	proto.millisecond = proto.milliseconds = getSetMillisecond;
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	function createUnix (input) {
		return createLocal(input * 1000);
	}

	function createInZone () {
		return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
		return string;
	}

	var proto$1 = Locale.prototype;

	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;

	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;

	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;

	function get$1 (format, index, field, setter) {
		var locale = getLocale();
		var utc = createUTC().set(setter, index);
		return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
		if (isNumber(format)) {
			index = format;
			format = undefined;
		}

		format = format || '';

		if (index != null) {
			return get$1(format, index, field, 'month');
		}

		var i;
		var out = [];
		for (i = 0; i < 12; i++) {
			out[i] = get$1(format, i, field, 'month');
		}
		return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
		if (typeof localeSorted === 'boolean') {
			if (isNumber(format)) {
				index = format;
				format = undefined;
			}

			format = format || '';
		} else {
			format = localeSorted;
			index = format;
			localeSorted = false;

			if (isNumber(format)) {
				index = format;
				format = undefined;
			}

			format = format || '';
		}

		var locale = getLocale(),
			shift = localeSorted ? locale._week.dow : 0;

		if (index != null) {
			return get$1(format, (index + shift) % 7, field, 'day');
		}

		var i;
		var out = [];
		for (i = 0; i < 7; i++) {
			out[i] = get$1(format, (i + shift) % 7, field, 'day');
		}
		return out;
	}

	function listMonths (format, index) {
		return listMonthsImpl(format, index, 'months');
	}

	function listMonthsShort (format, index) {
		return listMonthsImpl(format, index, 'monthsShort');
	}

	function listWeekdays (localeSorted, format, index) {
		return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}

	function listWeekdaysShort (localeSorted, format, index) {
		return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}

	function listWeekdaysMin (localeSorted, format, index) {
		return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}

	getSetGlobalLocale('en', {
		dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (toInt(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		}
	});

	// Side effect imports

	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

	var mathAbs = Math.abs;

	function abs () {
		var data           = this._data;

		this._milliseconds = mathAbs(this._milliseconds);
		this._days         = mathAbs(this._days);
		this._months       = mathAbs(this._months);

		data.milliseconds  = mathAbs(data.milliseconds);
		data.seconds       = mathAbs(data.seconds);
		data.minutes       = mathAbs(data.minutes);
		data.hours         = mathAbs(data.hours);
		data.months        = mathAbs(data.months);
		data.years         = mathAbs(data.years);

		return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
		var other = createDuration(input, value);

		duration._milliseconds += direction * other._milliseconds;
		duration._days         += direction * other._days;
		duration._months       += direction * other._months;

		return duration._bubble();
	}

	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
		return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
		return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
		if (number < 0) {
			return Math.floor(number);
		} else {
			return Math.ceil(number);
		}
	}

	function bubble () {
		var milliseconds = this._milliseconds;
		var days         = this._days;
		var months       = this._months;
		var data         = this._data;
		var seconds, minutes, hours, years, monthsFromDays;

		// if we have a mix of positive and negative values, bubble down first
		// check: https://github.com/moment/moment/issues/2166
		if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
			(milliseconds <= 0 && days <= 0 && months <= 0))) {
			milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
			days = 0;
			months = 0;
		}

		// The following code bubbles up values, see the tests for
		// examples of what that means.
		data.milliseconds = milliseconds % 1000;

		seconds           = absFloor(milliseconds / 1000);
		data.seconds      = seconds % 60;

		minutes           = absFloor(seconds / 60);
		data.minutes      = minutes % 60;

		hours             = absFloor(minutes / 60);
		data.hours        = hours % 24;

		days += absFloor(hours / 24);

		// convert days to months
		monthsFromDays = absFloor(daysToMonths(days));
		months += monthsFromDays;
		days -= absCeil(monthsToDays(monthsFromDays));

		// 12 months -> 1 year
		years = absFloor(months / 12);
		months %= 12;

		data.days   = days;
		data.months = months;
		data.years  = years;

		return this;
	}

	function daysToMonths (days) {
		// 400 years have 146097 days (taking into account leap year rules)
		// 400 years have 12 months === 4800
		return days * 4800 / 146097;
	}

	function monthsToDays (months) {
		// the reverse of daysToMonths
		return months * 146097 / 4800;
	}

	function as (units) {
		if (!this.isValid()) {
			return NaN;
		}
		var days;
		var months;
		var milliseconds = this._milliseconds;

		units = normalizeUnits(units);

		if (units === 'month' || units === 'quarter' || units === 'year') {
			days = this._days + milliseconds / 864e5;
			months = this._months + daysToMonths(days);
			switch (units) {
				case 'month':   return months;
				case 'quarter': return months / 3;
				case 'year':    return months / 12;
			}
		} else {
			// handle milliseconds separately because of floating point math errors (issue #1867)
			days = this._days + Math.round(monthsToDays(this._months));
			switch (units) {
				case 'week'   : return days / 7     + milliseconds / 6048e5;
				case 'day'    : return days         + milliseconds / 864e5;
				case 'hour'   : return days * 24    + milliseconds / 36e5;
				case 'minute' : return days * 1440  + milliseconds / 6e4;
				case 'second' : return days * 86400 + milliseconds / 1000;
				// Math.floor prevents floating point math errors here
				case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
				default: throw new Error('Unknown unit ' + units);
			}
		}
	}

	// TODO: Use this.as('ms')?
	function valueOf$1 () {
		if (!this.isValid()) {
			return NaN;
		}
		return (
			this._milliseconds +
			this._days * 864e5 +
			(this._months % 12) * 2592e6 +
			toInt(this._months / 12) * 31536e6
		);
	}

	function makeAs (alias) {
		return function () {
			return this.as(alias);
		};
	}

	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asQuarters     = makeAs('Q');
	var asYears        = makeAs('y');

	function clone$1 () {
		return createDuration(this);
	}

	function get$2 (units) {
		units = normalizeUnits(units);
		return this.isValid() ? this[units + 's']() : NaN;
	}

	function makeGetter(name) {
		return function () {
			return this.isValid() ? this._data[name] : NaN;
		};
	}

	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');

	function weeks () {
		return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
		ss: 44,         // a few seconds to seconds
		s : 45,         // seconds to minute
		m : 45,         // minutes to hour
		h : 22,         // hours to day
		d : 26,         // days to month
		M : 11          // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
		return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
		var duration = createDuration(posNegDuration).abs();
		var seconds  = round(duration.as('s'));
		var minutes  = round(duration.as('m'));
		var hours    = round(duration.as('h'));
		var days     = round(duration.as('d'));
		var months   = round(duration.as('M'));
		var years    = round(duration.as('y'));

		var a = seconds <= thresholds.ss && ['s', seconds]  ||
			seconds < thresholds.s   && ['ss', seconds] ||
			minutes <= 1             && ['m']           ||
			minutes < thresholds.m   && ['mm', minutes] ||
			hours   <= 1             && ['h']           ||
			hours   < thresholds.h   && ['hh', hours]   ||
			days    <= 1             && ['d']           ||
			days    < thresholds.d   && ['dd', days]    ||
			months  <= 1             && ['M']           ||
			months  < thresholds.M   && ['MM', months]  ||
			years   <= 1             && ['y']           || ['yy', years];

		a[2] = withoutSuffix;
		a[3] = +posNegDuration > 0;
		a[4] = locale;
		return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
		if (roundingFunction === undefined) {
			return round;
		}
		if (typeof(roundingFunction) === 'function') {
			round = roundingFunction;
			return true;
		}
		return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
		if (thresholds[threshold] === undefined) {
			return false;
		}
		if (limit === undefined) {
			return thresholds[threshold];
		}
		thresholds[threshold] = limit;
		if (threshold === 's') {
			thresholds.ss = limit - 1;
		}
		return true;
	}

	function humanize (withSuffix) {
		if (!this.isValid()) {
			return this.localeData().invalidDate();
		}

		var locale = this.localeData();
		var output = relativeTime$1(this, !withSuffix, locale);

		if (withSuffix) {
			output = locale.pastFuture(+this, output);
		}

		return locale.postformat(output);
	}

	var abs$1 = Math.abs;

	function sign(x) {
		return ((x > 0) - (x < 0)) || +x;
	}

	function toISOString$1() {
		// for ISO strings we do not use the normal bubbling rules:
		//  * milliseconds bubble up until they become hours
		//  * days do not bubble at all
		//  * months bubble up until they become years
		// This is because there is no context-free conversion between hours and days
		// (think of clock changes)
		// and also not between days and months (28-31 days per month)
		if (!this.isValid()) {
			return this.localeData().invalidDate();
		}

		var seconds = abs$1(this._milliseconds) / 1000;
		var days         = abs$1(this._days);
		var months       = abs$1(this._months);
		var minutes, hours, years;

		// 3600 seconds -> 60 minutes -> 1 hour
		minutes           = absFloor(seconds / 60);
		hours             = absFloor(minutes / 60);
		seconds %= 60;
		minutes %= 60;

		// 12 months -> 1 year
		years  = absFloor(months / 12);
		months %= 12;


		// inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		var Y = years;
		var M = months;
		var D = days;
		var h = hours;
		var m = minutes;
		var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
		var total = this.asSeconds();

		if (!total) {
			// this is the same as C#'s (Noda) and python (isodate)...
			// but not other JS (goog.date)
			return 'P0D';
		}

		var totalSign = total < 0 ? '-' : '';
		var ymSign = sign(this._months) !== sign(total) ? '-' : '';
		var daysSign = sign(this._days) !== sign(total) ? '-' : '';
		var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

		return totalSign + 'P' +
			(Y ? ymSign + Y + 'Y' : '') +
			(M ? ymSign + M + 'M' : '') +
			(D ? daysSign + D + 'D' : '') +
			((h || m || s) ? 'T' : '') +
			(h ? hmsSign + h + 'H' : '') +
			(m ? hmsSign + m + 'M' : '') +
			(s ? hmsSign + s + 'S' : '');
	}

	var proto$2 = Duration.prototype;

	proto$2.isValid        = isValid$1;
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asQuarters     = asQuarters;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.clone          = clone$1;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;

	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang;

	// Side effect imports

	// FORMATTING

	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');

	// PARSING

	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
		config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
		config._d = new Date(toInt(input));
	});

	// Side effect imports

	//! moment.js

	hooks.version = '2.24.0';

	setHookCallback(createLocal);

	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;

	// currently HTML5 input type only supports 24-hour formats
	hooks.HTML5_FMT = {
		DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
		DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
		DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
		DATE: 'YYYY-MM-DD',                             // <input type="date" />
		TIME: 'HH:mm',                                  // <input type="time" />
		TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
		TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
		WEEK: 'GGGG-[W]WW',                             // <input type="week" />
		MONTH: 'YYYY-MM'                                // <input type="month" />
	};

	//! moment.js locale configuration

	hooks.defineLocale('af', {
		months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
		monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
		weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
		weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
		weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
		meridiemParse: /vm|nm/i,
		isPM : function (input) {
			return /^nm$/i.test(input);
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 12) {
				return isLower ? 'vm' : 'VM';
			} else {
				return isLower ? 'nm' : 'NM';
			}
		},
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Vandag om] LT',
			nextDay : '[Mre om] LT',
			nextWeek : 'dddd [om] LT',
			lastDay : '[Gister om] LT',
			lastWeek : '[Laas] dddd [om] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'oor %s',
			past : '%s gelede',
			s : '\'n paar sekondes',
			ss : '%d sekondes',
			m : '\'n minuut',
			mm : '%d minute',
			h : '\'n uur',
			hh : '%d ure',
			d : '\'n dag',
			dd : '%d dae',
			M : '\'n maand',
			MM : '%d maande',
			y : '\'n jaar',
			yy : '%d jaar'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
		ordinal : function (number) {
			return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
		},
		week : {
			dow : 1, // Maandag is die eerste dag van die week.
			doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ar-dz', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : '',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ar-kw', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : '',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap = {
		'1': '1',
		'2': '2',
		'3': '3',
		'4': '4',
		'5': '5',
		'6': '6',
		'7': '7',
		'8': '8',
		'9': '9',
		'0': '0'
	}, pluralForm = function (n) {
		return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	}, plurals = {
		s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	}, pluralize = function (u) {
		return function (number, withoutSuffix, string, isFuture) {
			var f = pluralForm(number),
				str = plurals[u][pluralForm(number)];
			if (f === 2) {
				str = str[withoutSuffix ? 0 : 1];
			}
			return str.replace(/%d/i, number);
		};
	}, months$1 = [
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];

	hooks.defineLocale('ar-ly', {
		months : months$1,
		monthsShort : months$1,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'D/\u200FM/\u200FYYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM : function (input) {
			return '' === input;
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : pluralize('s'),
			ss : pluralize('s'),
			m : pluralize('m'),
			mm : pluralize('m'),
			h : pluralize('h'),
			hh : pluralize('h'),
			d : pluralize('d'),
			dd : pluralize('d'),
			M : pluralize('M'),
			MM : pluralize('M'),
			y : pluralize('y'),
			yy : pluralize('y')
		},
		preparse: function (string) {
			return string.replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap[match];
			}).replace(/,/g, '');
		},
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ar-ma', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : '',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$1 = {
		'1': '',
		'2': '',
		'3': '',
		'4': '',
		'5': '',
		'6': '',
		'7': '',
		'8': '',
		'9': '',
		'0': ''
	}, numberMap = {
		'': '1',
		'': '2',
		'': '3',
		'': '4',
		'': '5',
		'': '6',
		'': '7',
		'': '8',
		'': '9',
		'': '0'
	};

	hooks.defineLocale('ar-sa', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM : function (input) {
			return '' === input;
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : '',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap[match];
			}).replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$1[match];
			}).replace(/,/g, '');
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ar-tn', {
		months: '___________'.split('_'),
		monthsShort: '___________'.split('_'),
		weekdays: '______'.split('_'),
		weekdaysShort: '______'.split('_'),
		weekdaysMin: '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat: {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY HH:mm',
			LLLL: 'dddd D MMMM YYYY HH:mm'
		},
		calendar: {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: ' %s',
			past: ' %s',
			s: '',
			ss : '%d ',
			m: '',
			mm: '%d ',
			h: '',
			hh: '%d ',
			d: '',
			dd: '%d ',
			M: '',
			MM: '%d ',
			y: '',
			yy: '%d '
		},
		week: {
			dow: 1, // Monday is the first day of the week.
			doy: 4 // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$2 = {
		'1': '',
		'2': '',
		'3': '',
		'4': '',
		'5': '',
		'6': '',
		'7': '',
		'8': '',
		'9': '',
		'0': ''
	}, numberMap$1 = {
		'': '1',
		'': '2',
		'': '3',
		'': '4',
		'': '5',
		'': '6',
		'': '7',
		'': '8',
		'': '9',
		'': '0'
	}, pluralForm$1 = function (n) {
		return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	}, plurals$1 = {
		s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
		y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	}, pluralize$1 = function (u) {
		return function (number, withoutSuffix, string, isFuture) {
			var f = pluralForm$1(number),
				str = plurals$1[u][pluralForm$1(number)];
			if (f === 2) {
				str = str[withoutSuffix ? 0 : 1];
			}
			return str.replace(/%d/i, number);
		};
	}, months$2 = [
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];

	hooks.defineLocale('ar', {
		months : months$2,
		monthsShort : months$2,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'D/\u200FM/\u200FYYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM : function (input) {
			return '' === input;
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay: '[  ] LT',
			nextDay: '[  ] LT',
			nextWeek: 'dddd [ ] LT',
			lastDay: '[  ] LT',
			lastWeek: 'dddd [ ] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : pluralize$1('s'),
			ss : pluralize$1('s'),
			m : pluralize$1('m'),
			mm : pluralize$1('m'),
			h : pluralize$1('h'),
			hh : pluralize$1('h'),
			d : pluralize$1('d'),
			dd : pluralize$1('d'),
			M : pluralize$1('M'),
			MM : pluralize$1('M'),
			y : pluralize$1('y'),
			yy : pluralize$1('y')
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$1[match];
			}).replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$2[match];
			}).replace(/,/g, '');
		},
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var suffixes = {
		1: '-inci',
		5: '-inci',
		8: '-inci',
		70: '-inci',
		80: '-inci',
		2: '-nci',
		7: '-nci',
		20: '-nci',
		50: '-nci',
		3: '-nc',
		4: '-nc',
		100: '-nc',
		6: '-nc',
		9: '-uncu',
		10: '-uncu',
		30: '-uncu',
		60: '-nc',
		90: '-nc'
	};

	hooks.defineLocale('az', {
		months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
		monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
		weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
		weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
		weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[bugn saat] LT',
			nextDay : '[sabah saat] LT',
			nextWeek : '[gln hft] dddd [saat] LT',
			lastDay : '[dnn] LT',
			lastWeek : '[ken hft] dddd [saat] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s sonra',
			past : '%s vvl',
			s : 'birne saniy',
			ss : '%d saniy',
			m : 'bir dqiq',
			mm : '%d dqiq',
			h : 'bir saat',
			hh : '%d saat',
			d : 'bir gn',
			dd : '%d gn',
			M : 'bir ay',
			MM : '%d ay',
			y : 'bir il',
			yy : '%d il'
		},
		meridiemParse: /gec|shr|gndz|axam/,
		isPM : function (input) {
			return /^(gndz|axam)$/.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return 'gec';
			} else if (hour < 12) {
				return 'shr';
			} else if (hour < 17) {
				return 'gndz';
			} else {
				return 'axam';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
		ordinal : function (number) {
			if (number === 0) {  // special case for zero
				return number + '-nc';
			}
			var a = number % 10,
				b = number % 100 - a,
				c = number >= 100 ? 100 : null;
			return number + (suffixes[a] || suffixes[b] || suffixes[c]);
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function plural(word, num) {
		var forms = word.split('_');
		return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
		var format = {
			'ss': withoutSuffix ? '__' : '__',
			'mm': withoutSuffix ? '__' : '__',
			'hh': withoutSuffix ? '__' : '__',
			'dd': '__',
			'MM': '__',
			'yy': '__'
		};
		if (key === 'm') {
			return withoutSuffix ? '' : '';
		}
		else if (key === 'h') {
			return withoutSuffix ? '' : '';
		}
		else {
			return number + ' ' + plural(format[key], +number);
		}
	}

	hooks.defineLocale('be', {
		months : {
			format: '___________'.split('_'),
			standalone: '___________'.split('_')
		},
		monthsShort : '___________'.split('_'),
		weekdays : {
			format: '______'.split('_'),
			standalone: '______'.split('_'),
			isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
		},
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY .',
			LLL : 'D MMMM YYYY ., HH:mm',
			LLLL : 'dddd, D MMMM YYYY ., HH:mm'
		},
		calendar : {
			sameDay: '[ ] LT',
			nextDay: '[ ] LT',
			lastDay: '[ ] LT',
			nextWeek: function () {
				return '[] dddd [] LT';
			},
			lastWeek: function () {
				switch (this.day()) {
					case 0:
					case 3:
					case 5:
					case 6:
						return '[ ] dddd [] LT';
					case 1:
					case 2:
					case 4:
						return '[ ] dddd [] LT';
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s ',
			s : ' ',
			m : relativeTimeWithPlural,
			mm : relativeTimeWithPlural,
			h : relativeTimeWithPlural,
			hh : relativeTimeWithPlural,
			d : '',
			dd : relativeTimeWithPlural,
			M : '',
			MM : relativeTimeWithPlural,
			y : '',
			yy : relativeTimeWithPlural
		},
		meridiemParse: /|||/,
		isPM : function (input) {
			return /^(|)$/.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 12) {
				return '';
			} else if (hour < 17) {
				return '';
			} else {
				return '';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
		ordinal: function (number, period) {
			switch (period) {
				case 'M':
				case 'd':
				case 'DDD':
				case 'w':
				case 'W':
					return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
				case 'D':
					return number + '-';
				default:
					return number;
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('bg', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'D.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY H:mm',
			LLLL : 'dddd, D MMMM YYYY H:mm'
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ ] LT',
			lastWeek : function () {
				switch (this.day()) {
					case 0:
					case 3:
					case 6:
						return '[ ] dddd [] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[ ] dddd [] LT';
				}
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : ' ',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
		ordinal : function (number) {
			var lastDigit = number % 10,
				last2Digits = number % 100;
			if (number === 0) {
				return number + '-';
			} else if (last2Digits === 0) {
				return number + '-';
			} else if (last2Digits > 10 && last2Digits < 20) {
				return number + '-';
			} else if (lastDigit === 1) {
				return number + '-';
			} else if (lastDigit === 2) {
				return number + '-';
			} else if (lastDigit === 7 || lastDigit === 8) {
				return number + '-';
			} else {
				return number + '-';
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('bm', {
		months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
		monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
		weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
		weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
		weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'MMMM [tile] D [san] YYYY',
			LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',
			LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
		},
		calendar : {
			sameDay : '[Bi lr] LT',
			nextDay : '[Sini lr] LT',
			nextWeek : 'dddd [don lr] LT',
			lastDay : '[Kunu lr] LT',
			lastWeek : 'dddd [tmnen lr] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s kn',
			past : 'a b %s b',
			s : 'sanga dama dama',
			ss : 'sekondi %d',
			m : 'miniti kelen',
			mm : 'miniti %d',
			h : 'lr kelen',
			hh : 'lr %d',
			d : 'tile kelen',
			dd : 'tile %d',
			M : 'kalo kelen',
			MM : 'kalo %d',
			y : 'san kelen',
			yy : 'san %d'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$3 = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$2 = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('bn', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm ',
			LTS : 'A h:mm:ss ',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm ',
			LLLL : 'dddd, D MMMM YYYY, A h:mm '
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$2[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$3[match];
			});
		},
		meridiemParse: /||||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if ((meridiem === '' && hour >= 4) ||
				(meridiem === '' && hour < 5) ||
				meridiem === '') {
				return hour + 12;
			} else {
				return hour;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$4 = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$3 = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('bo', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm',
			LTS : 'A h:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm',
			LLLL : 'dddd, D MMMM YYYY, A h:mm'
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : '[], LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : '',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$3[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$4[match];
			});
		},
		meridiemParse: /||||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if ((meridiem === '' && hour >= 4) ||
				(meridiem === '' && hour < 5) ||
				meridiem === '') {
				return hour + 12;
			} else {
				return hour;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function relativeTimeWithMutation(number, withoutSuffix, key) {
		var format = {
			'mm': 'munutenn',
			'MM': 'miz',
			'dd': 'devezh'
		};
		return number + ' ' + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
		switch (lastNumber(number)) {
			case 1:
			case 3:
			case 4:
			case 5:
			case 9:
				return number + ' bloaz';
			default:
				return number + ' vloaz';
		}
	}
	function lastNumber(number) {
		if (number > 9) {
			return lastNumber(number % 10);
		}
		return number;
	}
	function mutation(text, number) {
		if (number === 2) {
			return softMutation(text);
		}
		return text;
	}
	function softMutation(text) {
		var mutationTable = {
			'm': 'v',
			'b': 'v',
			'd': 'z'
		};
		if (mutationTable[text.charAt(0)] === undefined) {
			return text;
		}
		return mutationTable[text.charAt(0)] + text.substring(1);
	}

	hooks.defineLocale('br', {
		months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
		monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
		weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
		weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
		weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'h[e]mm A',
			LTS : 'h[e]mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D [a viz] MMMM YYYY',
			LLL : 'D [a viz] MMMM YYYY h[e]mm A',
			LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
		},
		calendar : {
			sameDay : '[Hiziv da] LT',
			nextDay : '[Warc\'hoazh da] LT',
			nextWeek : 'dddd [da] LT',
			lastDay : '[Dec\'h da] LT',
			lastWeek : 'dddd [paset da] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'a-benn %s',
			past : '%s \'zo',
			s : 'un nebeud segondenno',
			ss : '%d eilenn',
			m : 'ur vunutenn',
			mm : relativeTimeWithMutation,
			h : 'un eur',
			hh : '%d eur',
			d : 'un devezh',
			dd : relativeTimeWithMutation,
			M : 'ur miz',
			MM : relativeTimeWithMutation,
			y : 'ur bloaz',
			yy : specialMutationForYears
		},
		dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
		ordinal : function (number) {
			var output = (number === 1) ? 'a' : 'vet';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function translate(number, withoutSuffix, key) {
		var result = number + ' ';
		switch (key) {
			case 'ss':
				if (number === 1) {
					result += 'sekunda';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'sekunde';
				} else {
					result += 'sekundi';
				}
				return result;
			case 'm':
				return withoutSuffix ? 'jedna minuta' : 'jedne minute';
			case 'mm':
				if (number === 1) {
					result += 'minuta';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'minute';
				} else {
					result += 'minuta';
				}
				return result;
			case 'h':
				return withoutSuffix ? 'jedan sat' : 'jednog sata';
			case 'hh':
				if (number === 1) {
					result += 'sat';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'sata';
				} else {
					result += 'sati';
				}
				return result;
			case 'dd':
				if (number === 1) {
					result += 'dan';
				} else {
					result += 'dana';
				}
				return result;
			case 'MM':
				if (number === 1) {
					result += 'mjesec';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'mjeseca';
				} else {
					result += 'mjeseci';
				}
				return result;
			case 'yy':
				if (number === 1) {
					result += 'godina';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'godine';
				} else {
					result += 'godina';
				}
				return result;
		}
	}

	hooks.defineLocale('bs', {
		months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
		monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
		monthsParseExact: true,
		weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
		weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
		weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY H:mm',
			LLLL : 'dddd, D. MMMM YYYY H:mm'
		},
		calendar : {
			sameDay  : '[danas u] LT',
			nextDay  : '[sutra u] LT',
			nextWeek : function () {
				switch (this.day()) {
					case 0:
						return '[u] [nedjelju] [u] LT';
					case 3:
						return '[u] [srijedu] [u] LT';
					case 6:
						return '[u] [subotu] [u] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[u] dddd [u] LT';
				}
			},
			lastDay  : '[juer u] LT',
			lastWeek : function () {
				switch (this.day()) {
					case 0:
					case 3:
						return '[prolu] dddd [u] LT';
					case 6:
						return '[prole] [subote] [u] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[proli] dddd [u] LT';
				}
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'za %s',
			past   : 'prije %s',
			s      : 'par sekundi',
			ss     : translate,
			m      : translate,
			mm     : translate,
			h      : translate,
			hh     : translate,
			d      : 'dan',
			dd     : translate,
			M      : 'mjesec',
			MM     : translate,
			y      : 'godinu',
			yy     : translate
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ca', {
		months : {
			standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
			format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
			isFormat: /D[oD]?(\s)+MMMM/
		},
		monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
		monthsParseExact : true,
		weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
		weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
		weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM [de] YYYY',
			ll : 'D MMM YYYY',
			LLL : 'D MMMM [de] YYYY [a les] H:mm',
			lll : 'D MMM YYYY, H:mm',
			LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
			llll : 'ddd D MMM YYYY, H:mm'
		},
		calendar : {
			sameDay : function () {
				return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
			},
			nextDay : function () {
				return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
			},
			nextWeek : function () {
				return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
			},
			lastDay : function () {
				return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
			},
			lastWeek : function () {
				return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'd\'aqu %s',
			past : 'fa %s',
			s : 'uns segons',
			ss : '%d segons',
			m : 'un minut',
			mm : '%d minuts',
			h : 'una hora',
			hh : '%d hores',
			d : 'un dia',
			dd : '%d dies',
			M : 'un mes',
			MM : '%d mesos',
			y : 'un any',
			yy : '%d anys'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
		ordinal : function (number, period) {
			var output = (number === 1) ? 'r' :
				(number === 2) ? 'n' :
					(number === 3) ? 'r' :
						(number === 4) ? 't' : '';
			if (period === 'w' || period === 'W') {
				output = 'a';
			}
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var months$3 = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
		monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');

	var monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i];
	// NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
	// Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
	var monthsRegex$1 = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

	function plural$1(n) {
		return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	}
	function translate$1(number, withoutSuffix, key, isFuture) {
		var result = number + ' ';
		switch (key) {
			case 's':  // a few seconds / in a few seconds / a few seconds ago
				return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
			case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
				if (withoutSuffix || isFuture) {
					return result + (plural$1(number) ? 'sekundy' : 'sekund');
				} else {
					return result + 'sekundami';
				}
				break;
			case 'm':  // a minute / in a minute / a minute ago
				return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
			case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
				if (withoutSuffix || isFuture) {
					return result + (plural$1(number) ? 'minuty' : 'minut');
				} else {
					return result + 'minutami';
				}
				break;
			case 'h':  // an hour / in an hour / an hour ago
				return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
			case 'hh': // 9 hours / in 9 hours / 9 hours ago
				if (withoutSuffix || isFuture) {
					return result + (plural$1(number) ? 'hodiny' : 'hodin');
				} else {
					return result + 'hodinami';
				}
				break;
			case 'd':  // a day / in a day / a day ago
				return (withoutSuffix || isFuture) ? 'den' : 'dnem';
			case 'dd': // 9 days / in 9 days / 9 days ago
				if (withoutSuffix || isFuture) {
					return result + (plural$1(number) ? 'dny' : 'dn');
				} else {
					return result + 'dny';
				}
				break;
			case 'M':  // a month / in a month / a month ago
				return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
			case 'MM': // 9 months / in 9 months / 9 months ago
				if (withoutSuffix || isFuture) {
					return result + (plural$1(number) ? 'msce' : 'msc');
				} else {
					return result + 'msci';
				}
				break;
			case 'y':  // a year / in a year / a year ago
				return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
			case 'yy': // 9 years / in 9 years / 9 years ago
				if (withoutSuffix || isFuture) {
					return result + (plural$1(number) ? 'roky' : 'let');
				} else {
					return result + 'lety';
				}
				break;
		}
	}

	hooks.defineLocale('cs', {
		months : months$3,
		monthsShort : monthsShort,
		monthsRegex : monthsRegex$1,
		monthsShortRegex : monthsRegex$1,
		// NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
		// Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
		monthsStrictRegex : /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
		monthsShortStrictRegex : /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
		monthsParse : monthsParse,
		longMonthsParse : monthsParse,
		shortMonthsParse : monthsParse,
		weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
		weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
		weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
		longDateFormat : {
			LT: 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY H:mm',
			LLLL : 'dddd D. MMMM YYYY H:mm',
			l : 'D. M. YYYY'
		},
		calendar : {
			sameDay: '[dnes v] LT',
			nextDay: '[ztra v] LT',
			nextWeek: function () {
				switch (this.day()) {
					case 0:
						return '[v nedli v] LT';
					case 1:
					case 2:
						return '[v] dddd [v] LT';
					case 3:
						return '[ve stedu v] LT';
					case 4:
						return '[ve tvrtek v] LT';
					case 5:
						return '[v ptek v] LT';
					case 6:
						return '[v sobotu v] LT';
				}
			},
			lastDay: '[vera v] LT',
			lastWeek: function () {
				switch (this.day()) {
					case 0:
						return '[minulou nedli v] LT';
					case 1:
					case 2:
						return '[minul] dddd [v] LT';
					case 3:
						return '[minulou stedu v] LT';
					case 4:
					case 5:
						return '[minul] dddd [v] LT';
					case 6:
						return '[minulou sobotu v] LT';
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : 'za %s',
			past : 'ped %s',
			s : translate$1,
			ss : translate$1,
			m : translate$1,
			mm : translate$1,
			h : translate$1,
			hh : translate$1,
			d : translate$1,
			dd : translate$1,
			M : translate$1,
			MM : translate$1,
			y : translate$1,
			yy : translate$1
		},
		dayOfMonthOrdinalParse : /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('cv', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD-MM-YYYY',
			LL : 'YYYY [] MMMM [] D[-]',
			LLL : 'YYYY [] MMMM [] D[-], HH:mm',
			LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
		},
		calendar : {
			sameDay: '[] LT []',
			nextDay: '[] LT []',
			lastDay: '[] LT []',
			nextWeek: '[] dddd LT []',
			lastWeek: '[] dddd LT []',
			sameElse: 'L'
		},
		relativeTime : {
			future : function (output) {
				var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
				return output + affix;
			},
			past : '%s ',
			s : '- ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}-/,
		ordinal : '%d-',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('cy', {
		months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
		monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
		weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
		weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
		weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
		weekdaysParseExact : true,
		// time formats are the same as en-gb
		longDateFormat: {
			LT: 'HH:mm',
			LTS : 'HH:mm:ss',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY HH:mm',
			LLLL: 'dddd, D MMMM YYYY HH:mm'
		},
		calendar: {
			sameDay: '[Heddiw am] LT',
			nextDay: '[Yfory am] LT',
			nextWeek: 'dddd [am] LT',
			lastDay: '[Ddoe am] LT',
			lastWeek: 'dddd [diwethaf am] LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: 'mewn %s',
			past: '%s yn l',
			s: 'ychydig eiliadau',
			ss: '%d eiliad',
			m: 'munud',
			mm: '%d munud',
			h: 'awr',
			hh: '%d awr',
			d: 'diwrnod',
			dd: '%d diwrnod',
			M: 'mis',
			MM: '%d mis',
			y: 'blwyddyn',
			yy: '%d flynedd'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
		// traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
		ordinal: function (number) {
			var b = number,
				output = '',
				lookup = [
					'', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
					'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
				];
			if (b > 20) {
				if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
					output = 'fed'; // not 30ain, 70ain or 90ain
				} else {
					output = 'ain';
				}
			} else if (b > 0) {
				output = lookup[b];
			}
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('da', {
		months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
		monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
		weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
		weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
		weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY HH:mm',
			LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
		},
		calendar : {
			sameDay : '[i dag kl.] LT',
			nextDay : '[i morgen kl.] LT',
			nextWeek : 'p dddd [kl.] LT',
			lastDay : '[i gr kl.] LT',
			lastWeek : '[i] dddd[s kl.] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'om %s',
			past : '%s siden',
			s : 'f sekunder',
			ss : '%d sekunder',
			m : 'et minut',
			mm : '%d minutter',
			h : 'en time',
			hh : '%d timer',
			d : 'en dag',
			dd : '%d dage',
			M : 'en mned',
			MM : '%d mneder',
			y : 'et r',
			yy : '%d r'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
		var format = {
			'm': ['eine Minute', 'einer Minute'],
			'h': ['eine Stunde', 'einer Stunde'],
			'd': ['ein Tag', 'einem Tag'],
			'dd': [number + ' Tage', number + ' Tagen'],
			'M': ['ein Monat', 'einem Monat'],
			'MM': [number + ' Monate', number + ' Monaten'],
			'y': ['ein Jahr', 'einem Jahr'],
			'yy': [number + ' Jahre', number + ' Jahren']
		};
		return withoutSuffix ? format[key][0] : format[key][1];
	}

	hooks.defineLocale('de-at', {
		months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
		monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
		monthsParseExact : true,
		weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
		weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
		weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY HH:mm',
			LLLL : 'dddd, D. MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[heute um] LT [Uhr]',
			sameElse: 'L',
			nextDay: '[morgen um] LT [Uhr]',
			nextWeek: 'dddd [um] LT [Uhr]',
			lastDay: '[gestern um] LT [Uhr]',
			lastWeek: '[letzten] dddd [um] LT [Uhr]'
		},
		relativeTime : {
			future : 'in %s',
			past : 'vor %s',
			s : 'ein paar Sekunden',
			ss : '%d Sekunden',
			m : processRelativeTime,
			mm : '%d Minuten',
			h : processRelativeTime,
			hh : '%d Stunden',
			d : processRelativeTime,
			dd : processRelativeTime,
			M : processRelativeTime,
			MM : processRelativeTime,
			y : processRelativeTime,
			yy : processRelativeTime
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
		var format = {
			'm': ['eine Minute', 'einer Minute'],
			'h': ['eine Stunde', 'einer Stunde'],
			'd': ['ein Tag', 'einem Tag'],
			'dd': [number + ' Tage', number + ' Tagen'],
			'M': ['ein Monat', 'einem Monat'],
			'MM': [number + ' Monate', number + ' Monaten'],
			'y': ['ein Jahr', 'einem Jahr'],
			'yy': [number + ' Jahre', number + ' Jahren']
		};
		return withoutSuffix ? format[key][0] : format[key][1];
	}

	hooks.defineLocale('de-ch', {
		months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
		monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
		monthsParseExact : true,
		weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
		weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
		weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY HH:mm',
			LLLL : 'dddd, D. MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[heute um] LT [Uhr]',
			sameElse: 'L',
			nextDay: '[morgen um] LT [Uhr]',
			nextWeek: 'dddd [um] LT [Uhr]',
			lastDay: '[gestern um] LT [Uhr]',
			lastWeek: '[letzten] dddd [um] LT [Uhr]'
		},
		relativeTime : {
			future : 'in %s',
			past : 'vor %s',
			s : 'ein paar Sekunden',
			ss : '%d Sekunden',
			m : processRelativeTime$1,
			mm : '%d Minuten',
			h : processRelativeTime$1,
			hh : '%d Stunden',
			d : processRelativeTime$1,
			dd : processRelativeTime$1,
			M : processRelativeTime$1,
			MM : processRelativeTime$1,
			y : processRelativeTime$1,
			yy : processRelativeTime$1
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
		var format = {
			'm': ['eine Minute', 'einer Minute'],
			'h': ['eine Stunde', 'einer Stunde'],
			'd': ['ein Tag', 'einem Tag'],
			'dd': [number + ' Tage', number + ' Tagen'],
			'M': ['ein Monat', 'einem Monat'],
			'MM': [number + ' Monate', number + ' Monaten'],
			'y': ['ein Jahr', 'einem Jahr'],
			'yy': [number + ' Jahre', number + ' Jahren']
		};
		return withoutSuffix ? format[key][0] : format[key][1];
	}

	hooks.defineLocale('de', {
		months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
		monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
		monthsParseExact : true,
		weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
		weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
		weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY HH:mm',
			LLLL : 'dddd, D. MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[heute um] LT [Uhr]',
			sameElse: 'L',
			nextDay: '[morgen um] LT [Uhr]',
			nextWeek: 'dddd [um] LT [Uhr]',
			lastDay: '[gestern um] LT [Uhr]',
			lastWeek: '[letzten] dddd [um] LT [Uhr]'
		},
		relativeTime : {
			future : 'in %s',
			past : 'vor %s',
			s : 'ein paar Sekunden',
			ss : '%d Sekunden',
			m : processRelativeTime$2,
			mm : '%d Minuten',
			h : processRelativeTime$2,
			hh : '%d Stunden',
			d : processRelativeTime$2,
			dd : processRelativeTime$2,
			M : processRelativeTime$2,
			MM : processRelativeTime$2,
			y : processRelativeTime$2,
			yy : processRelativeTime$2
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var months$4 = [
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		''
	], weekdays = [
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];

	hooks.defineLocale('dv', {
		months : months$4,
		monthsShort : months$4,
		weekdays : weekdays,
		weekdaysShort : weekdays,
		weekdaysMin : '______'.split('_'),
		longDateFormat : {

			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'D/M/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM : function (input) {
			return '' === input;
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : '',
			ss : 'd% ',
			m : '',
			mm : ' %d',
			h : '',
			hh : ' %d',
			d : '',
			dd : ' %d',
			M : '',
			MM : ' %d',
			y : '',
			yy : ' %d'
		},
		preparse: function (string) {
			return string.replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/,/g, '');
		},
		week : {
			dow : 7,  // Sunday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('el', {
		monthsNominativeEl : '___________'.split('_'),
		monthsGenitiveEl : '___________'.split('_'),
		months : function (momentToFormat, format) {
			if (!momentToFormat) {
				return this._monthsNominativeEl;
			} else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
				return this._monthsGenitiveEl[momentToFormat.month()];
			} else {
				return this._monthsNominativeEl[momentToFormat.month()];
			}
		},
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		meridiem : function (hours, minutes, isLower) {
			if (hours > 11) {
				return isLower ? '' : '';
			} else {
				return isLower ? '' : '';
			}
		},
		isPM : function (input) {
			return ((input + '').toLowerCase()[0] === '');
		},
		meridiemParse : /[]\.??\.?/i,
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY h:mm A',
			LLLL : 'dddd, D MMMM YYYY h:mm A'
		},
		calendarEl : {
			sameDay : '[ {}] LT',
			nextDay : '[ {}] LT',
			nextWeek : 'dddd [{}] LT',
			lastDay : '[ {}] LT',
			lastWeek : function () {
				switch (this.day()) {
					case 6:
						return '[ ] dddd [{}] LT';
					default:
						return '[ ] dddd [{}] LT';
				}
			},
			sameElse : 'L'
		},
		calendar : function (key, mom) {
			var output = this._calendarEl[key],
				hours = mom && mom.hours();
			if (isFunction(output)) {
				output = output.apply(mom);
			}
			return output.replace('{}', (hours % 12 === 1 ? '' : ''));
		},
		relativeTime : {
			future : ' %s',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal: '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4st is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-SG', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			ss : '%d seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-au', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY h:mm A',
			LLLL : 'dddd, D MMMM YYYY h:mm A'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			ss : '%d seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-ca', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'YYYY-MM-DD',
			LL : 'MMMM D, YYYY',
			LLL : 'MMMM D, YYYY h:mm A',
			LLLL : 'dddd, MMMM D, YYYY h:mm A'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			ss : '%d seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-gb', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			ss : '%d seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-ie', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			ss : '%d seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-il', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('en-nz', {
		months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY h:mm A',
			LLLL : 'dddd, D MMMM YYYY h:mm A'
		},
		calendar : {
			sameDay : '[Today at] LT',
			nextDay : '[Tomorrow at] LT',
			nextWeek : 'dddd [at] LT',
			lastDay : '[Yesterday at] LT',
			lastWeek : '[Last] dddd [at] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'in %s',
			past : '%s ago',
			s : 'a few seconds',
			ss : '%d seconds',
			m : 'a minute',
			mm : '%d minutes',
			h : 'an hour',
			hh : '%d hours',
			d : 'a day',
			dd : '%d days',
			M : 'a month',
			MM : '%d months',
			y : 'a year',
			yy : '%d years'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('eo', {
		months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
		monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
		weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
		weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
		weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY-MM-DD',
			LL : 'D[-a de] MMMM, YYYY',
			LLL : 'D[-a de] MMMM, YYYY HH:mm',
			LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
		},
		meridiemParse: /[ap]\.t\.m/i,
		isPM: function (input) {
			return input.charAt(0).toLowerCase() === 'p';
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours > 11) {
				return isLower ? 'p.t.m.' : 'P.T.M.';
			} else {
				return isLower ? 'a.t.m.' : 'A.T.M.';
			}
		},
		calendar : {
			sameDay : '[Hodia je] LT',
			nextDay : '[Morga je] LT',
			nextWeek : 'dddd [je] LT',
			lastDay : '[Hiera je] LT',
			lastWeek : '[pasinta] dddd [je] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'post %s',
			past : 'anta %s',
			s : 'sekundoj',
			ss : '%d sekundoj',
			m : 'minuto',
			mm : '%d minutoj',
			h : 'horo',
			hh : '%d horoj',
			d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
			dd : '%d tagoj',
			M : 'monato',
			MM : '%d monatoj',
			y : 'jaro',
			yy : '%d jaroj'
		},
		dayOfMonthOrdinalParse: /\d{1,2}a/,
		ordinal : '%da',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
		monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var monthsParse$1 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex$2 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	hooks.defineLocale('es-do', {
		months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
		monthsShort : function (m, format) {
			if (!m) {
				return monthsShortDot;
			} else if (/-MMM-/.test(format)) {
				return monthsShort$1[m.month()];
			} else {
				return monthsShortDot[m.month()];
			}
		},
		monthsRegex: monthsRegex$2,
		monthsShortRegex: monthsRegex$2,
		monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
		monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
		monthsParse: monthsParse$1,
		longMonthsParse: monthsParse$1,
		shortMonthsParse: monthsParse$1,
		weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
		weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
		weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D [de] MMMM [de] YYYY',
			LLL : 'D [de] MMMM [de] YYYY h:mm A',
			LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
		},
		calendar : {
			sameDay : function () {
				return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextDay : function () {
				return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextWeek : function () {
				return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			lastDay : function () {
				return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			lastWeek : function () {
				return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'en %s',
			past : 'hace %s',
			s : 'unos segundos',
			ss : '%d segundos',
			m : 'un minuto',
			mm : '%d minutos',
			h : 'una hora',
			hh : '%d horas',
			d : 'un da',
			dd : '%d das',
			M : 'un mes',
			MM : '%d meses',
			y : 'un ao',
			yy : '%d aos'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
		monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var monthsParse$2 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	hooks.defineLocale('es-us', {
		months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
		monthsShort : function (m, format) {
			if (!m) {
				return monthsShortDot$1;
			} else if (/-MMM-/.test(format)) {
				return monthsShort$2[m.month()];
			} else {
				return monthsShortDot$1[m.month()];
			}
		},
		monthsRegex: monthsRegex$3,
		monthsShortRegex: monthsRegex$3,
		monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
		monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
		monthsParse: monthsParse$2,
		longMonthsParse: monthsParse$2,
		shortMonthsParse: monthsParse$2,
		weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
		weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
		weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'MM/DD/YYYY',
			LL : 'D [de] MMMM [de] YYYY',
			LLL : 'D [de] MMMM [de] YYYY h:mm A',
			LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
		},
		calendar : {
			sameDay : function () {
				return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextDay : function () {
				return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextWeek : function () {
				return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			lastDay : function () {
				return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			lastWeek : function () {
				return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'en %s',
			past : 'hace %s',
			s : 'unos segundos',
			ss : '%d segundos',
			m : 'un minuto',
			mm : '%d minutos',
			h : 'una hora',
			hh : '%d horas',
			d : 'un da',
			dd : '%d das',
			M : 'un mes',
			MM : '%d meses',
			y : 'un ao',
			yy : '%d aos'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsShortDot$2 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
		monthsShort$3 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var monthsParse$3 = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
	var monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

	hooks.defineLocale('es', {
		months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
		monthsShort : function (m, format) {
			if (!m) {
				return monthsShortDot$2;
			} else if (/-MMM-/.test(format)) {
				return monthsShort$3[m.month()];
			} else {
				return monthsShortDot$2[m.month()];
			}
		},
		monthsRegex : monthsRegex$4,
		monthsShortRegex : monthsRegex$4,
		monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
		monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
		monthsParse : monthsParse$3,
		longMonthsParse : monthsParse$3,
		shortMonthsParse : monthsParse$3,
		weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
		weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
		weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D [de] MMMM [de] YYYY',
			LLL : 'D [de] MMMM [de] YYYY H:mm',
			LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
		},
		calendar : {
			sameDay : function () {
				return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextDay : function () {
				return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextWeek : function () {
				return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			lastDay : function () {
				return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			lastWeek : function () {
				return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'en %s',
			past : 'hace %s',
			s : 'unos segundos',
			ss : '%d segundos',
			m : 'un minuto',
			mm : '%d minutos',
			h : 'una hora',
			hh : '%d horas',
			d : 'un da',
			dd : '%d das',
			M : 'un mes',
			MM : '%d meses',
			y : 'un ao',
			yy : '%d aos'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
		var format = {
			's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
			'ss': [number + 'sekundi', number + 'sekundit'],
			'm' : ['he minuti', 'ks minut'],
			'mm': [number + ' minuti', number + ' minutit'],
			'h' : ['he tunni', 'tund aega', 'ks tund'],
			'hh': [number + ' tunni', number + ' tundi'],
			'd' : ['he peva', 'ks pev'],
			'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
			'MM': [number + ' kuu', number + ' kuud'],
			'y' : ['he aasta', 'aasta', 'ks aasta'],
			'yy': [number + ' aasta', number + ' aastat']
		};
		if (withoutSuffix) {
			return format[key][2] ? format[key][2] : format[key][1];
		}
		return isFuture ? format[key][0] : format[key][1];
	}

	hooks.defineLocale('et', {
		months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
		monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
		weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
		weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
		weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
		longDateFormat : {
			LT   : 'H:mm',
			LTS : 'H:mm:ss',
			L    : 'DD.MM.YYYY',
			LL   : 'D. MMMM YYYY',
			LLL  : 'D. MMMM YYYY H:mm',
			LLLL : 'dddd, D. MMMM YYYY H:mm'
		},
		calendar : {
			sameDay  : '[Tna,] LT',
			nextDay  : '[Homme,] LT',
			nextWeek : '[Jrgmine] dddd LT',
			lastDay  : '[Eile,] LT',
			lastWeek : '[Eelmine] dddd LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s prast',
			past   : '%s tagasi',
			s      : processRelativeTime$3,
			ss     : processRelativeTime$3,
			m      : processRelativeTime$3,
			mm     : processRelativeTime$3,
			h      : processRelativeTime$3,
			hh     : processRelativeTime$3,
			d      : processRelativeTime$3,
			dd     : '%d peva',
			M      : processRelativeTime$3,
			MM     : processRelativeTime$3,
			y      : processRelativeTime$3,
			yy     : processRelativeTime$3
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('eu', {
		months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
		monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
		monthsParseExact : true,
		weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
		weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
		weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY-MM-DD',
			LL : 'YYYY[ko] MMMM[ren] D[a]',
			LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
			LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
			l : 'YYYY-M-D',
			ll : 'YYYY[ko] MMM D[a]',
			lll : 'YYYY[ko] MMM D[a] HH:mm',
			llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
		},
		calendar : {
			sameDay : '[gaur] LT[etan]',
			nextDay : '[bihar] LT[etan]',
			nextWeek : 'dddd LT[etan]',
			lastDay : '[atzo] LT[etan]',
			lastWeek : '[aurreko] dddd LT[etan]',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s barru',
			past : 'duela %s',
			s : 'segundo batzuk',
			ss : '%d segundo',
			m : 'minutu bat',
			mm : '%d minutu',
			h : 'ordu bat',
			hh : '%d ordu',
			d : 'egun bat',
			dd : '%d egun',
			M : 'hilabete bat',
			MM : '%d hilabete',
			y : 'urte bat',
			yy : '%d urte'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$5 = {
		'1': '',
		'2': '',
		'3': '',
		'4': '',
		'5': '',
		'6': '',
		'7': '',
		'8': '',
		'9': '',
		'0': ''
	}, numberMap$4 = {
		'': '1',
		'': '2',
		'': '3',
		'': '4',
		'': '5',
		'': '6',
		'': '7',
		'': '8',
		'': '9',
		'': '0'
	};

	hooks.defineLocale('fa', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '\u200c__\u200c__\u200c__'.split('_'),
		weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		meridiemParse: /  |  /,
		isPM: function (input) {
			return /  /.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '  ';
			} else {
				return '  ';
			}
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ ] LT',
			lastWeek : 'dddd [] [] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s ',
			s : ' ',
			ss : ' d%',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[-]/g, function (match) {
				return numberMap$4[match];
			}).replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$5[match];
			}).replace(/,/g, '');
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12 // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
		numbersFuture = [
			'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
			numbersPast[7], numbersPast[8], numbersPast[9]
		];
	function translate$2(number, withoutSuffix, key, isFuture) {
		var result = '';
		switch (key) {
			case 's':
				return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
			case 'ss':
				return isFuture ? 'sekunnin' : 'sekuntia';
			case 'm':
				return isFuture ? 'minuutin' : 'minuutti';
			case 'mm':
				result = isFuture ? 'minuutin' : 'minuuttia';
				break;
			case 'h':
				return isFuture ? 'tunnin' : 'tunti';
			case 'hh':
				result = isFuture ? 'tunnin' : 'tuntia';
				break;
			case 'd':
				return isFuture ? 'pivn' : 'piv';
			case 'dd':
				result = isFuture ? 'pivn' : 'piv';
				break;
			case 'M':
				return isFuture ? 'kuukauden' : 'kuukausi';
			case 'MM':
				result = isFuture ? 'kuukauden' : 'kuukautta';
				break;
			case 'y':
				return isFuture ? 'vuoden' : 'vuosi';
			case 'yy':
				result = isFuture ? 'vuoden' : 'vuotta';
				break;
		}
		result = verbalNumber(number, isFuture) + ' ' + result;
		return result;
	}
	function verbalNumber(number, isFuture) {
		return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}

	hooks.defineLocale('fi', {
		months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
		monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
		weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
		weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
		weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
		longDateFormat : {
			LT : 'HH.mm',
			LTS : 'HH.mm.ss',
			L : 'DD.MM.YYYY',
			LL : 'Do MMMM[ta] YYYY',
			LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
			LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
			l : 'D.M.YYYY',
			ll : 'Do MMM YYYY',
			lll : 'Do MMM YYYY, [klo] HH.mm',
			llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
		},
		calendar : {
			sameDay : '[tnn] [klo] LT',
			nextDay : '[huomenna] [klo] LT',
			nextWeek : 'dddd [klo] LT',
			lastDay : '[eilen] [klo] LT',
			lastWeek : '[viime] dddd[na] [klo] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s pst',
			past : '%s sitten',
			s : translate$2,
			ss : translate$2,
			m : translate$2,
			mm : translate$2,
			h : translate$2,
			hh : translate$2,
			d : translate$2,
			dd : translate$2,
			M : translate$2,
			MM : translate$2,
			y : translate$2,
			yy : translate$2
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('fo', {
		months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
		monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
		weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
		weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
		weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D. MMMM, YYYY HH:mm'
		},
		calendar : {
			sameDay : '[ dag kl.] LT',
			nextDay : '[ morgin kl.] LT',
			nextWeek : 'dddd [kl.] LT',
			lastDay : '[ gjr kl.] LT',
			lastWeek : '[sstu] dddd [kl] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'um %s',
			past : '%s sani',
			s : 'f sekund',
			ss : '%d sekundir',
			m : 'ein minuttur',
			mm : '%d minuttir',
			h : 'ein tmi',
			hh : '%d tmar',
			d : 'ein dagur',
			dd : '%d dagar',
			M : 'ein mnaur',
			MM : '%d mnair',
			y : 'eitt r',
			yy : '%d r'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('fr-ca', {
		months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
		monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
		monthsParseExact : true,
		weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
		weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
		weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY-MM-DD',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Aujourdhui ] LT',
			nextDay : '[Demain ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[Hier ] LT',
			lastWeek : 'dddd [dernier ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'dans %s',
			past : 'il y a %s',
			s : 'quelques secondes',
			ss : '%d secondes',
			m : 'une minute',
			mm : '%d minutes',
			h : 'une heure',
			hh : '%d heures',
			d : 'un jour',
			dd : '%d jours',
			M : 'un mois',
			MM : '%d mois',
			y : 'un an',
			yy : '%d ans'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
		ordinal : function (number, period) {
			switch (period) {
				// Words with masculine grammatical gender: mois, trimestre, jour
				default:
				case 'M':
				case 'Q':
				case 'D':
				case 'DDD':
				case 'd':
					return number + (number === 1 ? 'er' : 'e');

				// Words with feminine grammatical gender: semaine
				case 'w':
				case 'W':
					return number + (number === 1 ? 're' : 'e');
			}
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('fr-ch', {
		months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
		monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
		monthsParseExact : true,
		weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
		weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
		weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Aujourdhui ] LT',
			nextDay : '[Demain ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[Hier ] LT',
			lastWeek : 'dddd [dernier ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'dans %s',
			past : 'il y a %s',
			s : 'quelques secondes',
			ss : '%d secondes',
			m : 'une minute',
			mm : '%d minutes',
			h : 'une heure',
			hh : '%d heures',
			d : 'un jour',
			dd : '%d jours',
			M : 'un mois',
			MM : '%d mois',
			y : 'un an',
			yy : '%d ans'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
		ordinal : function (number, period) {
			switch (period) {
				// Words with masculine grammatical gender: mois, trimestre, jour
				default:
				case 'M':
				case 'Q':
				case 'D':
				case 'DDD':
				case 'd':
					return number + (number === 1 ? 'er' : 'e');

				// Words with feminine grammatical gender: semaine
				case 'w':
				case 'W':
					return number + (number === 1 ? 're' : 'e');
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('fr', {
		months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
		monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
		monthsParseExact : true,
		weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
		weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
		weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Aujourdhui ] LT',
			nextDay : '[Demain ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[Hier ] LT',
			lastWeek : 'dddd [dernier ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'dans %s',
			past : 'il y a %s',
			s : 'quelques secondes',
			ss : '%d secondes',
			m : 'une minute',
			mm : '%d minutes',
			h : 'une heure',
			hh : '%d heures',
			d : 'un jour',
			dd : '%d jours',
			M : 'un mois',
			MM : '%d mois',
			y : 'un an',
			yy : '%d ans'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
		ordinal : function (number, period) {
			switch (period) {
				// TODO: Return 'e' when day of month > 1. Move this case inside
				// block for masculine words below.
				// See https://github.com/moment/moment/issues/3375
				case 'D':
					return number + (number === 1 ? 'er' : '');

				// Words with masculine grammatical gender: mois, trimestre, jour
				default:
				case 'M':
				case 'Q':
				case 'DDD':
				case 'd':
					return number + (number === 1 ? 'er' : 'e');

				// Words with feminine grammatical gender: semaine
				case 'w':
				case 'W':
					return number + (number === 1 ? 're' : 'e');
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
		monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	hooks.defineLocale('fy', {
		months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
		monthsShort : function (m, format) {
			if (!m) {
				return monthsShortWithDots;
			} else if (/-MMM-/.test(format)) {
				return monthsShortWithoutDots[m.month()];
			} else {
				return monthsShortWithDots[m.month()];
			}
		},
		monthsParseExact : true,
		weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
		weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
		weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD-MM-YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[hjoed om] LT',
			nextDay: '[moarn om] LT',
			nextWeek: 'dddd [om] LT',
			lastDay: '[juster om] LT',
			lastWeek: '[frne] dddd [om] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'oer %s',
			past : '%s lyn',
			s : 'in pear sekonden',
			ss : '%d sekonden',
			m : 'ien mint',
			mm : '%d minuten',
			h : 'ien oere',
			hh : '%d oeren',
			d : 'ien dei',
			dd : '%d dagen',
			M : 'ien moanne',
			MM : '%d moannen',
			y : 'ien jier',
			yy : '%d jierren'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
		ordinal : function (number) {
			return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration


	var months$5 = [
		'Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Mitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deaireadh Fmhair', 'Samhain', 'Nollaig'
	];

	var monthsShort$4 = ['Ean', 'Feab', 'Mrt', 'Aibr', 'Beal', 'Mit', 'Iil', 'Lna', 'Men', 'Deai', 'Samh', 'Noll'];

	var weekdays$1 = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Satharn'];

	var weekdaysShort = ['Dom', 'Lua', 'Mi', 'Ca', 'Da', 'hAo', 'Sat'];

	var weekdaysMin = ['Do', 'Lu', 'M', 'Ce', 'D', 'hA', 'Sa'];

	hooks.defineLocale('ga', {
		months: months$5,
		monthsShort: monthsShort$4,
		monthsParseExact: true,
		weekdays: weekdays$1,
		weekdaysShort: weekdaysShort,
		weekdaysMin: weekdaysMin,
		longDateFormat: {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY HH:mm',
			LLLL: 'dddd, D MMMM YYYY HH:mm'
		},
		calendar: {
			sameDay: '[Inniu ag] LT',
			nextDay: '[Amrach ag] LT',
			nextWeek: 'dddd [ag] LT',
			lastDay: '[Inn aig] LT',
			lastWeek: 'dddd [seo caite] [ag] LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: 'i %s',
			past: '%s  shin',
			s: 'cpla soicind',
			ss: '%d soicind',
			m: 'nimad',
			mm: '%d nimad',
			h: 'uair an chloig',
			hh: '%d uair an chloig',
			d: 'l',
			dd: '%d l',
			M: 'm',
			MM: '%d m',
			y: 'bliain',
			yy: '%d bliain'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
		ordinal: function (number) {
			var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
			return number + output;
		},
		week: {
			dow: 1, // Monday is the first day of the week.
			doy: 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var months$6 = [
		'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
	];

	var monthsShort$5 = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

	var weekdays$2 = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

	var weekdaysShort$1 = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

	var weekdaysMin$1 = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

	hooks.defineLocale('gd', {
		months : months$6,
		monthsShort : monthsShort$5,
		monthsParseExact : true,
		weekdays : weekdays$2,
		weekdaysShort : weekdaysShort$1,
		weekdaysMin : weekdaysMin$1,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[An-diugh aig] LT',
			nextDay : '[A-mireach aig] LT',
			nextWeek : 'dddd [aig] LT',
			lastDay : '[An-d aig] LT',
			lastWeek : 'dddd [seo chaidh] [aig] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'ann an %s',
			past : 'bho chionn %s',
			s : 'beagan diogan',
			ss : '%d diogan',
			m : 'mionaid',
			mm : '%d mionaidean',
			h : 'uair',
			hh : '%d uairean',
			d : 'latha',
			dd : '%d latha',
			M : 'mos',
			MM : '%d mosan',
			y : 'bliadhna',
			yy : '%d bliadhna'
		},
		dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
		ordinal : function (number) {
			var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('gl', {
		months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
		monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
		monthsParseExact: true,
		weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
		weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
		weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D [de] MMMM [de] YYYY',
			LLL : 'D [de] MMMM [de] YYYY H:mm',
			LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
		},
		calendar : {
			sameDay : function () {
				return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextDay : function () {
				return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
			},
			nextWeek : function () {
				return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
			},
			lastDay : function () {
				return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
			},
			lastWeek : function () {
				return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : function (str) {
				if (str.indexOf('un') === 0) {
					return 'n' + str;
				}
				return 'en ' + str;
			},
			past : 'hai %s',
			s : 'uns segundos',
			ss : '%d segundos',
			m : 'un minuto',
			mm : '%d minutos',
			h : 'unha hora',
			hh : '%d horas',
			d : 'un da',
			dd : '%d das',
			M : 'un mes',
			MM : '%d meses',
			y : 'un ano',
			yy : '%d anos'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
		var format = {
			's': ['thodde secondanim', 'thodde second'],
			'ss': [number + ' secondanim', number + ' second'],
			'm': ['eka mintan', 'ek minute'],
			'mm': [number + ' mintanim', number + ' mintam'],
			'h': ['eka voran', 'ek vor'],
			'hh': [number + ' voranim', number + ' voram'],
			'd': ['eka disan', 'ek dis'],
			'dd': [number + ' disanim', number + ' dis'],
			'M': ['eka mhoinean', 'ek mhoino'],
			'MM': [number + ' mhoineanim', number + ' mhoine'],
			'y': ['eka vorsan', 'ek voros'],
			'yy': [number + ' vorsanim', number + ' vorsam']
		};
		return withoutSuffix ? format[key][0] : format[key][1];
	}

	hooks.defineLocale('gom-latn', {
		months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
		monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
		monthsParseExact : true,
		weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
		weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
		weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'A h:mm [vazta]',
			LTS : 'A h:mm:ss [vazta]',
			L : 'DD-MM-YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY A h:mm [vazta]',
			LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
			llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
		},
		calendar : {
			sameDay: '[Aiz] LT',
			nextDay: '[Faleam] LT',
			nextWeek: '[Ieta to] dddd[,] LT',
			lastDay: '[Kal] LT',
			lastWeek: '[Fatlo] dddd[,] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : '%s',
			past : '%s adim',
			s : processRelativeTime$4,
			ss : processRelativeTime$4,
			m : processRelativeTime$4,
			mm : processRelativeTime$4,
			h : processRelativeTime$4,
			hh : processRelativeTime$4,
			d : processRelativeTime$4,
			dd : processRelativeTime$4,
			M : processRelativeTime$4,
			MM : processRelativeTime$4,
			y : processRelativeTime$4,
			yy : processRelativeTime$4
		},
		dayOfMonthOrdinalParse : /\d{1,2}(er)/,
		ordinal : function (number, period) {
			switch (period) {
				// the ordinal 'er' only applies to day of the month
				case 'D':
					return number + 'er';
				default:
				case 'M':
				case 'Q':
				case 'DDD':
				case 'd':
				case 'w':
				case 'W':
					return number;
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		},
		meridiemParse: /rati|sokalli|donparam|sanje/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === 'rati') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === 'sokalli') {
				return hour;
			} else if (meridiem === 'donparam') {
				return hour > 12 ? hour : hour + 12;
			} else if (meridiem === 'sanje') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return 'rati';
			} else if (hour < 12) {
				return 'sokalli';
			} else if (hour < 16) {
				return 'donparam';
			} else if (hour < 20) {
				return 'sanje';
			} else {
				return 'rati';
			}
		}
	});

	//! moment.js locale configuration

	var symbolMap$6 = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$5 = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('gu', {
		months: '___________'.split('_'),
		monthsShort: '._.__.___._._._._._.'.split('_'),
		monthsParseExact: true,
		weekdays: '______'.split('_'),
		weekdaysShort: '______'.split('_'),
		weekdaysMin: '______'.split('_'),
		longDateFormat: {
			LT: 'A h:mm ',
			LTS: 'A h:mm:ss ',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY, A h:mm ',
			LLLL: 'dddd, D MMMM YYYY, A h:mm '
		},
		calendar: {
			sameDay: '[] LT',
			nextDay: '[] LT',
			nextWeek: 'dddd, LT',
			lastDay: '[] LT',
			lastWeek: '[] dddd, LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: '%s ',
			past: '%s ',
			s: ' ',
			ss: '%d ',
			m: ' ',
			mm: '%d ',
			h: ' ',
			hh: '%d ',
			d: ' ',
			dd: '%d ',
			M: ' ',
			MM: '%d ',
			y: ' ',
			yy: '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$5[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$6[match];
			});
		},
		// Gujarati notation for meridiems are quite fuzzy in practice. While there exists
		// a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
		meridiemParse: /|||/,
		meridiemHour: function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem: function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week: {
			dow: 0, // Sunday is the first day of the week.
			doy: 6 // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('he', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D []MMMM YYYY',
			LLL : 'D []MMMM YYYY HH:mm',
			LLLL : 'dddd, D []MMMM YYYY HH:mm',
			l : 'D/M/YYYY',
			ll : 'D MMM YYYY',
			lll : 'D MMM YYYY HH:mm',
			llll : 'ddd, D MMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[ ]LT',
			nextDay : '[ ]LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ ]LT',
			lastWeek : '[] dddd [ ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : ' ',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : function (number) {
				if (number === 2) {
					return '';
				}
				return number + ' ';
			},
			d : '',
			dd : function (number) {
				if (number === 2) {
					return '';
				}
				return number + ' ';
			},
			M : '',
			MM : function (number) {
				if (number === 2) {
					return '';
				}
				return number + ' ';
			},
			y : '',
			yy : function (number) {
				if (number === 2) {
					return '';
				} else if (number % 10 === 0 && number !== 10) {
					return number + ' ';
				}
				return number + ' ';
			}
		},
		meridiemParse: /"|"| | | ||/i,
		isPM : function (input) {
			return /^("| |)$/.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 5) {
				return ' ';
			} else if (hour < 10) {
				return '';
			} else if (hour < 12) {
				return isLower ? '"' : ' ';
			} else if (hour < 18) {
				return isLower ? '"' : ' ';
			} else {
				return '';
			}
		}
	});

	//! moment.js locale configuration

	var symbolMap$7 = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$6 = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('hi', {
		months : '___________'.split('_'),
		monthsShort : '._.__.___._._._._._.'.split('_'),
		monthsParseExact: true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm ',
			LTS : 'A h:mm:ss ',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm ',
			LLLL : 'dddd, D MMMM YYYY, A h:mm '
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : '  ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$6[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$7[match];
			});
		},
		// Hindi notation for meridiems are quite fuzzy in practice. While there exists
		// a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
		meridiemParse: /|||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function translate$3(number, withoutSuffix, key) {
		var result = number + ' ';
		switch (key) {
			case 'ss':
				if (number === 1) {
					result += 'sekunda';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'sekunde';
				} else {
					result += 'sekundi';
				}
				return result;
			case 'm':
				return withoutSuffix ? 'jedna minuta' : 'jedne minute';
			case 'mm':
				if (number === 1) {
					result += 'minuta';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'minute';
				} else {
					result += 'minuta';
				}
				return result;
			case 'h':
				return withoutSuffix ? 'jedan sat' : 'jednog sata';
			case 'hh':
				if (number === 1) {
					result += 'sat';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'sata';
				} else {
					result += 'sati';
				}
				return result;
			case 'dd':
				if (number === 1) {
					result += 'dan';
				} else {
					result += 'dana';
				}
				return result;
			case 'MM':
				if (number === 1) {
					result += 'mjesec';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'mjeseca';
				} else {
					result += 'mjeseci';
				}
				return result;
			case 'yy':
				if (number === 1) {
					result += 'godina';
				} else if (number === 2 || number === 3 || number === 4) {
					result += 'godine';
				} else {
					result += 'godina';
				}
				return result;
		}
	}

	hooks.defineLocale('hr', {
		months : {
			format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
			standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
		},
		monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
		monthsParseExact: true,
		weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
		weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
		weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY H:mm',
			LLLL : 'dddd, D. MMMM YYYY H:mm'
		},
		calendar : {
			sameDay  : '[danas u] LT',
			nextDay  : '[sutra u] LT',
			nextWeek : function () {
				switch (this.day()) {
					case 0:
						return '[u] [nedjelju] [u] LT';
					case 3:
						return '[u] [srijedu] [u] LT';
					case 6:
						return '[u] [subotu] [u] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[u] dddd [u] LT';
				}
			},
			lastDay  : '[juer u] LT',
			lastWeek : function () {
				switch (this.day()) {
					case 0:
					case 3:
						return '[prolu] dddd [u] LT';
					case 6:
						return '[prole] [subote] [u] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[proli] dddd [u] LT';
				}
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'za %s',
			past   : 'prije %s',
			s      : 'par sekundi',
			ss     : translate$3,
			m      : translate$3,
			mm     : translate$3,
			h      : translate$3,
			hh     : translate$3,
			d      : 'dan',
			dd     : translate$3,
			M      : 'mjesec',
			MM     : translate$3,
			y      : 'godinu',
			yy     : translate$3
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	function translate$4(number, withoutSuffix, key, isFuture) {
		var num = number;
		switch (key) {
			case 's':
				return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
			case 'ss':
				return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';
			case 'm':
				return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
			case 'mm':
				return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
			case 'h':
				return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
			case 'hh':
				return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
			case 'd':
				return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
			case 'dd':
				return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
			case 'M':
				return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
			case 'MM':
				return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
			case 'y':
				return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
			case 'yy':
				return num + (isFuture || withoutSuffix ? ' v' : ' ve');
		}
		return '';
	}
	function week(isFuture) {
		return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	}

	hooks.defineLocale('hu', {
		months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
		monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
		weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
		weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
		weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'YYYY.MM.DD.',
			LL : 'YYYY. MMMM D.',
			LLL : 'YYYY. MMMM D. H:mm',
			LLLL : 'YYYY. MMMM D., dddd H:mm'
		},
		meridiemParse: /de|du/i,
		isPM: function (input) {
			return input.charAt(1).toLowerCase() === 'u';
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 12) {
				return isLower === true ? 'de' : 'DE';
			} else {
				return isLower === true ? 'du' : 'DU';
			}
		},
		calendar : {
			sameDay : '[ma] LT[-kor]',
			nextDay : '[holnap] LT[-kor]',
			nextWeek : function () {
				return week.call(this, true);
			},
			lastDay : '[tegnap] LT[-kor]',
			lastWeek : function () {
				return week.call(this, false);
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s mlva',
			past : '%s',
			s : translate$4,
			ss : translate$4,
			m : translate$4,
			mm : translate$4,
			h : translate$4,
			hh : translate$4,
			d : translate$4,
			dd : translate$4,
			M : translate$4,
			MM : translate$4,
			y : translate$4,
			yy : translate$4
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('hy-am', {
		months : {
			format: '___________'.split('_'),
			standalone: '___________'.split('_')
		},
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY .',
			LLL : 'D MMMM YYYY ., HH:mm',
			LLLL : 'dddd, D MMMM YYYY ., HH:mm'
		},
		calendar : {
			sameDay: '[] LT',
			nextDay: '[] LT',
			lastDay: '[] LT',
			nextWeek: function () {
				return 'dddd [ ] LT';
			},
			lastWeek: function () {
				return '[] dddd [ ] LT';
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : '  ',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		meridiemParse: /|||/,
		isPM: function (input) {
			return /^(|)$/.test(input);
		},
		meridiem : function (hour) {
			if (hour < 4) {
				return '';
			} else if (hour < 12) {
				return '';
			} else if (hour < 17) {
				return '';
			} else {
				return '';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
		ordinal: function (number, period) {
			switch (period) {
				case 'DDD':
				case 'w':
				case 'W':
				case 'DDDo':
					if (number === 1) {
						return number + '-';
					}
					return number + '-';
				default:
					return number;
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('id', {
		months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
		weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
		weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
		weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
		longDateFormat : {
			LT : 'HH.mm',
			LTS : 'HH.mm.ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY [pukul] HH.mm',
			LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
		},
		meridiemParse: /pagi|siang|sore|malam/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === 'pagi') {
				return hour;
			} else if (meridiem === 'siang') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === 'sore' || meridiem === 'malam') {
				return hour + 12;
			}
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 11) {
				return 'pagi';
			} else if (hours < 15) {
				return 'siang';
			} else if (hours < 19) {
				return 'sore';
			} else {
				return 'malam';
			}
		},
		calendar : {
			sameDay : '[Hari ini pukul] LT',
			nextDay : '[Besok pukul] LT',
			nextWeek : 'dddd [pukul] LT',
			lastDay : '[Kemarin pukul] LT',
			lastWeek : 'dddd [lalu pukul] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'dalam %s',
			past : '%s yang lalu',
			s : 'beberapa detik',
			ss : '%d detik',
			m : 'semenit',
			mm : '%d menit',
			h : 'sejam',
			hh : '%d jam',
			d : 'sehari',
			dd : '%d hari',
			M : 'sebulan',
			MM : '%d bulan',
			y : 'setahun',
			yy : '%d tahun'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function plural$2(n) {
		if (n % 100 === 11) {
			return true;
		} else if (n % 10 === 1) {
			return false;
		}
		return true;
	}
	function translate$5(number, withoutSuffix, key, isFuture) {
		var result = number + ' ';
		switch (key) {
			case 's':
				return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
			case 'ss':
				if (plural$2(number)) {
					return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
				}
				return result + 'seknda';
			case 'm':
				return withoutSuffix ? 'mnta' : 'mntu';
			case 'mm':
				if (plural$2(number)) {
					return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
				} else if (withoutSuffix) {
					return result + 'mnta';
				}
				return result + 'mntu';
			case 'hh':
				if (plural$2(number)) {
					return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
				}
				return result + 'klukkustund';
			case 'd':
				if (withoutSuffix) {
					return 'dagur';
				}
				return isFuture ? 'dag' : 'degi';
			case 'dd':
				if (plural$2(number)) {
					if (withoutSuffix) {
						return result + 'dagar';
					}
					return result + (isFuture ? 'daga' : 'dgum');
				} else if (withoutSuffix) {
					return result + 'dagur';
				}
				return result + (isFuture ? 'dag' : 'degi');
			case 'M':
				if (withoutSuffix) {
					return 'mnuur';
				}
				return isFuture ? 'mnu' : 'mnui';
			case 'MM':
				if (plural$2(number)) {
					if (withoutSuffix) {
						return result + 'mnuir';
					}
					return result + (isFuture ? 'mnui' : 'mnuum');
				} else if (withoutSuffix) {
					return result + 'mnuur';
				}
				return result + (isFuture ? 'mnu' : 'mnui');
			case 'y':
				return withoutSuffix || isFuture ? 'r' : 'ri';
			case 'yy':
				if (plural$2(number)) {
					return result + (withoutSuffix || isFuture ? 'r' : 'rum');
				}
				return result + (withoutSuffix || isFuture ? 'r' : 'ri');
		}
	}

	hooks.defineLocale('is', {
		months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
		monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
		weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
		weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
		weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY [kl.] H:mm',
			LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
		},
		calendar : {
			sameDay : '[ dag kl.] LT',
			nextDay : '[ morgun kl.] LT',
			nextWeek : 'dddd [kl.] LT',
			lastDay : '[ gr kl.] LT',
			lastWeek : '[sasta] dddd [kl.] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'eftir %s',
			past : 'fyrir %s san',
			s : translate$5,
			ss : translate$5,
			m : translate$5,
			mm : translate$5,
			h : 'klukkustund',
			hh : translate$5,
			d : translate$5,
			dd : translate$5,
			M : translate$5,
			MM : translate$5,
			y : translate$5,
			yy : translate$5
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('it-ch', {
		months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
		monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
		weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
		weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
		weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Oggi alle] LT',
			nextDay: '[Domani alle] LT',
			nextWeek: 'dddd [alle] LT',
			lastDay: '[Ieri alle] LT',
			lastWeek: function () {
				switch (this.day()) {
					case 0:
						return '[la scorsa] dddd [alle] LT';
					default:
						return '[lo scorso] dddd [alle] LT';
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : function (s) {
				return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
			},
			past : '%s fa',
			s : 'alcuni secondi',
			ss : '%d secondi',
			m : 'un minuto',
			mm : '%d minuti',
			h : 'un\'ora',
			hh : '%d ore',
			d : 'un giorno',
			dd : '%d giorni',
			M : 'un mese',
			MM : '%d mesi',
			y : 'un anno',
			yy : '%d anni'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal: '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('it', {
		months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
		monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
		weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
		weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
		weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Oggi alle] LT',
			nextDay: '[Domani alle] LT',
			nextWeek: 'dddd [alle] LT',
			lastDay: '[Ieri alle] LT',
			lastWeek: function () {
				switch (this.day()) {
					case 0:
						return '[la scorsa] dddd [alle] LT';
					default:
						return '[lo scorso] dddd [alle] LT';
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : function (s) {
				return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
			},
			past : '%s fa',
			s : 'alcuni secondi',
			ss : '%d secondi',
			m : 'un minuto',
			mm : '%d minuti',
			h : 'un\'ora',
			hh : '%d ore',
			d : 'un giorno',
			dd : '%d giorni',
			M : 'un mese',
			MM : '%d mesi',
			y : 'un anno',
			yy : '%d anni'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal: '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ja', {
		months : '___________'.split('_'),
		monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY/MM/DD',
			LL : 'YYYYMD',
			LLL : 'YYYYMD HH:mm',
			LLLL : 'YYYYMD dddd HH:mm',
			l : 'YYYY/MM/DD',
			ll : 'YYYYMD',
			lll : 'YYYYMD HH:mm',
			llll : 'YYYYMD(ddd) HH:mm'
		},
		meridiemParse: /|/i,
		isPM : function (input) {
			return input === '';
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : function (now) {
				if (now.week() < this.week()) {
					return '[]dddd LT';
				} else {
					return 'dddd LT';
				}
			},
			lastDay : '[] LT',
			lastWeek : function (now) {
				if (this.week() < now.week()) {
					return '[]dddd LT';
				} else {
					return 'dddd LT';
				}
			},
			sameElse : 'L'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : function (number, period) {
			switch (period) {
				case 'd':
				case 'D':
				case 'DDD':
					return number + '';
				default:
					return number;
			}
		},
		relativeTime : {
			future : '%s',
			past : '%s',
			s : '',
			ss : '%d',
			m : '1',
			mm : '%d',
			h : '1',
			hh : '%d',
			d : '1',
			dd : '%d',
			M : '1',
			MM : '%d',
			y : '1',
			yy : '%d'
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('jv', {
		months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
		monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
		weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
		weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
		weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
		longDateFormat : {
			LT : 'HH.mm',
			LTS : 'HH.mm.ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY [pukul] HH.mm',
			LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
		},
		meridiemParse: /enjing|siyang|sonten|ndalu/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === 'enjing') {
				return hour;
			} else if (meridiem === 'siyang') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === 'sonten' || meridiem === 'ndalu') {
				return hour + 12;
			}
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 11) {
				return 'enjing';
			} else if (hours < 15) {
				return 'siyang';
			} else if (hours < 19) {
				return 'sonten';
			} else {
				return 'ndalu';
			}
		},
		calendar : {
			sameDay : '[Dinten puniko pukul] LT',
			nextDay : '[Mbenjang pukul] LT',
			nextWeek : 'dddd [pukul] LT',
			lastDay : '[Kala wingi pukul] LT',
			lastWeek : 'dddd [kepengker pukul] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'wonten ing %s',
			past : '%s ingkang kepengker',
			s : 'sawetawis detik',
			ss : '%d detik',
			m : 'setunggal menit',
			mm : '%d menit',
			h : 'setunggal jam',
			hh : '%d jam',
			d : 'sedinten',
			dd : '%d dinten',
			M : 'sewulan',
			MM : '%d wulan',
			y : 'setaun',
			yy : '%d taun'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ka', {
		months : {
			standalone: '___________'.split('_'),
			format: '___________'.split('_')
		},
		monthsShort : '___________'.split('_'),
		weekdays : {
			standalone: '______'.split('_'),
			format: '______'.split('_'),
			isFormat: /(|)/
		},
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY h:mm A',
			LLLL : 'dddd, D MMMM YYYY h:mm A'
		},
		calendar : {
			sameDay : '[] LT[-]',
			nextDay : '[] LT[-]',
			lastDay : '[] LT[-]',
			nextWeek : '[] dddd LT[-]',
			lastWeek : '[] dddd LT-',
			sameElse : 'L'
		},
		relativeTime : {
			future : function (s) {
				return (/(|||)/).test(s) ?
					s.replace(/$/, '') :
					s + '';
			},
			past : function (s) {
				if ((/(||||)/).test(s)) {
					return s.replace(/(|)$/, ' ');
				}
				if ((//).test(s)) {
					return s.replace(/$/, ' ');
				}
			},
			s : ' ',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
		ordinal : function (number) {
			if (number === 0) {
				return number;
			}
			if (number === 1) {
				return number + '-';
			}
			if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
				return '-' + number;
			}
			return number + '-';
		},
		week : {
			dow : 1,
			doy : 7
		}
	});

	//! moment.js locale configuration

	var suffixes$1 = {
		0: '-',
		1: '-',
		2: '-',
		3: '-',
		4: '-',
		5: '-',
		6: '-',
		7: '-',
		8: '-',
		9: '-',
		10: '-',
		20: '-',
		30: '-',
		40: '-',
		50: '-',
		60: '-',
		70: '-',
		80: '-',
		90: '-',
		100: '-'
	};

	hooks.defineLocale('kk', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ ] LT',
			lastWeek : '[ ] dddd [] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
		ordinal : function (number) {
			var a = number % 10,
				b = number >= 100 ? 100 : null;
			return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$8 = {
		'1': '',
		'2': '',
		'3': '',
		'4': '',
		'5': '',
		'6': '',
		'7': '',
		'8': '',
		'9': '',
		'0': ''
	}, numberMap$7 = {
		'': '1',
		'': '2',
		'': '3',
		'': '4',
		'': '5',
		'': '6',
		'': '7',
		'': '8',
		'': '9',
		'': '0'
	};

	hooks.defineLocale('km', {
		months: '___________'.split(
			'_'
		),
		monthsShort: '___________'.split(
			'_'
		),
		weekdays: '______'.split('_'),
		weekdaysShort: '______'.split('_'),
		weekdaysMin: '______'.split('_'),
		weekdaysParseExact: true,
		longDateFormat: {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY HH:mm',
			LLLL: 'dddd, D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM: function (input) {
			return input === '';
		},
		meridiem: function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar: {
			sameDay: '[ ] LT',
			nextDay: '[ ] LT',
			nextWeek: 'dddd [] LT',
			lastDay: '[ ] LT',
			lastWeek: 'dddd [] [] LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: '%s',
			past: '%s',
			s: '',
			ss: '%d ',
			m: '',
			mm: '%d ',
			h: '',
			hh: '%d ',
			d: '',
			dd: '%d ',
			M: '',
			MM: '%d ',
			y: '',
			yy: '%d '
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : '%d',
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$7[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$8[match];
			});
		},
		week: {
			dow: 1, // Monday is the first day of the week.
			doy: 4 // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$9 = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$8 = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('kn', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		monthsParseExact: true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm',
			LTS : 'A h:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm',
			LLLL : 'dddd, D MMMM YYYY, A h:mm'
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$8[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$9[match];
			});
		},
		meridiemParse: /|||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}()/,
		ordinal : function (number) {
			return number + '';
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ko', {
		months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
		monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm',
			LTS : 'A h:mm:ss',
			L : 'YYYY.MM.DD.',
			LL : 'YYYY MMMM D',
			LLL : 'YYYY MMMM D A h:mm',
			LLLL : 'YYYY MMMM D dddd A h:mm',
			l : 'YYYY.MM.DD.',
			ll : 'YYYY MMMM D',
			lll : 'YYYY MMMM D A h:mm',
			llll : 'YYYY MMMM D dddd A h:mm'
		},
		calendar : {
			sameDay : ' LT',
			nextDay : ' LT',
			nextWeek : 'dddd LT',
			lastDay : ' LT',
			lastWeek : ' dddd LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d',
			m : '1',
			mm : '%d',
			h : ' ',
			hh : '%d',
			d : '',
			dd : '%d',
			M : ' ',
			MM : '%d',
			y : ' ',
			yy : '%d'
		},
		dayOfMonthOrdinalParse : /\d{1,2}(||)/,
		ordinal : function (number, period) {
			switch (period) {
				case 'd':
				case 'D':
				case 'DDD':
					return number + '';
				case 'M':
					return number + '';
				case 'w':
				case 'W':
					return number + '';
				default:
					return number;
			}
		},
		meridiemParse : /|/,
		isPM : function (token) {
			return token === '';
		},
		meridiem : function (hour, minute, isUpper) {
			return hour < 12 ? '' : '';
		}
	});

	//! moment.js locale configuration

	var symbolMap$a = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		}, numberMap$9 = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		},
		months$7 = [
			' ',
			'',
			'',
			'',
			'',
			'',
			'',
			'',
			'',
			' ',
			' ',
			' '
		];


	hooks.defineLocale('ku', {
		months : months$7,
		monthsShort : months$7,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM: function (input) {
			return //.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ ] LT',
			lastWeek : 'dddd [] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s',
			s : ' ',
			ss : ' %d',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$9[match];
			}).replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$a[match];
			}).replace(/,/g, '');
		},
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12 // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var suffixes$2 = {
		0: '-',
		1: '-',
		2: '-',
		3: '-',
		4: '-',
		5: '-',
		6: '-',
		7: '-',
		8: '-',
		9: '-',
		10: '-',
		20: '-',
		30: '-',
		40: '-',
		50: '-',
		60: '-',
		70: '-',
		80: '-',
		90: '-',
		100: '-'
	};

	hooks.defineLocale('ky', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ ] LT',
			lastWeek : '[ ] dddd [] [] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
		ordinal : function (number) {
			var a = number % 10,
				b = number >= 100 ? 100 : null;
			return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
		var format = {
			'm': ['eng Minutt', 'enger Minutt'],
			'h': ['eng Stonn', 'enger Stonn'],
			'd': ['een Dag', 'engem Dag'],
			'M': ['ee Mount', 'engem Mount'],
			'y': ['ee Joer', 'engem Joer']
		};
		return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
		var number = string.substr(0, string.indexOf(' '));
		if (eifelerRegelAppliesToNumber(number)) {
			return 'a ' + string;
		}
		return 'an ' + string;
	}
	function processPastTime(string) {
		var number = string.substr(0, string.indexOf(' '));
		if (eifelerRegelAppliesToNumber(number)) {
			return 'viru ' + string;
		}
		return 'virun ' + string;
	}
	/**
	 * Returns true if the word before the given number loses the '-n' ending.
	 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
		number = parseInt(number, 10);
		if (isNaN(number)) {
			return false;
		}
		if (number < 0) {
			// Negative Number --> always true
			return true;
		} else if (number < 10) {
			// Only 1 digit
			if (4 <= number && number <= 7) {
				return true;
			}
			return false;
		} else if (number < 100) {
			// 2 digits
			var lastDigit = number % 10, firstDigit = number / 10;
			if (lastDigit === 0) {
				return eifelerRegelAppliesToNumber(firstDigit);
			}
			return eifelerRegelAppliesToNumber(lastDigit);
		} else if (number < 10000) {
			// 3 or 4 digits --> recursively check first digit
			while (number >= 10) {
				number = number / 10;
			}
			return eifelerRegelAppliesToNumber(number);
		} else {
			// Anything larger than 4 digits: recursively check first n-3 digits
			number = number / 1000;
			return eifelerRegelAppliesToNumber(number);
		}
	}

	hooks.defineLocale('lb', {
		months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
		monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
		monthsParseExact : true,
		weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
		weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
		weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
		weekdaysParseExact : true,
		longDateFormat: {
			LT: 'H:mm [Auer]',
			LTS: 'H:mm:ss [Auer]',
			L: 'DD.MM.YYYY',
			LL: 'D. MMMM YYYY',
			LLL: 'D. MMMM YYYY H:mm [Auer]',
			LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
		},
		calendar: {
			sameDay: '[Haut um] LT',
			sameElse: 'L',
			nextDay: '[Muer um] LT',
			nextWeek: 'dddd [um] LT',
			lastDay: '[Gschter um] LT',
			lastWeek: function () {
				// Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
				switch (this.day()) {
					case 2:
					case 4:
						return '[Leschten] dddd [um] LT';
					default:
						return '[Leschte] dddd [um] LT';
				}
			}
		},
		relativeTime : {
			future : processFutureTime,
			past : processPastTime,
			s : 'e puer Sekonnen',
			ss : '%d Sekonnen',
			m : processRelativeTime$5,
			mm : '%d Minutten',
			h : processRelativeTime$5,
			hh : '%d Stonnen',
			d : processRelativeTime$5,
			dd : '%d Deeg',
			M : processRelativeTime$5,
			MM : '%d Mint',
			y : processRelativeTime$5,
			yy : '%d Joer'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal: '%d.',
		week: {
			dow: 1, // Monday is the first day of the week.
			doy: 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('lo', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM: function (input) {
			return input === '';
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : '[]dddd[] LT',
			lastDay : '[] LT',
			lastWeek : '[]dddd[] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s',
			s : '',
			ss : '%d ' ,
			m : '1 ',
			mm : '%d ',
			h : '1 ',
			hh : '%d ',
			d : '1 ',
			dd : '%d ',
			M : '1 ',
			MM : '%d ',
			y : '1 ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /()\d{1,2}/,
		ordinal : function (number) {
			return '' + number;
		}
	});

	//! moment.js locale configuration

	var units = {
		'ss' : 'sekund_sekundi_sekundes',
		'm' : 'minut_minuts_minut',
		'mm': 'minuts_minui_minutes',
		'h' : 'valanda_valandos_valand',
		'hh': 'valandos_valand_valandas',
		'd' : 'diena_dienos_dien',
		'dd': 'dienos_dien_dienas',
		'M' : 'mnuo_mnesio_mnes',
		'MM': 'mnesiai_mnesi_mnesius',
		'y' : 'metai_met_metus',
		'yy': 'metai_met_metus'
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
		if (withoutSuffix) {
			return 'kelios sekunds';
		} else {
			return isFuture ? 'keli sekundi' : 'kelias sekundes';
		}
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
		return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
		return number % 10 === 0 || (number > 10 && number < 20);
	}
	function forms(key) {
		return units[key].split('_');
	}
	function translate$6(number, withoutSuffix, key, isFuture) {
		var result = number + ' ';
		if (number === 1) {
			return result + translateSingular(number, withoutSuffix, key[0], isFuture);
		} else if (withoutSuffix) {
			return result + (special(number) ? forms(key)[1] : forms(key)[0]);
		} else {
			if (isFuture) {
				return result + forms(key)[1];
			} else {
				return result + (special(number) ? forms(key)[1] : forms(key)[2]);
			}
		}
	}
	hooks.defineLocale('lt', {
		months : {
			format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
			standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
			isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
		},
		monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
		weekdays : {
			format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
			standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
			isFormat: /dddd HH:mm/
		},
		weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
		weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY-MM-DD',
			LL : 'YYYY [m.] MMMM D [d.]',
			LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
			LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
			l : 'YYYY-MM-DD',
			ll : 'YYYY [m.] MMMM D [d.]',
			lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
			llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
		},
		calendar : {
			sameDay : '[iandien] LT',
			nextDay : '[Rytoj] LT',
			nextWeek : 'dddd LT',
			lastDay : '[Vakar] LT',
			lastWeek : '[Prajus] dddd LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'po %s',
			past : 'prie %s',
			s : translateSeconds,
			ss : translate$6,
			m : translateSingular,
			mm : translate$6,
			h : translateSingular,
			hh : translate$6,
			d : translateSingular,
			dd : translate$6,
			M : translateSingular,
			MM : translate$6,
			y : translateSingular,
			yy : translate$6
		},
		dayOfMonthOrdinalParse: /\d{1,2}-oji/,
		ordinal : function (number) {
			return number + '-oji';
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var units$1 = {
		'ss': 'sekundes_sekundm_sekunde_sekundes'.split('_'),
		'm': 'mintes_mintm_minte_mintes'.split('_'),
		'mm': 'mintes_mintm_minte_mintes'.split('_'),
		'h': 'stundas_stundm_stunda_stundas'.split('_'),
		'hh': 'stundas_stundm_stunda_stundas'.split('_'),
		'd': 'dienas_dienm_diena_dienas'.split('_'),
		'dd': 'dienas_dienm_diena_dienas'.split('_'),
		'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
		'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
		'y': 'gada_gadiem_gads_gadi'.split('_'),
		'yy': 'gada_gadiem_gads_gadi'.split('_')
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format$1(forms, number, withoutSuffix) {
		if (withoutSuffix) {
			// E.g. "21 minte", "3 mintes".
			return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
		} else {
			// E.g. "21 mintes" as in "pc 21 mintes".
			// E.g. "3 mintm" as in "pc 3 mintm".
			return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
		}
	}
	function relativeTimeWithPlural$1(number, withoutSuffix, key) {
		return number + ' ' + format$1(units$1[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
		return format$1(units$1[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
		return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
	}

	hooks.defineLocale('lv', {
		months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
		monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
		weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
		weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
		weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY.',
			LL : 'YYYY. [gada] D. MMMM',
			LLL : 'YYYY. [gada] D. MMMM, HH:mm',
			LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
		},
		calendar : {
			sameDay : '[odien pulksten] LT',
			nextDay : '[Rt pulksten] LT',
			nextWeek : 'dddd [pulksten] LT',
			lastDay : '[Vakar pulksten] LT',
			lastWeek : '[Pagju] dddd [pulksten] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'pc %s',
			past : 'pirms %s',
			s : relativeSeconds,
			ss : relativeTimeWithPlural$1,
			m : relativeTimeWithSingular,
			mm : relativeTimeWithPlural$1,
			h : relativeTimeWithSingular,
			hh : relativeTimeWithPlural$1,
			d : relativeTimeWithSingular,
			dd : relativeTimeWithPlural$1,
			M : relativeTimeWithSingular,
			MM : relativeTimeWithPlural$1,
			y : relativeTimeWithSingular,
			yy : relativeTimeWithPlural$1
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var translator = {
		words: { //Different grammatical cases
			ss: ['sekund', 'sekunda', 'sekundi'],
			m: ['jedan minut', 'jednog minuta'],
			mm: ['minut', 'minuta', 'minuta'],
			h: ['jedan sat', 'jednog sata'],
			hh: ['sat', 'sata', 'sati'],
			dd: ['dan', 'dana', 'dana'],
			MM: ['mjesec', 'mjeseca', 'mjeseci'],
			yy: ['godina', 'godine', 'godina']
		},
		correctGrammaticalCase: function (number, wordKey) {
			return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
		},
		translate: function (number, withoutSuffix, key) {
			var wordKey = translator.words[key];
			if (key.length === 1) {
				return withoutSuffix ? wordKey[0] : wordKey[1];
			} else {
				return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
			}
		}
	};

	hooks.defineLocale('me', {
		months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
		monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
		monthsParseExact : true,
		weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
		weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
		weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
		weekdaysParseExact : true,
		longDateFormat: {
			LT: 'H:mm',
			LTS : 'H:mm:ss',
			L: 'DD.MM.YYYY',
			LL: 'D. MMMM YYYY',
			LLL: 'D. MMMM YYYY H:mm',
			LLLL: 'dddd, D. MMMM YYYY H:mm'
		},
		calendar: {
			sameDay: '[danas u] LT',
			nextDay: '[sjutra u] LT',

			nextWeek: function () {
				switch (this.day()) {
					case 0:
						return '[u] [nedjelju] [u] LT';
					case 3:
						return '[u] [srijedu] [u] LT';
					case 6:
						return '[u] [subotu] [u] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[u] dddd [u] LT';
				}
			},
			lastDay  : '[jue u] LT',
			lastWeek : function () {
				var lastWeekDays = [
					'[prole] [nedjelje] [u] LT',
					'[prolog] [ponedjeljka] [u] LT',
					'[prolog] [utorka] [u] LT',
					'[prole] [srijede] [u] LT',
					'[prolog] [etvrtka] [u] LT',
					'[prolog] [petka] [u] LT',
					'[prole] [subote] [u] LT'
				];
				return lastWeekDays[this.day()];
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'za %s',
			past   : 'prije %s',
			s      : 'nekoliko sekundi',
			ss     : translator.translate,
			m      : translator.translate,
			mm     : translator.translate,
			h      : translator.translate,
			hh     : translator.translate,
			d      : 'dan',
			dd     : translator.translate,
			M      : 'mjesec',
			MM     : translator.translate,
			y      : 'godinu',
			yy     : translator.translate
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('mi', {
		months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
		monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
		monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
		monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
		monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
		monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
		weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
		weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
		weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
		longDateFormat: {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY [i] HH:mm',
			LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
		},
		calendar: {
			sameDay: '[i teie mahana, i] LT',
			nextDay: '[apopo i] LT',
			nextWeek: 'dddd [i] LT',
			lastDay: '[inanahi i] LT',
			lastWeek: 'dddd [whakamutunga i] LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: 'i roto i %s',
			past: '%s i mua',
			s: 'te hkona ruarua',
			ss: '%d hkona',
			m: 'he meneti',
			mm: '%d meneti',
			h: 'te haora',
			hh: '%d haora',
			d: 'he ra',
			dd: '%d ra',
			M: 'he marama',
			MM: '%d marama',
			y: 'he tau',
			yy: '%d tau'
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal: '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('mk', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : 'e_o_____a'.split('_'),
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'D.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY H:mm',
			LLLL : 'dddd, D MMMM YYYY H:mm'
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : '[] dddd [] LT',
			lastDay : '[ ] LT',
			lastWeek : function () {
				switch (this.day()) {
					case 0:
					case 3:
					case 6:
						return '[] dddd [] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[] dddd [] LT';
				}
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : ' %s',
			s : ' ',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d ',
			M : '',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
		ordinal : function (number) {
			var lastDigit = number % 10,
				last2Digits = number % 100;
			if (number === 0) {
				return number + '-';
			} else if (last2Digits === 0) {
				return number + '-';
			} else if (last2Digits > 10 && last2Digits < 20) {
				return number + '-';
			} else if (lastDigit === 1) {
				return number + '-';
			} else if (lastDigit === 2) {
				return number + '-';
			} else if (lastDigit === 7 || lastDigit === 8) {
				return number + '-';
			} else {
				return number + '-';
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ml', {
		months : '___________'.split('_'),
		monthsShort : '._._._.___._._._._._.'.split('_'),
		monthsParseExact : true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm -',
			LTS : 'A h:mm:ss -',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm -',
			LLLL : 'dddd, D MMMM YYYY, A h:mm -'
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		meridiemParse: /|| ||/i,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if ((meridiem === '' && hour >= 4) ||
				meridiem === ' ' ||
				meridiem === '') {
				return hour + 12;
			} else {
				return hour;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 12) {
				return '';
			} else if (hour < 17) {
				return ' ';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		}
	});

	//! moment.js locale configuration

	function translate$7(number, withoutSuffix, key, isFuture) {
		switch (key) {
			case 's':
				return withoutSuffix ? ' ' : ' ';
			case 'ss':
				return number + (withoutSuffix ? ' ' : ' ');
			case 'm':
			case 'mm':
				return number + (withoutSuffix ? ' ' : ' ');
			case 'h':
			case 'hh':
				return number + (withoutSuffix ? ' ' : ' ');
			case 'd':
			case 'dd':
				return number + (withoutSuffix ? ' ' : ' ');
			case 'M':
			case 'MM':
				return number + (withoutSuffix ? ' ' : ' ');
			case 'y':
			case 'yy':
				return number + (withoutSuffix ? ' ' : ' ');
			default:
				return number;
		}
	}

	hooks.defineLocale('mn', {
		months : ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
		monthsShort : '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
		monthsParseExact : true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY-MM-DD',
			LL : 'YYYY  MMMM D',
			LLL : 'YYYY  MMMM D HH:mm',
			LLLL : 'dddd, YYYY  MMMM D HH:mm'
		},
		meridiemParse: /|/i,
		isPM : function (input) {
			return input === '';
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : '[] dddd LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : translate$7,
			ss : translate$7,
			m : translate$7,
			mm : translate$7,
			h : translate$7,
			hh : translate$7,
			d : translate$7,
			dd : translate$7,
			M : translate$7,
			MM : translate$7,
			y : translate$7,
			yy : translate$7
		},
		dayOfMonthOrdinalParse: /\d{1,2} /,
		ordinal : function (number, period) {
			switch (period) {
				case 'd':
				case 'D':
				case 'DDD':
					return number + ' ';
				default:
					return number;
			}
		}
	});

	//! moment.js locale configuration

	var symbolMap$b = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$a = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
		var output = '';
		if (withoutSuffix) {
			switch (string) {
				case 's': output = ' '; break;
				case 'ss': output = '%d '; break;
				case 'm': output = ' '; break;
				case 'mm': output = '%d '; break;
				case 'h': output = ' '; break;
				case 'hh': output = '%d '; break;
				case 'd': output = ' '; break;
				case 'dd': output = '%d '; break;
				case 'M': output = ' '; break;
				case 'MM': output = '%d '; break;
				case 'y': output = ' '; break;
				case 'yy': output = '%d '; break;
			}
		}
		else {
			switch (string) {
				case 's': output = ' '; break;
				case 'ss': output = '%d '; break;
				case 'm': output = ' '; break;
				case 'mm': output = '%d '; break;
				case 'h': output = ' '; break;
				case 'hh': output = '%d '; break;
				case 'd': output = ' '; break;
				case 'dd': output = '%d '; break;
				case 'M': output = ' '; break;
				case 'MM': output = '%d '; break;
				case 'y': output = ' '; break;
				case 'yy': output = '%d '; break;
			}
		}
		return output.replace(/%d/i, number);
	}

	hooks.defineLocale('mr', {
		months : '___________'.split('_'),
		monthsShort: '._._._._._._._._._._._.'.split('_'),
		monthsParseExact : true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm ',
			LTS : 'A h:mm:ss ',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm ',
			LLLL : 'dddd, D MMMM YYYY, A h:mm '
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek: '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future: '%s',
			past: '%s',
			s: relativeTimeMr,
			ss: relativeTimeMr,
			m: relativeTimeMr,
			mm: relativeTimeMr,
			h: relativeTimeMr,
			hh: relativeTimeMr,
			d: relativeTimeMr,
			dd: relativeTimeMr,
			M: relativeTimeMr,
			MM: relativeTimeMr,
			y: relativeTimeMr,
			yy: relativeTimeMr
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$a[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$b[match];
			});
		},
		meridiemParse: /|||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem: function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ms-my', {
		months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
		monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
		weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
		weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
		weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
		longDateFormat : {
			LT : 'HH.mm',
			LTS : 'HH.mm.ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY [pukul] HH.mm',
			LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
		},
		meridiemParse: /pagi|tengahari|petang|malam/,
		meridiemHour: function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === 'pagi') {
				return hour;
			} else if (meridiem === 'tengahari') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === 'petang' || meridiem === 'malam') {
				return hour + 12;
			}
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 11) {
				return 'pagi';
			} else if (hours < 15) {
				return 'tengahari';
			} else if (hours < 19) {
				return 'petang';
			} else {
				return 'malam';
			}
		},
		calendar : {
			sameDay : '[Hari ini pukul] LT',
			nextDay : '[Esok pukul] LT',
			nextWeek : 'dddd [pukul] LT',
			lastDay : '[Kelmarin pukul] LT',
			lastWeek : 'dddd [lepas pukul] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'dalam %s',
			past : '%s yang lepas',
			s : 'beberapa saat',
			ss : '%d saat',
			m : 'seminit',
			mm : '%d minit',
			h : 'sejam',
			hh : '%d jam',
			d : 'sehari',
			dd : '%d hari',
			M : 'sebulan',
			MM : '%d bulan',
			y : 'setahun',
			yy : '%d tahun'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ms', {
		months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
		monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
		weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
		weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
		weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
		longDateFormat : {
			LT : 'HH.mm',
			LTS : 'HH.mm.ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY [pukul] HH.mm',
			LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
		},
		meridiemParse: /pagi|tengahari|petang|malam/,
		meridiemHour: function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === 'pagi') {
				return hour;
			} else if (meridiem === 'tengahari') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === 'petang' || meridiem === 'malam') {
				return hour + 12;
			}
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 11) {
				return 'pagi';
			} else if (hours < 15) {
				return 'tengahari';
			} else if (hours < 19) {
				return 'petang';
			} else {
				return 'malam';
			}
		},
		calendar : {
			sameDay : '[Hari ini pukul] LT',
			nextDay : '[Esok pukul] LT',
			nextWeek : 'dddd [pukul] LT',
			lastDay : '[Kelmarin pukul] LT',
			lastWeek : 'dddd [lepas pukul] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'dalam %s',
			past : '%s yang lepas',
			s : 'beberapa saat',
			ss : '%d saat',
			m : 'seminit',
			mm : '%d minit',
			h : 'sejam',
			hh : '%d jam',
			d : 'sehari',
			dd : '%d hari',
			M : 'sebulan',
			MM : '%d bulan',
			y : 'setahun',
			yy : '%d tahun'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('mt', {
		months : 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
		monthsShort : 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
		weekdays : 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
		weekdaysShort : 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
		weekdaysMin : 'a_Tn_Tl_Er_a_i_Si'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Illum fil-]LT',
			nextDay : '[Gada fil-]LT',
			nextWeek : 'dddd [fil-]LT',
			lastDay : '[Il-biera fil-]LT',
			lastWeek : 'dddd [li gadda] [fil-]LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'f %s',
			past : '%s ilu',
			s : 'ftit sekondi',
			ss : '%d sekondi',
			m : 'minuta',
			mm : '%d minuti',
			h : 'siega',
			hh : '%d siegat',
			d : 'urnata',
			dd : '%d ranet',
			M : 'xahar',
			MM : '%d xhur',
			y : 'sena',
			yy : '%d sni'
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal: '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$c = {
		'1': '',
		'2': '',
		'3': '',
		'4': '',
		'5': '',
		'6': '',
		'7': '',
		'8': '',
		'9': '',
		'0': ''
	}, numberMap$b = {
		'': '1',
		'': '2',
		'': '3',
		'': '4',
		'': '5',
		'': '6',
		'': '7',
		'': '8',
		'': '9',
		'': '0'
	};

	hooks.defineLocale('my', {
		months: '___________'.split('_'),
		monthsShort: '___________'.split('_'),
		weekdays: '______'.split('_'),
		weekdaysShort: '______'.split('_'),
		weekdaysMin: '______'.split('_'),

		longDateFormat: {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L: 'DD/MM/YYYY',
			LL: 'D MMMM YYYY',
			LLL: 'D MMMM YYYY HH:mm',
			LLLL: 'dddd D MMMM YYYY HH:mm'
		},
		calendar: {
			sameDay: '[.] LT []',
			nextDay: '[] LT []',
			nextWeek: 'dddd LT []',
			lastDay: '[.] LT []',
			lastWeek: '[] dddd LT []',
			sameElse: 'L'
		},
		relativeTime: {
			future: ' %s ',
			past: ' %s ',
			s: '.',
			ss : '%d ',
			m: '',
			mm: '%d ',
			h: '',
			hh: '%d ',
			d: '',
			dd: '%d ',
			M: '',
			MM: '%d ',
			y: '',
			yy: '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$b[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$c[match];
			});
		},
		week: {
			dow: 1, // Monday is the first day of the week.
			doy: 4 // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('nb', {
		months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
		monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
		monthsParseExact : true,
		weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
		weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
		weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY [kl.] HH:mm',
			LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
		},
		calendar : {
			sameDay: '[i dag kl.] LT',
			nextDay: '[i morgen kl.] LT',
			nextWeek: 'dddd [kl.] LT',
			lastDay: '[i gr kl.] LT',
			lastWeek: '[forrige] dddd [kl.] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'om %s',
			past : '%s siden',
			s : 'noen sekunder',
			ss : '%d sekunder',
			m : 'ett minutt',
			mm : '%d minutter',
			h : 'en time',
			hh : '%d timer',
			d : 'en dag',
			dd : '%d dager',
			M : 'en mned',
			MM : '%d mneder',
			y : 'ett r',
			yy : '%d r'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$d = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$c = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('ne', {
		months : '___________'.split('_'),
		monthsShort : '._.__.___._._._._._.'.split('_'),
		monthsParseExact : true,
		weekdays : '______'.split('_'),
		weekdaysShort : '._._._._._._.'.split('_'),
		weekdaysMin : '._._._._._._.'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'A h:mm ',
			LTS : 'A h:mm:ss ',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm ',
			LLLL : 'dddd, D MMMM YYYY, A h:mm '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$c[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$d[match];
			});
		},
		meridiemParse: /|||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 3) {
				return '';
			} else if (hour < 12) {
				return '';
			} else if (hour < 16) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : '[] dddd[,] LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd[,] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
		monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse$4 = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex$5 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	hooks.defineLocale('nl-be', {
		months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
		monthsShort : function (m, format) {
			if (!m) {
				return monthsShortWithDots$1;
			} else if (/-MMM-/.test(format)) {
				return monthsShortWithoutDots$1[m.month()];
			} else {
				return monthsShortWithDots$1[m.month()];
			}
		},

		monthsRegex: monthsRegex$5,
		monthsShortRegex: monthsRegex$5,
		monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
		monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

		monthsParse : monthsParse$4,
		longMonthsParse : monthsParse$4,
		shortMonthsParse : monthsParse$4,

		weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
		weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
		weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[vandaag om] LT',
			nextDay: '[morgen om] LT',
			nextWeek: 'dddd [om] LT',
			lastDay: '[gisteren om] LT',
			lastWeek: '[afgelopen] dddd [om] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'over %s',
			past : '%s geleden',
			s : 'een paar seconden',
			ss : '%d seconden',
			m : 'n minuut',
			mm : '%d minuten',
			h : 'n uur',
			hh : '%d uur',
			d : 'n dag',
			dd : '%d dagen',
			M : 'n maand',
			MM : '%d maanden',
			y : 'n jaar',
			yy : '%d jaar'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
		ordinal : function (number) {
			return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
		monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse$5 = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex$6 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	hooks.defineLocale('nl', {
		months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
		monthsShort : function (m, format) {
			if (!m) {
				return monthsShortWithDots$2;
			} else if (/-MMM-/.test(format)) {
				return monthsShortWithoutDots$2[m.month()];
			} else {
				return monthsShortWithDots$2[m.month()];
			}
		},

		monthsRegex: monthsRegex$6,
		monthsShortRegex: monthsRegex$6,
		monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
		monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

		monthsParse : monthsParse$5,
		longMonthsParse : monthsParse$5,
		shortMonthsParse : monthsParse$5,

		weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
		weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
		weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD-MM-YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[vandaag om] LT',
			nextDay: '[morgen om] LT',
			nextWeek: 'dddd [om] LT',
			lastDay: '[gisteren om] LT',
			lastWeek: '[afgelopen] dddd [om] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'over %s',
			past : '%s geleden',
			s : 'een paar seconden',
			ss : '%d seconden',
			m : 'n minuut',
			mm : '%d minuten',
			h : 'n uur',
			hh : '%d uur',
			d : 'n dag',
			dd : '%d dagen',
			M : 'n maand',
			MM : '%d maanden',
			y : 'n jaar',
			yy : '%d jaar'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
		ordinal : function (number) {
			return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('nn', {
		months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
		monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
		weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
		weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
		weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY [kl.] H:mm',
			LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
		},
		calendar : {
			sameDay: '[I dag klokka] LT',
			nextDay: '[I morgon klokka] LT',
			nextWeek: 'dddd [klokka] LT',
			lastDay: '[I gr klokka] LT',
			lastWeek: '[Fregande] dddd [klokka] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'om %s',
			past : '%s sidan',
			s : 'nokre sekund',
			ss : '%d sekund',
			m : 'eit minutt',
			mm : '%d minutt',
			h : 'ein time',
			hh : '%d timar',
			d : 'ein dag',
			dd : '%d dagar',
			M : 'ein mnad',
			MM : '%d mnader',
			y : 'eit r',
			yy : '%d r'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$e = {
			'1': '',
			'2': '',
			'3': '',
			'4': '',
			'5': '',
			'6': '',
			'7': '',
			'8': '',
			'9': '',
			'0': ''
		},
		numberMap$d = {
			'': '1',
			'': '2',
			'': '3',
			'': '4',
			'': '5',
			'': '6',
			'': '7',
			'': '8',
			'': '9',
			'': '0'
		};

	hooks.defineLocale('pa-in', {
		// There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm ',
			LTS : 'A h:mm:ss ',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm ',
			LLLL : 'dddd, D MMMM YYYY, A h:mm '
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : '[] dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$d[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$e[match];
			});
		},
		// Punjabi notation for meridiems are quite fuzzy in practice. While there exists
		// a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
		meridiemParse: /|||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
		monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	function plural$3(n) {
		return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	}
	function translate$8(number, withoutSuffix, key) {
		var result = number + ' ';
		switch (key) {
			case 'ss':
				return result + (plural$3(number) ? 'sekundy' : 'sekund');
			case 'm':
				return withoutSuffix ? 'minuta' : 'minut';
			case 'mm':
				return result + (plural$3(number) ? 'minuty' : 'minut');
			case 'h':
				return withoutSuffix  ? 'godzina'  : 'godzin';
			case 'hh':
				return result + (plural$3(number) ? 'godziny' : 'godzin');
			case 'MM':
				return result + (plural$3(number) ? 'miesice' : 'miesicy');
			case 'yy':
				return result + (plural$3(number) ? 'lata' : 'lat');
		}
	}

	hooks.defineLocale('pl', {
		months : function (momentToFormat, format) {
			if (!momentToFormat) {
				return monthsNominative;
			} else if (format === '') {
				// Hack: if format empty we know this is used to generate
				// RegExp by moment. Give then back both valid forms of months
				// in RegExp ready format.
				return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
			} else if (/D MMMM/.test(format)) {
				return monthsSubjective[momentToFormat.month()];
			} else {
				return monthsNominative[momentToFormat.month()];
			}
		},
		monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
		weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
		weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
		weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Dzi o] LT',
			nextDay: '[Jutro o] LT',
			nextWeek: function () {
				switch (this.day()) {
					case 0:
						return '[W niedziel o] LT';

					case 2:
						return '[We wtorek o] LT';

					case 3:
						return '[W rod o] LT';

					case 6:
						return '[W sobot o] LT';

					default:
						return '[W] dddd [o] LT';
				}
			},
			lastDay: '[Wczoraj o] LT',
			lastWeek: function () {
				switch (this.day()) {
					case 0:
						return '[W zesz niedziel o] LT';
					case 3:
						return '[W zesz rod o] LT';
					case 6:
						return '[W zesz sobot o] LT';
					default:
						return '[W zeszy] dddd [o] LT';
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : 'za %s',
			past : '%s temu',
			s : 'kilka sekund',
			ss : translate$8,
			m : translate$8,
			mm : translate$8,
			h : translate$8,
			hh : translate$8,
			d : '1 dzie',
			dd : '%d dni',
			M : 'miesic',
			MM : translate$8,
			y : 'rok',
			yy : translate$8
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('pt-br', {
		months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
		monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
		weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
		weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
		weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D [de] MMMM [de] YYYY',
			LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
			LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
		},
		calendar : {
			sameDay: '[Hoje s] LT',
			nextDay: '[Amanh s] LT',
			nextWeek: 'dddd [s] LT',
			lastDay: '[Ontem s] LT',
			lastWeek: function () {
				return (this.day() === 0 || this.day() === 6) ?
					'[ltimo] dddd [s] LT' : // Saturday + Sunday
					'[ltima] dddd [s] LT'; // Monday - Friday
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : 'em %s',
			past : 'h %s',
			s : 'poucos segundos',
			ss : '%d segundos',
			m : 'um minuto',
			mm : '%d minutos',
			h : 'uma hora',
			hh : '%d horas',
			d : 'um dia',
			dd : '%d dias',
			M : 'um ms',
			MM : '%d meses',
			y : 'um ano',
			yy : '%d anos'
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : '%d'
	});

	//! moment.js locale configuration

	hooks.defineLocale('pt', {
		months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
		monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
		weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
		weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
		weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D [de] MMMM [de] YYYY',
			LLL : 'D [de] MMMM [de] YYYY HH:mm',
			LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Hoje s] LT',
			nextDay: '[Amanh s] LT',
			nextWeek: 'dddd [s] LT',
			lastDay: '[Ontem s] LT',
			lastWeek: function () {
				return (this.day() === 0 || this.day() === 6) ?
					'[ltimo] dddd [s] LT' : // Saturday + Sunday
					'[ltima] dddd [s] LT'; // Monday - Friday
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : 'em %s',
			past : 'h %s',
			s : 'segundos',
			ss : '%d segundos',
			m : 'um minuto',
			mm : '%d minutos',
			h : 'uma hora',
			hh : '%d horas',
			d : 'um dia',
			dd : '%d dias',
			M : 'um ms',
			MM : '%d meses',
			y : 'um ano',
			yy : '%d anos'
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function relativeTimeWithPlural$2(number, withoutSuffix, key) {
		var format = {
				'ss': 'secunde',
				'mm': 'minute',
				'hh': 'ore',
				'dd': 'zile',
				'MM': 'luni',
				'yy': 'ani'
			},
			separator = ' ';
		if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
			separator = ' de ';
		}
		return number + separator + format[key];
	}

	hooks.defineLocale('ro', {
		months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
		monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
		monthsParseExact: true,
		weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
		weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
		weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY H:mm',
			LLLL : 'dddd, D MMMM YYYY H:mm'
		},
		calendar : {
			sameDay: '[azi la] LT',
			nextDay: '[mine la] LT',
			nextWeek: 'dddd [la] LT',
			lastDay: '[ieri la] LT',
			lastWeek: '[fosta] dddd [la] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'peste %s',
			past : '%s n urm',
			s : 'cteva secunde',
			ss : relativeTimeWithPlural$2,
			m : 'un minut',
			mm : relativeTimeWithPlural$2,
			h : 'o or',
			hh : relativeTimeWithPlural$2,
			d : 'o zi',
			dd : relativeTimeWithPlural$2,
			M : 'o lun',
			MM : relativeTimeWithPlural$2,
			y : 'un an',
			yy : relativeTimeWithPlural$2
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function plural$4(word, num) {
		var forms = word.split('_');
		return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural$3(number, withoutSuffix, key) {
		var format = {
			'ss': withoutSuffix ? '__' : '__',
			'mm': withoutSuffix ? '__' : '__',
			'hh': '__',
			'dd': '__',
			'MM': '__',
			'yy': '__'
		};
		if (key === 'm') {
			return withoutSuffix ? '' : '';
		}
		else {
			return number + ' ' + plural$4(format[key], +number);
		}
	}
	var monthsParse$6 = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

	// http://new.gramota.ru/spravka/rules/139-prop :  103
	//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	hooks.defineLocale('ru', {
		months : {
			format: '___________'.split('_'),
			standalone: '___________'.split('_')
		},
		monthsShort : {
			//  CLDR  "."  ".",        ?
			format: '._._._.____._._._._.'.split('_'),
			standalone: '._.__.____._._._._.'.split('_')
		},
		weekdays : {
			standalone: '______'.split('_'),
			format: '______'.split('_'),
			isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
		},
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		monthsParse : monthsParse$6,
		longMonthsParse : monthsParse$6,
		shortMonthsParse : monthsParse$6,

		//    ,   ,  ,  4 ,      
		monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

		//  
		monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

		//    
		monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

		// ,     
		monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY .',
			LLL : 'D MMMM YYYY ., H:mm',
			LLLL : 'dddd, D MMMM YYYY ., H:mm'
		},
		calendar : {
			sameDay: '[, ] LT',
			nextDay: '[, ] LT',
			lastDay: '[, ] LT',
			nextWeek: function (now) {
				if (now.week() !== this.week()) {
					switch (this.day()) {
						case 0:
							return '[ ] dddd, [] LT';
						case 1:
						case 2:
						case 4:
							return '[ ] dddd, [] LT';
						case 3:
						case 5:
						case 6:
							return '[ ] dddd, [] LT';
					}
				} else {
					if (this.day() === 2) {
						return '[] dddd, [] LT';
					} else {
						return '[] dddd, [] LT';
					}
				}
			},
			lastWeek: function (now) {
				if (now.week() !== this.week()) {
					switch (this.day()) {
						case 0:
							return '[ ] dddd, [] LT';
						case 1:
						case 2:
						case 4:
							return '[ ] dddd, [] LT';
						case 3:
						case 5:
						case 6:
							return '[ ] dddd, [] LT';
					}
				} else {
					if (this.day() === 2) {
						return '[] dddd, [] LT';
					} else {
						return '[] dddd, [] LT';
					}
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s ',
			s : ' ',
			ss : relativeTimeWithPlural$3,
			m : relativeTimeWithPlural$3,
			mm : relativeTimeWithPlural$3,
			h : '',
			hh : relativeTimeWithPlural$3,
			d : '',
			dd : relativeTimeWithPlural$3,
			M : '',
			MM : relativeTimeWithPlural$3,
			y : '',
			yy : relativeTimeWithPlural$3
		},
		meridiemParse: /|||/i,
		isPM : function (input) {
			return /^(|)$/.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 12) {
				return '';
			} else if (hour < 17) {
				return '';
			} else {
				return '';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
		ordinal: function (number, period) {
			switch (period) {
				case 'M':
				case 'd':
				case 'DDD':
					return number + '-';
				case 'D':
					return number + '-';
				case 'w':
				case 'W':
					return number + '-';
				default:
					return number;
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var months$8 = [
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];
	var days$1 = [
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];

	hooks.defineLocale('sd', {
		months : months$8,
		monthsShort : months$8,
		weekdays : days$1,
		weekdaysShort : days$1,
		weekdaysMin : days$1,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM : function (input) {
			return '' === input;
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			}
			return '';
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd [  ] LT',
			lastDay : '[] LT',
			lastWeek : '[ ] dddd [] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/,/g, '');
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('se', {
		months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
		monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
		weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
		weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
		weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'MMMM D. [b.] YYYY',
			LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
			LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
		},
		calendar : {
			sameDay: '[otne ti] LT',
			nextDay: '[ihttin ti] LT',
			nextWeek: 'dddd [ti] LT',
			lastDay: '[ikte ti] LT',
			lastWeek: '[ovddit] dddd [ti] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : '%s geaes',
			past : 'mait %s',
			s : 'moadde sekunddat',
			ss: '%d sekunddat',
			m : 'okta minuhta',
			mm : '%d minuhtat',
			h : 'okta diimmu',
			hh : '%d diimmut',
			d : 'okta beaivi',
			dd : '%d beaivvit',
			M : 'okta mnnu',
			MM : '%d mnut',
			y : 'okta jahki',
			yy : '%d jagit'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	/*jshint -W100*/
	hooks.defineLocale('si', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'a h:mm',
			LTS : 'a h:mm:ss',
			L : 'YYYY/MM/DD',
			LL : 'YYYY MMMM D',
			LLL : 'YYYY MMMM D, a h:mm',
			LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
		},
		calendar : {
			sameDay : '[] LT[]',
			nextDay : '[] LT[]',
			nextWeek : 'dddd LT[]',
			lastDay : '[] LT[]',
			lastWeek : '[] dddd LT[]',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s',
			past : '%s ',
			s : ' ',
			ss : ' %d',
			m : '',
			mm : ' %d',
			h : '',
			hh : ' %d',
			d : '',
			dd : ' %d',
			M : '',
			MM : ' %d',
			y : '',
			yy : ' %d'
		},
		dayOfMonthOrdinalParse: /\d{1,2} /,
		ordinal : function (number) {
			return number + ' ';
		},
		meridiemParse : / | |.|../,
		isPM : function (input) {
			return input === '..' || input === ' ';
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours > 11) {
				return isLower ? '..' : ' ';
			} else {
				return isLower ? '..' : ' ';
			}
		}
	});

	//! moment.js locale configuration

	var months$9 = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
		monthsShort$6 = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	function plural$5(n) {
		return (n > 1) && (n < 5);
	}
	function translate$9(number, withoutSuffix, key, isFuture) {
		var result = number + ' ';
		switch (key) {
			case 's':  // a few seconds / in a few seconds / a few seconds ago
				return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
			case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
				if (withoutSuffix || isFuture) {
					return result + (plural$5(number) ? 'sekundy' : 'seknd');
				} else {
					return result + 'sekundami';
				}
				break;
			case 'm':  // a minute / in a minute / a minute ago
				return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
			case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
				if (withoutSuffix || isFuture) {
					return result + (plural$5(number) ? 'minty' : 'mint');
				} else {
					return result + 'mintami';
				}
				break;
			case 'h':  // an hour / in an hour / an hour ago
				return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
			case 'hh': // 9 hours / in 9 hours / 9 hours ago
				if (withoutSuffix || isFuture) {
					return result + (plural$5(number) ? 'hodiny' : 'hodn');
				} else {
					return result + 'hodinami';
				}
				break;
			case 'd':  // a day / in a day / a day ago
				return (withoutSuffix || isFuture) ? 'de' : 'dom';
			case 'dd': // 9 days / in 9 days / 9 days ago
				if (withoutSuffix || isFuture) {
					return result + (plural$5(number) ? 'dni' : 'dn');
				} else {
					return result + 'dami';
				}
				break;
			case 'M':  // a month / in a month / a month ago
				return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
			case 'MM': // 9 months / in 9 months / 9 months ago
				if (withoutSuffix || isFuture) {
					return result + (plural$5(number) ? 'mesiace' : 'mesiacov');
				} else {
					return result + 'mesiacmi';
				}
				break;
			case 'y':  // a year / in a year / a year ago
				return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
			case 'yy': // 9 years / in 9 years / 9 years ago
				if (withoutSuffix || isFuture) {
					return result + (plural$5(number) ? 'roky' : 'rokov');
				} else {
					return result + 'rokmi';
				}
				break;
		}
	}

	hooks.defineLocale('sk', {
		months : months$9,
		monthsShort : monthsShort$6,
		weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
		weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
		weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
		longDateFormat : {
			LT: 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY H:mm',
			LLLL : 'dddd D. MMMM YYYY H:mm'
		},
		calendar : {
			sameDay: '[dnes o] LT',
			nextDay: '[zajtra o] LT',
			nextWeek: function () {
				switch (this.day()) {
					case 0:
						return '[v nedeu o] LT';
					case 1:
					case 2:
						return '[v] dddd [o] LT';
					case 3:
						return '[v stredu o] LT';
					case 4:
						return '[vo tvrtok o] LT';
					case 5:
						return '[v piatok o] LT';
					case 6:
						return '[v sobotu o] LT';
				}
			},
			lastDay: '[vera o] LT',
			lastWeek: function () {
				switch (this.day()) {
					case 0:
						return '[minul nedeu o] LT';
					case 1:
					case 2:
						return '[minul] dddd [o] LT';
					case 3:
						return '[minul stredu o] LT';
					case 4:
					case 5:
						return '[minul] dddd [o] LT';
					case 6:
						return '[minul sobotu o] LT';
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : 'za %s',
			past : 'pred %s',
			s : translate$9,
			ss : translate$9,
			m : translate$9,
			mm : translate$9,
			h : translate$9,
			hh : translate$9,
			d : translate$9,
			dd : translate$9,
			M : translate$9,
			MM : translate$9,
			y : translate$9,
			yy : translate$9
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
		var result = number + ' ';
		switch (key) {
			case 's':
				return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
			case 'ss':
				if (number === 1) {
					result += withoutSuffix ? 'sekundo' : 'sekundi';
				} else if (number === 2) {
					result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
				} else if (number < 5) {
					result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
				} else {
					result += 'sekund';
				}
				return result;
			case 'm':
				return withoutSuffix ? 'ena minuta' : 'eno minuto';
			case 'mm':
				if (number === 1) {
					result += withoutSuffix ? 'minuta' : 'minuto';
				} else if (number === 2) {
					result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
				} else if (number < 5) {
					result += withoutSuffix || isFuture ? 'minute' : 'minutami';
				} else {
					result += withoutSuffix || isFuture ? 'minut' : 'minutami';
				}
				return result;
			case 'h':
				return withoutSuffix ? 'ena ura' : 'eno uro';
			case 'hh':
				if (number === 1) {
					result += withoutSuffix ? 'ura' : 'uro';
				} else if (number === 2) {
					result += withoutSuffix || isFuture ? 'uri' : 'urama';
				} else if (number < 5) {
					result += withoutSuffix || isFuture ? 'ure' : 'urami';
				} else {
					result += withoutSuffix || isFuture ? 'ur' : 'urami';
				}
				return result;
			case 'd':
				return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
			case 'dd':
				if (number === 1) {
					result += withoutSuffix || isFuture ? 'dan' : 'dnem';
				} else if (number === 2) {
					result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
				} else {
					result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
				}
				return result;
			case 'M':
				return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
			case 'MM':
				if (number === 1) {
					result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
				} else if (number === 2) {
					result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
				} else if (number < 5) {
					result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
				} else {
					result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
				}
				return result;
			case 'y':
				return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
			case 'yy':
				if (number === 1) {
					result += withoutSuffix || isFuture ? 'leto' : 'letom';
				} else if (number === 2) {
					result += withoutSuffix || isFuture ? 'leti' : 'letoma';
				} else if (number < 5) {
					result += withoutSuffix || isFuture ? 'leta' : 'leti';
				} else {
					result += withoutSuffix || isFuture ? 'let' : 'leti';
				}
				return result;
		}
	}

	hooks.defineLocale('sl', {
		months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
		monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
		monthsParseExact: true,
		weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
		weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
		weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM YYYY',
			LLL : 'D. MMMM YYYY H:mm',
			LLLL : 'dddd, D. MMMM YYYY H:mm'
		},
		calendar : {
			sameDay  : '[danes ob] LT',
			nextDay  : '[jutri ob] LT',

			nextWeek : function () {
				switch (this.day()) {
					case 0:
						return '[v] [nedeljo] [ob] LT';
					case 3:
						return '[v] [sredo] [ob] LT';
					case 6:
						return '[v] [soboto] [ob] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[v] dddd [ob] LT';
				}
			},
			lastDay  : '[veraj ob] LT',
			lastWeek : function () {
				switch (this.day()) {
					case 0:
						return '[prejnjo] [nedeljo] [ob] LT';
					case 3:
						return '[prejnjo] [sredo] [ob] LT';
					case 6:
						return '[prejnjo] [soboto] [ob] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[prejnji] dddd [ob] LT';
				}
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'ez %s',
			past   : 'pred %s',
			s      : processRelativeTime$6,
			ss     : processRelativeTime$6,
			m      : processRelativeTime$6,
			mm     : processRelativeTime$6,
			h      : processRelativeTime$6,
			hh     : processRelativeTime$6,
			d      : processRelativeTime$6,
			dd     : processRelativeTime$6,
			M      : processRelativeTime$6,
			MM     : processRelativeTime$6,
			y      : processRelativeTime$6,
			yy     : processRelativeTime$6
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('sq', {
		months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
		monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
		weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
		weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
		weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
		weekdaysParseExact : true,
		meridiemParse: /PD|MD/,
		isPM: function (input) {
			return input.charAt(0) === 'M';
		},
		meridiem : function (hours, minutes, isLower) {
			return hours < 12 ? 'PD' : 'MD';
		},
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[Sot n] LT',
			nextDay : '[Nesr n] LT',
			nextWeek : 'dddd [n] LT',
			lastDay : '[Dje n] LT',
			lastWeek : 'dddd [e kaluar n] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'n %s',
			past : '%s m par',
			s : 'disa sekonda',
			ss : '%d sekonda',
			m : 'nj minut',
			mm : '%d minuta',
			h : 'nj or',
			hh : '%d or',
			d : 'nj dit',
			dd : '%d dit',
			M : 'nj muaj',
			MM : '%d muaj',
			y : 'nj vit',
			yy : '%d vite'
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var translator$1 = {
		words: { //Different grammatical cases
			ss: ['', '', ''],
			m: [' ', ' '],
			mm: ['', '', ''],
			h: [' ', ' '],
			hh: ['', '', ''],
			dd: ['', '', ''],
			MM: ['', '', ''],
			yy: ['', '', '']
		},
		correctGrammaticalCase: function (number, wordKey) {
			return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
		},
		translate: function (number, withoutSuffix, key) {
			var wordKey = translator$1.words[key];
			if (key.length === 1) {
				return withoutSuffix ? wordKey[0] : wordKey[1];
			} else {
				return number + ' ' + translator$1.correctGrammaticalCase(number, wordKey);
			}
		}
	};

	hooks.defineLocale('sr-cyrl', {
		months: '___________'.split('_'),
		monthsShort: '._._._.____._._._._.'.split('_'),
		monthsParseExact: true,
		weekdays: '______'.split('_'),
		weekdaysShort: '._._._._._._.'.split('_'),
		weekdaysMin: '______'.split('_'),
		weekdaysParseExact : true,
		longDateFormat: {
			LT: 'H:mm',
			LTS : 'H:mm:ss',
			L: 'DD.MM.YYYY',
			LL: 'D. MMMM YYYY',
			LLL: 'D. MMMM YYYY H:mm',
			LLLL: 'dddd, D. MMMM YYYY H:mm'
		},
		calendar: {
			sameDay: '[ ] LT',
			nextDay: '[ ] LT',
			nextWeek: function () {
				switch (this.day()) {
					case 0:
						return '[] [] [] LT';
					case 3:
						return '[] [] [] LT';
					case 6:
						return '[] [] [] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[] dddd [] LT';
				}
			},
			lastDay  : '[ ] LT',
			lastWeek : function () {
				var lastWeekDays = [
					'[] [] [] LT',
					'[] [] [] LT',
					'[] [] [] LT',
					'[] [] [] LT',
					'[] [] [] LT',
					'[] [] [] LT',
					'[] [] [] LT'
				];
				return lastWeekDays[this.day()];
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past   : ' %s',
			s      : ' ',
			ss     : translator$1.translate,
			m      : translator$1.translate,
			mm     : translator$1.translate,
			h      : translator$1.translate,
			hh     : translator$1.translate,
			d      : '',
			dd     : translator$1.translate,
			M      : '',
			MM     : translator$1.translate,
			y      : '',
			yy     : translator$1.translate
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var translator$2 = {
		words: { //Different grammatical cases
			ss: ['sekunda', 'sekunde', 'sekundi'],
			m: ['jedan minut', 'jedne minute'],
			mm: ['minut', 'minute', 'minuta'],
			h: ['jedan sat', 'jednog sata'],
			hh: ['sat', 'sata', 'sati'],
			dd: ['dan', 'dana', 'dana'],
			MM: ['mesec', 'meseca', 'meseci'],
			yy: ['godina', 'godine', 'godina']
		},
		correctGrammaticalCase: function (number, wordKey) {
			return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
		},
		translate: function (number, withoutSuffix, key) {
			var wordKey = translator$2.words[key];
			if (key.length === 1) {
				return withoutSuffix ? wordKey[0] : wordKey[1];
			} else {
				return number + ' ' + translator$2.correctGrammaticalCase(number, wordKey);
			}
		}
	};

	hooks.defineLocale('sr', {
		months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
		monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
		monthsParseExact: true,
		weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
		weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
		weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
		weekdaysParseExact : true,
		longDateFormat: {
			LT: 'H:mm',
			LTS : 'H:mm:ss',
			L: 'DD.MM.YYYY',
			LL: 'D. MMMM YYYY',
			LLL: 'D. MMMM YYYY H:mm',
			LLLL: 'dddd, D. MMMM YYYY H:mm'
		},
		calendar: {
			sameDay: '[danas u] LT',
			nextDay: '[sutra u] LT',
			nextWeek: function () {
				switch (this.day()) {
					case 0:
						return '[u] [nedelju] [u] LT';
					case 3:
						return '[u] [sredu] [u] LT';
					case 6:
						return '[u] [subotu] [u] LT';
					case 1:
					case 2:
					case 4:
					case 5:
						return '[u] dddd [u] LT';
				}
			},
			lastDay  : '[jue u] LT',
			lastWeek : function () {
				var lastWeekDays = [
					'[prole] [nedelje] [u] LT',
					'[prolog] [ponedeljka] [u] LT',
					'[prolog] [utorka] [u] LT',
					'[prole] [srede] [u] LT',
					'[prolog] [etvrtka] [u] LT',
					'[prolog] [petka] [u] LT',
					'[prole] [subote] [u] LT'
				];
				return lastWeekDays[this.day()];
			},
			sameElse : 'L'
		},
		relativeTime : {
			future : 'za %s',
			past   : 'pre %s',
			s      : 'nekoliko sekundi',
			ss     : translator$2.translate,
			m      : translator$2.translate,
			mm     : translator$2.translate,
			h      : translator$2.translate,
			hh     : translator$2.translate,
			d      : 'dan',
			dd     : translator$2.translate,
			M      : 'mesec',
			MM     : translator$2.translate,
			y      : 'godinu',
			yy     : translator$2.translate
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('ss', {
		months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
		monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
		weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
		weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
		weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY h:mm A',
			LLLL : 'dddd, D MMMM YYYY h:mm A'
		},
		calendar : {
			sameDay : '[Namuhla nga] LT',
			nextDay : '[Kusasa nga] LT',
			nextWeek : 'dddd [nga] LT',
			lastDay : '[Itolo nga] LT',
			lastWeek : 'dddd [leliphelile] [nga] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'nga %s',
			past : 'wenteka nga %s',
			s : 'emizuzwana lomcane',
			ss : '%d mzuzwana',
			m : 'umzuzu',
			mm : '%d emizuzu',
			h : 'lihora',
			hh : '%d emahora',
			d : 'lilanga',
			dd : '%d emalanga',
			M : 'inyanga',
			MM : '%d tinyanga',
			y : 'umnyaka',
			yy : '%d iminyaka'
		},
		meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
		meridiem : function (hours, minutes, isLower) {
			if (hours < 11) {
				return 'ekuseni';
			} else if (hours < 15) {
				return 'emini';
			} else if (hours < 19) {
				return 'entsambama';
			} else {
				return 'ebusuku';
			}
		},
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === 'ekuseni') {
				return hour;
			} else if (meridiem === 'emini') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
				if (hour === 0) {
					return 0;
				}
				return hour + 12;
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : '%d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('sv', {
		months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
		monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
		weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
		weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
		weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY-MM-DD',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY [kl.] HH:mm',
			LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
			lll : 'D MMM YYYY HH:mm',
			llll : 'ddd D MMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Idag] LT',
			nextDay: '[Imorgon] LT',
			lastDay: '[Igr] LT',
			nextWeek: '[P] dddd LT',
			lastWeek: '[I] dddd[s] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'om %s',
			past : 'fr %s sedan',
			s : 'ngra sekunder',
			ss : '%d sekunder',
			m : 'en minut',
			mm : '%d minuter',
			h : 'en timme',
			hh : '%d timmar',
			d : 'en dag',
			dd : '%d dagar',
			M : 'en mnad',
			MM : '%d mnader',
			y : 'ett r',
			yy : '%d r'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'e' :
					(b === 1) ? 'a' :
						(b === 2) ? 'a' :
							(b === 3) ? 'e' : 'e';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('sw', {
		months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
		monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
		weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
		weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
		weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[leo saa] LT',
			nextDay : '[kesho saa] LT',
			nextWeek : '[wiki ijayo] dddd [saat] LT',
			lastDay : '[jana] LT',
			lastWeek : '[wiki iliyopita] dddd [saat] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s baadaye',
			past : 'tokea %s',
			s : 'hivi punde',
			ss : 'sekunde %d',
			m : 'dakika moja',
			mm : 'dakika %d',
			h : 'saa limoja',
			hh : 'masaa %d',
			d : 'siku moja',
			dd : 'masiku %d',
			M : 'mwezi mmoja',
			MM : 'miezi %d',
			y : 'mwaka mmoja',
			yy : 'miaka %d'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var symbolMap$f = {
		'1': '',
		'2': '',
		'3': '',
		'4': '',
		'5': '',
		'6': '',
		'7': '',
		'8': '',
		'9': '',
		'0': ''
	}, numberMap$e = {
		'': '1',
		'': '2',
		'': '3',
		'': '4',
		'': '5',
		'': '6',
		'': '7',
		'': '8',
		'': '9',
		'': '0'
	};

	hooks.defineLocale('ta', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, HH:mm',
			LLLL : 'dddd, D MMMM YYYY, HH:mm'
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[ ] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : '  ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : '  ',
			hh : '%d  ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : function (number) {
			return number + '';
		},
		preparse: function (string) {
			return string.replace(/[]/g, function (match) {
				return numberMap$e[match];
			});
		},
		postformat: function (string) {
			return string.replace(/\d/g, function (match) {
				return symbolMap$f[match];
			});
		},
		// refer http://ta.wikipedia.org/s/1er1
		meridiemParse: /|||||/,
		meridiem : function (hour, minute, isLower) {
			if (hour < 2) {
				return ' ';
			} else if (hour < 6) {
				return ' ';  // 
			} else if (hour < 10) {
				return ' '; // 
			} else if (hour < 14) {
				return ' '; // 
			} else if (hour < 18) {
				return ' '; // 
			} else if (hour < 22) {
				return ' '; // 
			} else {
				return ' ';
			}
		},
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 2 ? hour : hour + 12;
			} else if (meridiem === '' || meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else {
				return hour + 12;
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('te', {
		months : '___________'.split('_'),
		monthsShort : '._.__.____._._._._.'.split('_'),
		monthsParseExact : true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'A h:mm',
			LTS : 'A h:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY, A h:mm',
			LLLL : 'dddd, D MMMM YYYY, A h:mm'
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : 'dddd, LT',
			lastDay : '[] LT',
			lastWeek : '[] dddd, LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		dayOfMonthOrdinalParse : /\d{1,2}/,
		ordinal : '%d',
		meridiemParse: /|||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 10 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 10) {
				return '';
			} else if (hour < 17) {
				return '';
			} else if (hour < 20) {
				return '';
			} else {
				return '';
			}
		},
		week : {
			dow : 0, // Sunday is the first day of the week.
			doy : 6  // The week that contains Jan 6th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('tet', {
		months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
		monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
		weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
		weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
		weekdaysMin : 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Ohin iha] LT',
			nextDay: '[Aban iha] LT',
			nextWeek: 'dddd [iha] LT',
			lastDay: '[Horiseik iha] LT',
			lastWeek: 'dddd [semana kotuk] [iha] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'iha %s',
			past : '%s liuba',
			s : 'minutu balun',
			ss : 'minutu %d',
			m : 'minutu ida',
			mm : 'minutu %d',
			h : 'oras ida',
			hh : 'oras %d',
			d : 'loron ida',
			dd : 'loron %d',
			M : 'fulan ida',
			MM : 'fulan %d',
			y : 'tinan ida',
			yy : 'tinan %d'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var suffixes$3 = {
		0: '-',
		1: '-',
		2: '-',
		3: '-',
		4: '-',
		5: '-',
		6: '-',
		7: '-',
		8: '-',
		9: '-',
		10: '-',
		12: '-',
		13: '-',
		20: '-',
		30: '-',
		40: '-',
		50: '-',
		60: '-',
		70: '-',
		80: '-',
		90: '-',
		100: '-'
	};

	hooks.defineLocale('tg', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			lastDay : '[ ] LT',
			nextWeek : 'dddd[] [  ] LT',
			lastWeek : 'dddd[] [  ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s ',
			s : ' ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		meridiemParse: /|||/,
		meridiemHour: function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '') {
				return hour < 4 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === '') {
				return hour + 12;
			}
		},
		meridiem: function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 11) {
				return '';
			} else if (hour < 16) {
				return '';
			} else if (hour < 19) {
				return '';
			} else {
				return '';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
		ordinal: function (number) {
			var a = number % 10,
				b = number >= 100 ? 100 : null;
			return number + (suffixes$3[number] || suffixes$3[a] || suffixes$3[b]);
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 1th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('th', {
		months : '___________'.split('_'),
		monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
		monthsParseExact: true,
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'), // yes, three characters difference
		weekdaysMin : '._._._._._._.'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'H:mm',
			LTS : 'H:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY  H:mm',
			LLLL : 'dddd D MMMM YYYY  H:mm'
		},
		meridiemParse: /|/,
		isPM: function (input) {
			return input === '';
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd[ ] LT',
			lastDay : '[ ] LT',
			lastWeek : '[]dddd[ ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s',
			s : '',
			ss : '%d ',
			m : '1 ',
			mm : '%d ',
			h : '1 ',
			hh : '%d ',
			d : '1 ',
			dd : '%d ',
			M : '1 ',
			MM : '%d ',
			y : '1 ',
			yy : '%d '
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('tl-ph', {
		months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
		monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
		weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
		weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
		weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'MM/D/YYYY',
			LL : 'MMMM D, YYYY',
			LLL : 'MMMM D, YYYY HH:mm',
			LLLL : 'dddd, MMMM DD, YYYY HH:mm'
		},
		calendar : {
			sameDay: 'LT [ngayong araw]',
			nextDay: '[Bukas ng] LT',
			nextWeek: 'LT [sa susunod na] dddd',
			lastDay: 'LT [kahapon]',
			lastWeek: 'LT [noong nakaraang] dddd',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'sa loob ng %s',
			past : '%s ang nakalipas',
			s : 'ilang segundo',
			ss : '%d segundo',
			m : 'isang minuto',
			mm : '%d minuto',
			h : 'isang oras',
			hh : '%d oras',
			d : 'isang araw',
			dd : '%d araw',
			M : 'isang buwan',
			MM : '%d buwan',
			y : 'isang taon',
			yy : '%d taon'
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : function (number) {
			return number;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

	function translateFuture(output) {
		var time = output;
		time = (output.indexOf('jaj') !== -1) ?
			time.slice(0, -3) + 'leS' :
			(output.indexOf('jar') !== -1) ?
				time.slice(0, -3) + 'waQ' :
				(output.indexOf('DIS') !== -1) ?
					time.slice(0, -3) + 'nem' :
					time + ' pIq';
		return time;
	}

	function translatePast(output) {
		var time = output;
		time = (output.indexOf('jaj') !== -1) ?
			time.slice(0, -3) + 'Hu' :
			(output.indexOf('jar') !== -1) ?
				time.slice(0, -3) + 'wen' :
				(output.indexOf('DIS') !== -1) ?
					time.slice(0, -3) + 'ben' :
					time + ' ret';
		return time;
	}

	function translate$a(number, withoutSuffix, string, isFuture) {
		var numberNoun = numberAsNoun(number);
		switch (string) {
			case 'ss':
				return numberNoun + ' lup';
			case 'mm':
				return numberNoun + ' tup';
			case 'hh':
				return numberNoun + ' rep';
			case 'dd':
				return numberNoun + ' jaj';
			case 'MM':
				return numberNoun + ' jar';
			case 'yy':
				return numberNoun + ' DIS';
		}
	}

	function numberAsNoun(number) {
		var hundred = Math.floor((number % 1000) / 100),
			ten = Math.floor((number % 100) / 10),
			one = number % 10,
			word = '';
		if (hundred > 0) {
			word += numbersNouns[hundred] + 'vatlh';
		}
		if (ten > 0) {
			word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
		}
		if (one > 0) {
			word += ((word !== '') ? ' ' : '') + numbersNouns[one];
		}
		return (word === '') ? 'pagh' : word;
	}

	hooks.defineLocale('tlh', {
		months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
		monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
		monthsParseExact : true,
		weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
		weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
		weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[DaHjaj] LT',
			nextDay: '[waleS] LT',
			nextWeek: 'LLL',
			lastDay: '[waHu] LT',
			lastWeek: 'LLL',
			sameElse: 'L'
		},
		relativeTime : {
			future : translateFuture,
			past : translatePast,
			s : 'puS lup',
			ss : translate$a,
			m : 'wa tup',
			mm : translate$a,
			h : 'wa rep',
			hh : translate$a,
			d : 'wa jaj',
			dd : translate$a,
			M : 'wa jar',
			MM : translate$a,
			y : 'wa DIS',
			yy : translate$a
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	var suffixes$4 = {
		1: '\'inci',
		5: '\'inci',
		8: '\'inci',
		70: '\'inci',
		80: '\'inci',
		2: '\'nci',
		7: '\'nci',
		20: '\'nci',
		50: '\'nci',
		3: '\'nc',
		4: '\'nc',
		100: '\'nc',
		6: '\'nc',
		9: '\'uncu',
		10: '\'uncu',
		30: '\'uncu',
		60: '\'nc',
		90: '\'nc'
	};

	hooks.defineLocale('tr', {
		months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
		monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
		weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
		weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
		weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[bugn saat] LT',
			nextDay : '[yarn saat] LT',
			nextWeek : '[gelecek] dddd [saat] LT',
			lastDay : '[dn] LT',
			lastWeek : '[geen] dddd [saat] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s sonra',
			past : '%s nce',
			s : 'birka saniye',
			ss : '%d saniye',
			m : 'bir dakika',
			mm : '%d dakika',
			h : 'bir saat',
			hh : '%d saat',
			d : 'bir gn',
			dd : '%d gn',
			M : 'bir ay',
			MM : '%d ay',
			y : 'bir yl',
			yy : '%d yl'
		},
		ordinal: function (number, period) {
			switch (period) {
				case 'd':
				case 'D':
				case 'Do':
				case 'DD':
					return number;
				default:
					if (number === 0) {  // special case for zero
						return number + '\'nc';
					}
					var a = number % 10,
						b = number % 100 - a,
						c = number >= 100 ? 100 : null;
					return number + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	hooks.defineLocale('tzl', {
		months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
		monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
		weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
		weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
		weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
		longDateFormat : {
			LT : 'HH.mm',
			LTS : 'HH.mm.ss',
			L : 'DD.MM.YYYY',
			LL : 'D. MMMM [dallas] YYYY',
			LLL : 'D. MMMM [dallas] YYYY HH.mm',
			LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
		},
		meridiemParse: /d\'o|d\'a/i,
		isPM : function (input) {
			return 'd\'o' === input.toLowerCase();
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours > 11) {
				return isLower ? 'd\'o' : 'D\'O';
			} else {
				return isLower ? 'd\'a' : 'D\'A';
			}
		},
		calendar : {
			sameDay : '[oxhi ] LT',
			nextDay : '[dem ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[ieiri ] LT',
			lastWeek : '[sr el] dddd [lasteu ] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'osprei %s',
			past : 'ja%s',
			s : processRelativeTime$7,
			ss : processRelativeTime$7,
			m : processRelativeTime$7,
			mm : processRelativeTime$7,
			h : processRelativeTime$7,
			hh : processRelativeTime$7,
			d : processRelativeTime$7,
			dd : processRelativeTime$7,
			M : processRelativeTime$7,
			MM : processRelativeTime$7,
			y : processRelativeTime$7,
			yy : processRelativeTime$7
		},
		dayOfMonthOrdinalParse: /\d{1,2}\./,
		ordinal : '%d.',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
		var format = {
			's': ['viensas secunds', '\'iensas secunds'],
			'ss': [number + ' secunds', '' + number + ' secunds'],
			'm': ['\'n mut', '\'iens mut'],
			'mm': [number + ' muts', '' + number + ' muts'],
			'h': ['\'n ora', '\'iensa ora'],
			'hh': [number + ' oras', '' + number + ' oras'],
			'd': ['\'n ziua', '\'iensa ziua'],
			'dd': [number + ' ziuas', '' + number + ' ziuas'],
			'M': ['\'n mes', '\'iens mes'],
			'MM': [number + ' mesen', '' + number + ' mesen'],
			'y': ['\'n ar', '\'iens ar'],
			'yy': [number + ' ars', '' + number + ' ars']
		};
		return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}

	//! moment.js locale configuration

	hooks.defineLocale('tzm-latn', {
		months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
		monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
		weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
		weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
		weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[asdkh g] LT',
			nextDay: '[aska g] LT',
			nextWeek: 'dddd [g] LT',
			lastDay: '[assant g] LT',
			lastWeek: 'dddd [g] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : 'dadkh s yan %s',
			past : 'yan %s',
			s : 'imik',
			ss : '%d imik',
			m : 'minu',
			mm : '%d minu',
			h : 'saa',
			hh : '%d tassain',
			d : 'ass',
			dd : '%d ossan',
			M : 'ayowr',
			MM : '%d iyyirn',
			y : 'asgas',
			yy : '%d isgasn'
		},
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('tzm', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS: 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[ ] LT',
			nextDay: '[ ] LT',
			nextWeek: 'dddd [] LT',
			lastDay: '[ ] LT',
			lastWeek: 'dddd [] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : '   %s',
			past : ' %s',
			s : '',
			ss : '%d ',
			m : '',
			mm : '%d ',
			h : '',
			hh : '%d ',
			d : '',
			dd : '%d o',
			M : 'o',
			MM : '%d ',
			y : '',
			yy : '%d '
		},
		week : {
			dow : 6, // Saturday is the first day of the week.
			doy : 12  // The week that contains Jan 12th is the first week of the year.
		}
	});

	//! moment.js language configuration

	hooks.defineLocale('ug-cn', {
		months: '___________'.split(
			'_'
		),
		monthsShort: '___________'.split(
			'_'
		),
		weekdays: '______'.split(
			'_'
		),
		weekdaysShort: '______'.split('_'),
		weekdaysMin: '______'.split('_'),
		longDateFormat: {
			LT: 'HH:mm',
			LTS: 'HH:mm:ss',
			L: 'YYYY-MM-DD',
			LL: 'YYYY-M-D-',
			LLL: 'YYYY-M-D- HH:mm',
			LLLL: 'dddd YYYY-M-D- HH:mm'
		},
		meridiemParse: / || || |/,
		meridiemHour: function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (
				meridiem === ' ' ||
				meridiem === '' ||
				meridiem === ' '
			) {
				return hour;
			} else if (meridiem === ' ' || meridiem === '') {
				return hour + 12;
			} else {
				return hour >= 11 ? hour : hour + 12;
			}
		},
		meridiem: function (hour, minute, isLower) {
			var hm = hour * 100 + minute;
			if (hm < 600) {
				return ' ';
			} else if (hm < 900) {
				return '';
			} else if (hm < 1130) {
				return ' ';
			} else if (hm < 1230) {
				return '';
			} else if (hm < 1800) {
				return ' ';
			} else {
				return '';
			}
		},
		calendar: {
			sameDay: '[ ] LT',
			nextDay: '[ ] LT',
			nextWeek: '[] dddd [] LT',
			lastDay: '[] LT',
			lastWeek: '[] dddd [] LT',
			sameElse: 'L'
		},
		relativeTime: {
			future: '%s ',
			past: '%s ',
			s: ' ',
			ss: '%d ',
			m: ' ',
			mm: '%d ',
			h: ' ',
			hh: '%d ',
			d: ' ',
			dd: '%d ',
			M: ' ',
			MM: '%d ',
			y: ' ',
			yy: '%d '
		},

		dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
		ordinal: function (number, period) {
			switch (period) {
				case 'd':
				case 'D':
				case 'DDD':
					return number + '-';
				case 'w':
				case 'W':
					return number + '-';
				default:
					return number;
			}
		},
		preparse: function (string) {
			return string.replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/,/g, '');
		},
		week: {
			// GB/T 7408-1994ISO 8601:1988
			dow: 1, // Monday is the first day of the week.
			doy: 7 // The week that contains Jan 1st is the first week of the year.
		}
	});

	//! moment.js locale configuration

	function plural$6(word, num) {
		var forms = word.split('_');
		return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural$4(number, withoutSuffix, key) {
		var format = {
			'ss': withoutSuffix ? '__' : '__',
			'mm': withoutSuffix ? '__' : '__',
			'hh': withoutSuffix ? '__' : '__',
			'dd': '__',
			'MM': '__',
			'yy': '__'
		};
		if (key === 'm') {
			return withoutSuffix ? '' : '';
		}
		else if (key === 'h') {
			return withoutSuffix ? '' : '';
		}
		else {
			return number + ' ' + plural$6(format[key], +number);
		}
	}
	function weekdaysCaseReplace(m, format) {
		var weekdays = {
			'nominative': '______'.split('_'),
			'accusative': '______'.split('_'),
			'genitive': '______'.split('_')
		};

		if (m === true) {
			return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
		}
		if (!m) {
			return weekdays['nominative'];
		}

		var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
			'accusative' :
			((/\[?(?:|)? ?\] ?dddd/).test(format) ?
				'genitive' :
				'nominative');
		return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
		return function () {
			return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
		};
	}

	hooks.defineLocale('uk', {
		months : {
			'format': '___________'.split('_'),
			'standalone': '___________'.split('_')
		},
		monthsShort : '___________'.split('_'),
		weekdays : weekdaysCaseReplace,
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD.MM.YYYY',
			LL : 'D MMMM YYYY .',
			LLL : 'D MMMM YYYY ., HH:mm',
			LLLL : 'dddd, D MMMM YYYY ., HH:mm'
		},
		calendar : {
			sameDay: processHoursFunction('[ '),
			nextDay: processHoursFunction('[ '),
			lastDay: processHoursFunction('[ '),
			nextWeek: processHoursFunction('[] dddd ['),
			lastWeek: function () {
				switch (this.day()) {
					case 0:
					case 3:
					case 5:
					case 6:
						return processHoursFunction('[] dddd [').call(this);
					case 1:
					case 2:
					case 4:
						return processHoursFunction('[] dddd [').call(this);
				}
			},
			sameElse: 'L'
		},
		relativeTime : {
			future : ' %s',
			past : '%s ',
			s : ' ',
			ss : relativeTimeWithPlural$4,
			m : relativeTimeWithPlural$4,
			mm : relativeTimeWithPlural$4,
			h : '',
			hh : relativeTimeWithPlural$4,
			d : '',
			dd : relativeTimeWithPlural$4,
			M : '',
			MM : relativeTimeWithPlural$4,
			y : '',
			yy : relativeTimeWithPlural$4
		},
		// M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
		meridiemParse: /|||/,
		isPM: function (input) {
			return /^(|)$/.test(input);
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 4) {
				return '';
			} else if (hour < 12) {
				return '';
			} else if (hour < 17) {
				return '';
			} else {
				return '';
			}
		},
		dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
		ordinal: function (number, period) {
			switch (period) {
				case 'M':
				case 'd':
				case 'DDD':
				case 'w':
				case 'W':
					return number + '-';
				case 'D':
					return number + '-';
				default:
					return number;
			}
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	var months$a = [
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];
	var days$2 = [
		'',
		'',
		'',
		'',
		'',
		'',
		''
	];

	hooks.defineLocale('ur', {
		months : months$a,
		monthsShort : months$a,
		weekdays : days$2,
		weekdaysShort : days$2,
		weekdaysMin : days$2,
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd D MMMM YYYY HH:mm'
		},
		meridiemParse: /|/,
		isPM : function (input) {
			return '' === input;
		},
		meridiem : function (hour, minute, isLower) {
			if (hour < 12) {
				return '';
			}
			return '';
		},
		calendar : {
			sameDay : '[ ] LT',
			nextDay : '[ ] LT',
			nextWeek : 'dddd [] LT',
			lastDay : '[  ] LT',
			lastWeek : '[] dddd [] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '%s ',
			past : '%s ',
			s : ' ',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		preparse: function (string) {
			return string.replace(//g, ',');
		},
		postformat: function (string) {
			return string.replace(/,/g, '');
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('uz-latn', {
		months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
		monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
		weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
		weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
		weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'D MMMM YYYY, dddd HH:mm'
		},
		calendar : {
			sameDay : '[Bugun soat] LT [da]',
			nextDay : '[Ertaga] LT [da]',
			nextWeek : 'dddd [kuni soat] LT [da]',
			lastDay : '[Kecha soat] LT [da]',
			lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'Yaqin %s ichida',
			past : 'Bir necha %s oldin',
			s : 'soniya',
			ss : '%d soniya',
			m : 'bir daqiqa',
			mm : '%d daqiqa',
			h : 'bir soat',
			hh : '%d soat',
			d : 'bir kun',
			dd : '%d kun',
			M : 'bir oy',
			MM : '%d oy',
			y : 'bir yil',
			yy : '%d yil'
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 7th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('uz', {
		months : '___________'.split('_'),
		monthsShort : '___________'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'D MMMM YYYY, dddd HH:mm'
		},
		calendar : {
			sameDay : '[ ] LT []',
			nextDay : '[] LT []',
			nextWeek : 'dddd [ ] LT []',
			lastDay : '[ ] LT []',
			lastWeek : '[] dddd [ ] LT []',
			sameElse : 'L'
		},
		relativeTime : {
			future : ' %s ',
			past : '  %s ',
			s : '',
			ss : '%d ',
			m : ' ',
			mm : '%d ',
			h : ' ',
			hh : '%d ',
			d : ' ',
			dd : '%d ',
			M : ' ',
			MM : '%d ',
			y : ' ',
			yy : '%d '
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 7  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('vi', {
		months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
		monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
		monthsParseExact : true,
		weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
		weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
		weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
		weekdaysParseExact : true,
		meridiemParse: /sa|ch/i,
		isPM : function (input) {
			return /^ch$/i.test(input);
		},
		meridiem : function (hours, minutes, isLower) {
			if (hours < 12) {
				return isLower ? 'sa' : 'SA';
			} else {
				return isLower ? 'ch' : 'CH';
			}
		},
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM [nm] YYYY',
			LLL : 'D MMMM [nm] YYYY HH:mm',
			LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
			l : 'DD/M/YYYY',
			ll : 'D MMM YYYY',
			lll : 'D MMM YYYY HH:mm',
			llll : 'ddd, D MMM YYYY HH:mm'
		},
		calendar : {
			sameDay: '[Hm nay lc] LT',
			nextDay: '[Ngy mai lc] LT',
			nextWeek: 'dddd [tun ti lc] LT',
			lastDay: '[Hm qua lc] LT',
			lastWeek: 'dddd [tun ri lc] LT',
			sameElse: 'L'
		},
		relativeTime : {
			future : '%s ti',
			past : '%s trc',
			s : 'vi giy',
			ss : '%d giy' ,
			m : 'mt pht',
			mm : '%d pht',
			h : 'mt gi',
			hh : '%d gi',
			d : 'mt ngy',
			dd : '%d ngy',
			M : 'mt thng',
			MM : '%d thng',
			y : 'mt nm',
			yy : '%d nm'
		},
		dayOfMonthOrdinalParse: /\d{1,2}/,
		ordinal : function (number) {
			return number;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('x-pseudo', {
		months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
		monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
		monthsParseExact : true,
		weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
		weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
		weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
		weekdaysParseExact : true,
		longDateFormat : {
			LT : 'HH:mm',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY HH:mm',
			LLLL : 'dddd, D MMMM YYYY HH:mm'
		},
		calendar : {
			sameDay : '[T~d~ t] LT',
			nextDay : '[T~m~rr~w t] LT',
			nextWeek : 'dddd [t] LT',
			lastDay : '[~st~rd~ t] LT',
			lastWeek : '[L~st] dddd [t] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : '~ %s',
			past : '%s ~g',
			s : ' ~fw ~sc~ds',
			ss : '%d s~c~ds',
			m : ' ~m~t',
			mm : '%d m~~ts',
			h : '~ h~r',
			hh : '%d h~rs',
			d : ' ~d',
			dd : '%d d~s',
			M : ' ~m~th',
			MM : '%d m~t~hs',
			y : ' ~r',
			yy : '%d ~rs'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		ordinal : function (number) {
			var b = number % 10,
				output = (~~(number % 100 / 10) === 1) ? 'th' :
					(b === 1) ? 'st' :
						(b === 2) ? 'nd' :
							(b === 3) ? 'rd' : 'th';
			return number + output;
		},
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('yo', {
		months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
		monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
		weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
		weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
		weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
		longDateFormat : {
			LT : 'h:mm A',
			LTS : 'h:mm:ss A',
			L : 'DD/MM/YYYY',
			LL : 'D MMMM YYYY',
			LLL : 'D MMMM YYYY h:mm A',
			LLLL : 'dddd, D MMMM YYYY h:mm A'
		},
		calendar : {
			sameDay : '[Oni ni] LT',
			nextDay : '[la ni] LT',
			nextWeek : 'dddd [s ton\'b] [ni] LT',
			lastDay : '[Ana ni] LT',
			lastWeek : 'dddd [s tol] [ni] LT',
			sameElse : 'L'
		},
		relativeTime : {
			future : 'ni %s',
			past : '%s kja',
			s : 'isju aaya die',
			ss :'aaya %d',
			m : 'isju kan',
			mm : 'isju %d',
			h : 'wakati kan',
			hh : 'wakati %d',
			d : 'j kan',
			dd : 'j %d',
			M : 'osu kan',
			MM : 'osu %d',
			y : 'dun kan',
			yy : 'dun %d'
		},
		dayOfMonthOrdinalParse : /j\s\d{1,2}/,
		ordinal : 'j %d',
		week : {
			dow : 1, // Monday is the first day of the week.
			doy : 4 // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('zh-cn', {
		months : '___________'.split('_'),
		monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY/MM/DD',
			LL : 'YYYYMD',
			LLL : 'YYYYMDAhmm',
			LLLL : 'YYYYMDddddAhmm',
			l : 'YYYY/M/D',
			ll : 'YYYYMD',
			lll : 'YYYYMD HH:mm',
			llll : 'YYYYMDdddd HH:mm'
		},
		meridiemParse: /|||||/,
		meridiemHour: function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '' || meridiem === '' ||
				meridiem === '') {
				return hour;
			} else if (meridiem === '' || meridiem === '') {
				return hour + 12;
			} else {
				// ''
				return hour >= 11 ? hour : hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			var hm = hour * 100 + minute;
			if (hm < 600) {
				return '';
			} else if (hm < 900) {
				return '';
			} else if (hm < 1130) {
				return '';
			} else if (hm < 1230) {
				return '';
			} else if (hm < 1800) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[]LT',
			nextDay : '[]LT',
			nextWeek : '[]ddddLT',
			lastDay : '[]LT',
			lastWeek : '[]ddddLT',
			sameElse : 'L'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(||)/,
		ordinal : function (number, period) {
			switch (period) {
				case 'd':
				case 'D':
				case 'DDD':
					return number + '';
				case 'M':
					return number + '';
				case 'w':
				case 'W':
					return number + '';
				default:
					return number;
			}
		},
		relativeTime : {
			future : '%s',
			past : '%s',
			s : '',
			ss : '%d ',
			m : '1 ',
			mm : '%d ',
			h : '1 ',
			hh : '%d ',
			d : '1 ',
			dd : '%d ',
			M : '1 ',
			MM : '%d ',
			y : '1 ',
			yy : '%d '
		},
		week : {
			// GB/T 7408-1994ISO 8601:1988
			dow : 1, // Monday is the first day of the week.
			doy : 4  // The week that contains Jan 4th is the first week of the year.
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('zh-hk', {
		months : '___________'.split('_'),
		monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY/MM/DD',
			LL : 'YYYYMD',
			LLL : 'YYYYMD HH:mm',
			LLLL : 'YYYYMDdddd HH:mm',
			l : 'YYYY/M/D',
			ll : 'YYYYMD',
			lll : 'YYYYMD HH:mm',
			llll : 'YYYYMDdddd HH:mm'
		},
		meridiemParse: /|||||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '' || meridiem === '' || meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === '' || meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			var hm = hour * 100 + minute;
			if (hm < 600) {
				return '';
			} else if (hm < 900) {
				return '';
			} else if (hm < 1130) {
				return '';
			} else if (hm < 1230) {
				return '';
			} else if (hm < 1800) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[]LT',
			nextDay : '[]LT',
			nextWeek : '[]ddddLT',
			lastDay : '[]LT',
			lastWeek : '[]ddddLT',
			sameElse : 'L'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(||)/,
		ordinal : function (number, period) {
			switch (period) {
				case 'd' :
				case 'D' :
				case 'DDD' :
					return number + '';
				case 'M' :
					return number + '';
				case 'w' :
				case 'W' :
					return number + '';
				default :
					return number;
			}
		},
		relativeTime : {
			future : '%s',
			past : '%s',
			s : '',
			ss : '%d ',
			m : '1 ',
			mm : '%d ',
			h : '1 ',
			hh : '%d ',
			d : '1 ',
			dd : '%d ',
			M : '1 ',
			MM : '%d ',
			y : '1 ',
			yy : '%d '
		}
	});

	//! moment.js locale configuration

	hooks.defineLocale('zh-tw', {
		months : '___________'.split('_'),
		monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
		weekdays : '______'.split('_'),
		weekdaysShort : '______'.split('_'),
		weekdaysMin : '______'.split('_'),
		longDateFormat : {
			LT : 'HH:mm',
			LTS : 'HH:mm:ss',
			L : 'YYYY/MM/DD',
			LL : 'YYYYMD',
			LLL : 'YYYYMD HH:mm',
			LLLL : 'YYYYMDdddd HH:mm',
			l : 'YYYY/M/D',
			ll : 'YYYYMD',
			lll : 'YYYYMD HH:mm',
			llll : 'YYYYMDdddd HH:mm'
		},
		meridiemParse: /|||||/,
		meridiemHour : function (hour, meridiem) {
			if (hour === 12) {
				hour = 0;
			}
			if (meridiem === '' || meridiem === '' || meridiem === '') {
				return hour;
			} else if (meridiem === '') {
				return hour >= 11 ? hour : hour + 12;
			} else if (meridiem === '' || meridiem === '') {
				return hour + 12;
			}
		},
		meridiem : function (hour, minute, isLower) {
			var hm = hour * 100 + minute;
			if (hm < 600) {
				return '';
			} else if (hm < 900) {
				return '';
			} else if (hm < 1130) {
				return '';
			} else if (hm < 1230) {
				return '';
			} else if (hm < 1800) {
				return '';
			} else {
				return '';
			}
		},
		calendar : {
			sameDay : '[] LT',
			nextDay : '[] LT',
			nextWeek : '[]dddd LT',
			lastDay : '[] LT',
			lastWeek : '[]dddd LT',
			sameElse : 'L'
		},
		dayOfMonthOrdinalParse: /\d{1,2}(||)/,
		ordinal : function (number, period) {
			switch (period) {
				case 'd' :
				case 'D' :
				case 'DDD' :
					return number + '';
				case 'M' :
					return number + '';
				case 'w' :
				case 'W' :
					return number + '';
				default :
					return number;
			}
		},
		relativeTime : {
			future : '%s',
			past : '%s',
			s : '',
			ss : '%d ',
			m : '1 ',
			mm : '%d ',
			h : '1 ',
			hh : '%d ',
			d : '1 ',
			dd : '%d ',
			M : '1 ',
			MM : '%d ',
			y : '1 ',
			yy : '%d '
		}
	});

	hooks.locale('en');

	return hooks;

})));
/*!
 * Modernizr v2.8.2
 * www.modernizr.com
 *
 * Copyright (c) Faruk Ates, Paul Irish, Alex Sexton
 * Available under the BSD and MIT licenses: www.modernizr.com/license/
 */
window.Modernizr=function(a,b,c){function d(a){t.cssText=a}function e(a,b){return d(x.join(a+";")+(b||""))}function f(a,b){return typeof a===b}function g(a,b){return!!~(""+a).indexOf(b)}function h(a,b){for(var d in a){var e=a[d];if(!g(e,"-")&&t[e]!==c)return"pfx"==b?e:!0}return!1}function i(a,b,d){for(var e in a){var g=b[a[e]];if(g!==c)return d===!1?a[e]:f(g,"function")?g.bind(d||b):g}return!1}function j(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+z.join(d+" ")+d).split(" ");return f(b,"string")||f(b,"undefined")?h(e,b):(e=(a+" "+A.join(d+" ")+d).split(" "),i(e,b,c))}function k(){o.input=function(c){for(var d=0,e=c.length;e>d;d++)E[c[d]]=!!(c[d]in u);return E.list&&(E.list=!(!b.createElement("datalist")||!a.HTMLDataListElement)),E}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),o.inputtypes=function(a){for(var d,e,f,g=0,h=a.length;h>g;g++)u.setAttribute("type",e=a[g]),d="text"!==u.type,d&&(u.value=v,u.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(e)&&u.style.WebkitAppearance!==c?(q.appendChild(u),f=b.defaultView,d=f.getComputedStyle&&"textfield"!==f.getComputedStyle(u,null).WebkitAppearance&&0!==u.offsetHeight,q.removeChild(u)):/^(search|tel)$/.test(e)||(d=/^(url|email)$/.test(e)?u.checkValidity&&u.checkValidity()===!1:u.value!=v)),D[a[g]]=!!d;return D}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var l,m,n="2.8.2",o={},p=!0,q=b.documentElement,r="modernizr",s=b.createElement(r),t=s.style,u=b.createElement("input"),v=":)",w={}.toString,x=" -webkit- -moz- -o- -ms- ".split(" "),y="Webkit Moz O ms",z=y.split(" "),A=y.toLowerCase().split(" "),B={svg:"http://www.w3.org/2000/svg"},C={},D={},E={},F=[],G=F.slice,H=function(a,c,d,e){var f,g,h,i,j=b.createElement("div"),k=b.body,l=k||b.createElement("body");if(parseInt(d,10))for(;d--;)h=b.createElement("div"),h.id=e?e[d]:r+(d+1),j.appendChild(h);return f=["&#173;",'<style id="s',r,'">',a,"</style>"].join(""),j.id=r,(k?j:l).innerHTML+=f,l.appendChild(j),k||(l.style.background="",l.style.overflow="hidden",i=q.style.overflow,q.style.overflow="hidden",q.appendChild(l)),g=c(j,a),k?j.parentNode.removeChild(j):(l.parentNode.removeChild(l),q.style.overflow=i),!!g},I=function(b){var c=a.matchMedia||a.msMatchMedia;if(c)return c(b)&&c(b).matches||!1;var d;return H("@media "+b+" { #"+r+" { position: absolute; } }",function(b){d="absolute"==(a.getComputedStyle?getComputedStyle(b,null):b.currentStyle).position}),d},J=function(){function a(a,e){e=e||b.createElement(d[a]||"div"),a="on"+a;var g=a in e;return g||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(a,""),g=f(e[a],"function"),f(e[a],"undefined")||(e[a]=c),e.removeAttribute(a))),e=null,g}var d={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return a}(),K={}.hasOwnProperty;m=f(K,"undefined")||f(K.call,"undefined")?function(a,b){return b in a&&f(a.constructor.prototype[b],"undefined")}:function(a,b){return K.call(a,b)},Function.prototype.bind||(Function.prototype.bind=function(a){var b=this;if("function"!=typeof b)throw new TypeError;var c=G.call(arguments,1),d=function(){if(this instanceof d){var e=function(){};e.prototype=b.prototype;var f=new e,g=b.apply(f,c.concat(G.call(arguments)));return Object(g)===g?g:f}return b.apply(a,c.concat(G.call(arguments)))};return d}),C.flexbox=function(){return j("flexWrap")},C.flexboxlegacy=function(){return j("boxDirection")},C.canvas=function(){var a=b.createElement("canvas");return!(!a.getContext||!a.getContext("2d"))},C.canvastext=function(){return!(!o.canvas||!f(b.createElement("canvas").getContext("2d").fillText,"function"))},C.webgl=function(){return!!a.WebGLRenderingContext},C.touch=function(){var c;return"ontouchstart"in a||a.DocumentTouch&&b instanceof DocumentTouch?c=!0:H(["@media (",x.join("touch-enabled),("),r,")","{#modernizr{top:9px;position:absolute}}"].join(""),function(a){c=9===a.offsetTop}),c},C.geolocation=function(){return"geolocation"in navigator},C.postmessage=function(){return!!a.postMessage},C.websqldatabase=function(){return!!a.openDatabase},C.indexedDB=function(){return!!j("indexedDB",a)},C.hashchange=function(){return J("hashchange",a)&&(b.documentMode===c||b.documentMode>7)},C.history=function(){return!(!a.history||!history.pushState)},C.draganddrop=function(){var a=b.createElement("div");return"draggable"in a||"ondragstart"in a&&"ondrop"in a},C.websockets=function(){return"WebSocket"in a||"MozWebSocket"in a},C.rgba=function(){return d("background-color:rgba(150,255,150,.5)"),g(t.backgroundColor,"rgba")},C.hsla=function(){return d("background-color:hsla(120,40%,100%,.5)"),g(t.backgroundColor,"rgba")||g(t.backgroundColor,"hsla")},C.multiplebgs=function(){return d("background:url(https://),url(https://),red url(https://)"),/(url\s*\(.*?){3}/.test(t.background)},C.backgroundsize=function(){return j("backgroundSize")},C.borderimage=function(){return j("borderImage")},C.borderradius=function(){return j("borderRadius")},C.boxshadow=function(){return j("boxShadow")},C.textshadow=function(){return""===b.createElement("div").style.textShadow},C.opacity=function(){return e("opacity:.55"),/^0.55$/.test(t.opacity)},C.cssanimations=function(){return j("animationName")},C.csscolumns=function(){return j("columnCount")},C.cssgradients=function(){var a="background-image:",b="gradient(linear,left top,right bottom,from(#9f9),to(white));",c="linear-gradient(left top,#9f9, white);";return d((a+"-webkit- ".split(" ").join(b+a)+x.join(c+a)).slice(0,-a.length)),g(t.backgroundImage,"gradient")},C.cssreflections=function(){return j("boxReflect")},C.csstransforms=function(){return!!j("transform")},C.csstransforms3d=function(){var a=!!j("perspective");return a&&"webkitPerspective"in q.style&&H("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",function(b){a=9===b.offsetLeft&&3===b.offsetHeight}),a},C.csstransitions=function(){return j("transition")},C.fontface=function(){var a;return H('@font-face {font-family:"font";src:url("https://")}',function(c,d){var e=b.getElementById("smodernizr"),f=e.sheet||e.styleSheet,g=f?f.cssRules&&f.cssRules[0]?f.cssRules[0].cssText:f.cssText||"":"";a=/src/i.test(g)&&0===g.indexOf(d.split(" ")[0])}),a},C.generatedcontent=function(){var a;return H(["#",r,"{font:0/0 a}#",r,':after{content:"',v,'";visibility:hidden;font:3px/1 a}'].join(""),function(b){a=b.offsetHeight>=3}),a},C.video=function(){var a=b.createElement("video"),c=!1;try{(c=!!a.canPlayType)&&(c=new Boolean(c),c.ogg=a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,""),c.h264=a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,""),c.webm=a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,""))}catch(d){}return c},C.audio=function(){var a=b.createElement("audio"),c=!1;try{(c=!!a.canPlayType)&&(c=new Boolean(c),c.ogg=a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),c.mp3=a.canPlayType("audio/mpeg;").replace(/^no$/,""),c.wav=a.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),c.m4a=(a.canPlayType("audio/x-m4a;")||a.canPlayType("audio/aac;")).replace(/^no$/,""))}catch(d){}return c},C.localstorage=function(){try{return localStorage.setItem(r,r),localStorage.removeItem(r),!0}catch(a){return!1}},C.sessionstorage=function(){try{return sessionStorage.setItem(r,r),sessionStorage.removeItem(r),!0}catch(a){return!1}},C.webworkers=function(){return!!a.Worker},C.applicationcache=function(){return!!a.applicationCache},C.svg=function(){return!!b.createElementNS&&!!b.createElementNS(B.svg,"svg").createSVGRect},C.inlinesvg=function(){var a=b.createElement("div");return a.innerHTML="<svg/>",(a.firstChild&&a.firstChild.namespaceURI)==B.svg},C.smil=function(){return!!b.createElementNS&&/SVGAnimate/.test(w.call(b.createElementNS(B.svg,"animate")))},C.svgclippaths=function(){return!!b.createElementNS&&/SVGClipPath/.test(w.call(b.createElementNS(B.svg,"clipPath")))};for(var L in C)m(C,L)&&(l=L.toLowerCase(),o[l]=C[L](),F.push((o[l]?"":"no-")+l));return o.input||k(),o.addTest=function(a,b){if("object"==typeof a)for(var d in a)m(a,d)&&o.addTest(d,a[d]);else{if(a=a.toLowerCase(),o[a]!==c)return o;b="function"==typeof b?b():b,"undefined"!=typeof p&&p&&(q.className+=" "+(b?"":"no-")+a),o[a]=b}return o},d(""),s=u=null,function(a,b){function c(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function d(){var a=s.elements;return"string"==typeof a?a.split(" "):a}function e(a){var b=r[a[p]];return b||(b={},q++,a[p]=q,r[q]=b),b}function f(a,c,d){if(c||(c=b),k)return c.createElement(a);d||(d=e(c));var f;return f=d.cache[a]?d.cache[a].cloneNode():o.test(a)?(d.cache[a]=d.createElem(a)).cloneNode():d.createElem(a),!f.canHaveChildren||n.test(a)||f.tagUrn?f:d.frag.appendChild(f)}function g(a,c){if(a||(a=b),k)return a.createDocumentFragment();c=c||e(a);for(var f=c.frag.cloneNode(),g=0,h=d(),i=h.length;i>g;g++)f.createElement(h[g]);return f}function h(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?f(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+d().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function i(a){a||(a=b);var d=e(a);return!s.shivCSS||j||d.hasCSS||(d.hasCSS=!!c(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||h(a,d),a}var j,k,l="3.7.0",m=a.html5||{},n=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,o=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,p="_html5shiv",q=0,r={};!function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",j="hidden"in a,k=1==a.childNodes.length||function(){b.createElement("a");var a=b.createDocumentFragment();return"undefined"==typeof a.cloneNode||"undefined"==typeof a.createDocumentFragment||"undefined"==typeof a.createElement}()}catch(c){j=!0,k=!0}}();var s={elements:m.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:l,shivCSS:m.shivCSS!==!1,supportsUnknownElements:k,shivMethods:m.shivMethods!==!1,type:"default",shivDocument:i,createElement:f,createDocumentFragment:g};a.html5=s,i(b)}(this,b),o._version=n,o._prefixes=x,o._domPrefixes=A,o._cssomPrefixes=z,o.mq=I,o.hasEvent=J,o.testProp=function(a){return h([a])},o.testAllProps=j,o.testStyles=H,o.prefixed=function(a,b,c){return b?j(a,b,c):j(a,"pfx")},q.className=q.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(p?" js "+F.join(" "):""),o}(this,this.document);

define("modernizr", function(){});

/*
 This file is part of SMAP.

 SMAP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 uSMAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

 */

/*
 * Chart functions
 */



define('app/summary_report',[
        'jquery',
        'modernizr',
        'localise',
        'globals'],
    function ($, modernizr, lang, globals) {

        var gCharts = [];
        
        return {
            getXLSData: getXLSData
        };

        function init(chartView, timingView) {

        }

        /*
         * Get XLS Data from charts
         * If all data is set true then ignore the current charts and generate counts for all questions
         */
        function getXLSData(alldata) {

            var results = globals.gMainTable.rows({
                order: 'current',  // 'current', 'applied', 'index',  'original'
                page: 'all',      // 'all',     'current'
                search: 'applied',     // 'none',    'applied', 'removed'
            }).data();

            var i,
                data,
                chart,
                chartArray = [],
                dataLength = results.count(),
                xlsResponse = [],
                groupIdx;

            if(alldata) {
                // Create an array of dummy charts that will generate the counts
                var columns = gTasks.cache.currentData.schema.columns;
                for (i = 0; i < columns.length; i++) {
                    if (columns[i].chartQuestion) {

                        chart = {
                            title: columns[i].select_name ? columns[i].select_name : columns[i].displayName,
                            tSeries: false,
                            chart_type: "other",
                            fn: getChartFunction(columns[i].type),
                            groups: [{
                                name: columns[i].select_name ? columns[i].select_name  : columns[i].displayName,
                                dataLabel: columns[i].select_name ? columns[i].select_name  : columns[i].displayName,
                                l_id: columns[i].l_id,
                                type: columns[i].type
                            }
                            ]
                        }

                        if (columns[i].type === "select") {
                            chart.groups[0].choiceNames = columns[i].choiceNames;
                            chart.groups[0].choices = columns[i].choices;
                        }

                        groupIdx = $('#srf_group').val();
                        if(groupIdx == i) {
                            continue;   // Don't create a chart of the question grouped by itself
                        }
                        if(groupIdx != -1) {
                            chart.groups.push({
                                name: columns[groupIdx].select_name ? columns[groupIdx].select_name  : columns[groupIdx].displayName,
                                    dataLabel: columns[groupIdx].select_name ? columns[groupIdx].select_name  : columns[groupIdx].displayName,
                                l_id: columns[groupIdx].l_id,
                                type: columns[groupIdx].type
                            });

                            if (columns[groupIdx].type === "select" || columns[groupIdx].type === "select1") {
                                chart.groups[1].choiceNames = columns[groupIdx].choiceNames;
                                chart.groups[1].choices = columns[groupIdx].choices;
                            }
                        }
                        chartArray.push(chart);
                    }
                }
            } else {
                chartArray = gCharts;
            }

            for (i = 0; i < chartArray.length; i++) {

                chart = chartArray[i];
                data = processData(results, chart, dataLength);
                getXlsResponseObject(xlsResponse, chart, data);

            }

            return xlsResponse;
        }


        /*
         * Add a charts data to the xlsResponse object if the data is to be sent to an XLS export
         * The data has to be transformed into a two dimensional array so it can be processed by the Java server
         */
        function getXlsResponseObject(xlsResponse, chart, data) {
            var newData,
                twoDim = [],
                i, j, k,
                add = false;

            if (chart.tSeries) {
                newData = data;
                add = true;

            } else if (chart.chart_type === "wordcloud") {
                // the data for word clouds is in an object
                 add = true;
                 for (var p in data) {
                    if (data.hasOwnProperty(p)) {
                        twoDim.push({
                            key: p,
                            pr: [{
                                key: chart.groups[0].dataLabel,
                                value: data[p]
                            }]
                        });
                     }
                 }

            } else {
                // Rollup the data as per the chart settings

                var add = true;
                var rows = data.length;
                if(chart.fn === "percent" && rows === 0) {
                    return;
                }

                var groupsObject = {};
                // Get the number of entries per row for calculating percentage
                if(chart.fn === "percent") {
                    var groupRows = d3.nest()
                        .key(function (d) {
                            return d[chart.groups[1].name];
                        })
                        .rollup(function (v) {
                            return v.length;
                        })
                        .entries(data);

                    for(i = 0; i < groupRows.length; i++) {
                        groupsObject["x" + groupRows[i].key] = groupRows[i].value;
                    }
                }

                if(chart.groups.length === 1) {
                    if(chart.fn === "count" || chart.fn === "percent") {

                        newData = d3.nest()
                            .key(function (d) {
                                return d[chart.groups[0].name];
                            })
                            .rollup(function (v) {
                                if(chart.fn === "count") {
                                    return v.length;
                                } else {
                                    return v.length * 100 / rows;
                                }
                            })
                            .entries(data);
                    } else {
                        newData = d3.nest()
                            .key(function (d) {
                                return chart.groups[0].name;
                            })
                            .rollup(function (v) {
                               if (chart.fn === "average") {
                                    return d3.mean(v, function (d) {
                                        var val = +d[chart.groups[0].name];
                                        return val;
                                    });
                                } else if(chart.fn === "sum") {
                                    return d3.sum(v, function (d) {
                                       var val = +d[chart.groups[0].name];
                                       return val;
                                    });
                                } else if(chart.fn === "min") {
                                   return d3.min(v, function (d) {
                                       var val = +d[chart.groups[0].name];
                                       return val;
                                   });
                               } else if(chart.fn === "max") {
                                   return d3.max(v, function (d) {
                                       var val = +d[chart.groups[0].name];
                                       return val;
                                   });
                               }
                            })
                            .entries(data);
                    }
                } else {
                    if(chart.fn === "count" || chart.fn === "percent") {

                        newData = d3.nest()
                            .key(function (d) {
                                return d[chart.groups[0].name];
                            })
                            .key(function (d) {
                                return d[chart.groups[1].name];
                            })
                            .rollup(function (v) {
                                return v.length;
                            })
                            .entries(data);

                        if(chart.fn === "percent") {
                            for(i = 0; i < newData.length; i++) {
                                for(j = 0; j < newData[i].values.length; j++) {
                                    if (groupsObject["x" + newData[i].values[j].key] == 0) {
                                        newData[i].values[j].value = 0;
                                    } else {
                                        newData[i].values[j].value = newData[i].values[j].value * 100 / groupsObject["x" + newData[i].values[j].key];
                                    }
                                }
                            }
                        }
                    } else {
                        newData = d3.nest()
                            .key(function (d) {
                                return d[chart.groups[1].name];
                            })
                            .rollup(function (v) {
                               if (chart.fn === "average") {
                                   return d3.mean(v, function (d) {
                                       var val = +d[chart.groups[0].name];
                                       return val;
                                   });
                                } else if(chart.fn === "sum") {
                                    return d3.sum(v, function (d) {
                                        var val = +d[chart.groups[0].name];
                                        return val;
                                    });
                                } else if(chart.fn === "min") {
                                   return d3.min(v, function (d) {
                                       var val = +d[chart.groups[0].name];
                                       return val;
                                   });
                               } else if(chart.fn === "max") {
                                   return d3.max(v, function (d) {
                                       var val = +d[chart.groups[0].name];
                                       return val;
                                   });
                               }
                            })
                            .entries(data);
                    }
                }

                // Get the array of labels
                var labelArray = [];
                for(i = 0; i < chart.groups.length; i++) {
                    labelArray.push(chart.groups[i].dataLabel);
                }

                // Get the array of columns
                var columnArray = [];
                if(chart.groups.length === 2 && (chart.fn === "count" || chart.fn === "percent")) {
                    for(i = 0; i < newData.length; i++) {
                        for(j = 0; j < newData[i].values.length; j++) {
                            var key = newData[i].values[j].key;
                            if(columnArray.indexOf(key) < 0) {
                                columnArray.push(key);
                            }
                        }
                    }
                }

                // Normalise 2 dimensional array
                for(i = 0; i < newData.length; i++) {

                    var item = {
                        key: newData[i].key,
                        pr: []
                    };

                    if(chart.groups.length === 1 || (chart.fn !== "count" && chart.fn !== "percent")) {
                        item.pr.push({
                            key: chart.fn,
                            value: newData[i].value
                        });
                    }
                    if(chart.groups.length === 2) {
                        for(j = 0; j < columnArray.length; j++) {
                            var hasValue = false;
                            for(k = 0; k < newData[i].values.length; k++) {
                                if(newData[i].values[k].key === columnArray[j]) {
                                    item.pr.push({
                                        key: columnArray[j],
                                        value: newData[i].values[k].value
                                    });
                                    hasValue = true;
                                    break;
                                }
                            }
                            if(!hasValue) {
                                item.pr.push({
                                    key: columnArray[j],
                                    value: 0
                                });
                            }

                        }

                    }

                    twoDim.push(item);
                }

            }

            var responseItem = {
                chart_type: chart.chart_type,
                name: chart.title,
                fn: chart.fn,
                labels: labelArray,
                columns: columnArray,
                data: twoDim
            };

            xlsResponse.push(responseItem);

        }

        /*
         * Generate data suitable for charting from the results
         */
        function processData(results, chart, dataLength) {
            var i, j,
                columns = gTasks.cache.currentData.schema.columns,
                datalabel = chart.qlabel ? 'label' : 'name';

            if (!gTasks.cache.surveyConfig.processedData) {
                gTasks.cache.surveyConfig.processedData = {};
            }

            if (chart.groups[0].type === "select" || (chart.groups.length > 1 && chart.groups[1].type === "select")) {
                return processSelectMultipleData(results, chart, dataLength);
            } else {
                if (!gTasks.cache.surveyConfig.processedData[datalabel]) {

                    gTasks.cache.surveyConfig.processedData[datalabel] = [];
                    for (i = 0; i < results.length; i++) {
                        var di = {};
                        di.count = 1;
                        for (j = 0; j < columns.length; j++) {
                            var val = results[i][columns[j].column_name];
                            if(columns[j].l_id > 0) {
                                if(chart.qlabel) {
                                    val = lookupChoiceLabel(columns[j].l_id, val);  // Convert to the default label
                                }
                            }
                            di[columns[j].displayName] = val;
                        }
                        if (!di["Survey Duration"]) {         // Make sure durations have a number
                            di["Survey Duration"] = 0;
                        }
                        di["Survey Duration"] = +di["Survey Duration"];
                        gTasks.cache.surveyConfig.processedData[datalabel].push(di);
                    }
                }
                return gTasks.cache.surveyConfig.processedData[datalabel];
            }
        }


        /*
         * Process the wordcloud data
         */
        function processSelectMultipleData(results, chart, dataLength) {

            var data = [],
                groups,
                i, j,
                selM,
                nonM,
                row,
                choiceValues,
                val,
                selectedValues;

            // Get index of select multiple
            groups = chart.groups;
            if(chart.groups[0].type == "select") {
                selM = chart.groups[0];
                if(chart.groups.length > 0) {
                    nonM = chart.groups[1];
                }
            } else {
                nonM = chart.groups[0];
                selM = chart.groups[1];
            }

            // Get the choice values from the choices which have the question name in them
            var choiceLists = gTasks.cache.currentData.schema.choiceLists;
            for(i = 0; i < choiceLists.length; i++) {
                if(choiceLists[i].l_id == selM.l_id) {
                    choiceValues = choiceLists[i].choices;
                    break;
                }
            }

            for(i = 0; i < results.length; i++) {
                if(results[i][selM.dataLabel]) {
                    selectedValues = results[i][selM.dataLabel].split(" ");

                    for(j = 0; j < selectedValues.length; j++) {
                        // add a row
                        row = {
                            count: 1
                        };

                        if(chart.qlabel) {
                            val = lookupChoiceLabel(selM.l_id, selectedValues[j]);
                        } else {
                            val = selectedValues[j];
                        }

                        row[selM.dataLabel] = val;
                        if(nonM) {
                            row[nonM.dataLabel] = results[i][nonM.dataLabel];
                        }
                        data.push(row);
                    }
                }

            }

            return data;
        }

        /*
         * get the chart function from the question type
         */
        function getChartFunction(type) {
            if(type === "decimal" || type === "int" || type === "duration") {
                // numeric
                return $('#srf_num_fn').val();
            } else {
                return $('#srf_text_fn').val();
            }
        }

    });

/*
 This file is part of SMAP.

 SMAP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 uSMAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

 */

/*
 * Chart functions
 * Uses: https://www.chartjs.org/
 */



define('app/chart',[
        'jquery',
        'modernizr',
        'localise',
        'globals'],
    function ($, modernizr, localise, globals) {

        var charts = [];
        //var barColors = ["red", "green","blue","orange","brown"];
        var barColors = ["#e60049", "#0bb4ff", "#50e991", "#e6d800", "#9b19f5", "#ffa300", "#dc0ab4", "#b3d4ff", "#00bfa0"];  // River nights from: https://www.heavy.ai/blog/12-color-palettes-for-telling-better-stories-with-your-data

        return {
            add: add,
            replace: replace,
            refresh: refresh,
            remove: remove,
            clear: clear
        };

        function add(settings) {

            if(!gTasks.cache.currentData) {
                // Data not available yet.
                return;
            }

            var item = {
                source: {
                    subject: settings.subject
                },
                config: updateConfigFromSettings({
                    type: settings.chart_type,
                    responsive: true,
                    data: {
                        labels: [],
                        datasets:[{
                            label: settings.label,
                            backgroundColor: barColors,
                            borderColor: 'rgb(0, 0, 0)',
                            data: [],
                        }]
                    },
                    options: {}
                }, settings)
            };

            // Set the data key
            var cd = gTasks.cache.currentData.case;
            if(settings.subject === 'status') {
                item.source.key = cd.settings.statusQuestion;
            } else  if(settings.subject === 'assigned') {
                item.source.key = "_assigned";
            } else  if(settings.subject === 'alert') {
                item.source.key = "_alert";
            } else  if(settings.subject === 'criticality') {
                item.source.key = cd.settings.criticalityQuestion;
            }

            // create the canvas element
            var label = settings.label;
            var index = charts.length;
            var card = `<div class="col-sm-12 col-md-6 col-lg-3">
                                    <div class="card">
                                        <div class="card-header d-flex chart-header">
                                            <span class="mr-auto">${label}</span>
                                            <i class="fa fa-trash text-danger pr-2" data-idx="${index}"></i>
                                            <i class="fa fa-cog" data-idx="${index}"></i>
                                        </div>
                                        <div class="card-body">
                                            <canvas id="chart${index}"></canvas>
                                        </div>
                                    </div>
                                </div>`;
            $('#chartcontent').append(card);

            // Associate the canvas element with the chart
            item.chart = new Chart(
                document.getElementById('chart' + charts.length),
                item.config
            );
            charts.push(item);
        }

        function replace(settings, index) {
            charts[index].config = updateConfigFromSettings(charts[index].config, settings);
            charts[index].chart.update();
        }

        function remove(index) {
            charts[index].chart.destroy();
            charts.splice(index,1);
        }

        function updateConfigFromSettings(config, settings) {
            config.type = settings.chart_type;
            config.data.datasets[0].backgroundColor = barColors;

            if(config.type === 'col') {
                config.type = 'bar';

            } else if(config.type === 'bar') {
                config.options.indexAxis = 'y';
            }

            return config;
        }

        /*
         * Clear existing charts
         */
       function clear() {
           for(var chartIdx = 0; chartIdx < charts.length; chartIdx++) {
               charts[chartIdx].chart.destroy();
           }
           charts = [];
           $('#chartcontent').empty();
        }

        /*
         * Extract the data in chart form
         */
        function refresh() {


            if(!gTasks.cache.currentData) {
                // Data not available yet.
                return;
            }

            var cd = gTasks.cache.currentData.case;
            var results = globals.gMainTable.rows({
                order: 'current',  // 'current', 'applied', 'index',  'original'
                page: 'all',      // 'all',     'current'
                search: 'applied',     // 'none',    'applied', 'removed'
            }).data();

            if(cd.settings.finalStatus && cd.settings.statusQuestion) {
                for(var chartIdx = 0; chartIdx < charts.length; chartIdx++) {

                    var key = charts[chartIdx].source.key;
                    var chartData = {};

                    for (var i = 0; i < results.length; i++) {

                        var val = results[i][key];

                        // ignore records without an alert when getting alert chart data
                        if (key === '_alert' && val.trim().length === 0) {
                            continue;
                        } else if (val === "") {
                            val = localise.set["c_none"];
                        }

                        chartData[val] = chartData[val] || 0; // Ensure value is numeric
                        chartData[val]++;

                    }
                    updateChart(charts[chartIdx].config, chartData, charts[chartIdx].chart);
                }
            }

        }

        function updateChart(config, data, chart) {
            var keys = Object.keys(data).sort();

            config.data.labels = [];
            config.data.datasets[0].data = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                config.data.labels.push(key);
                config.data.datasets[0].data.push(data[key]);
            }
            chart.update();
        }
    });
/*! iCheck v1.0.2 by Damir Sultanov, http://git.io/arlzeA, MIT Licensed */
(function(f){function A(a,b,d){var c=a[0],g=/er/.test(d)?_indeterminate:/bl/.test(d)?n:k,e=d==_update?{checked:c[k],disabled:c[n],indeterminate:"true"==a.attr(_indeterminate)||"false"==a.attr(_determinate)}:c[g];if(/^(ch|di|in)/.test(d)&&!e)x(a,g);else if(/^(un|en|de)/.test(d)&&e)q(a,g);else if(d==_update)for(var f in e)e[f]?x(a,f,!0):q(a,f,!0);else if(!b||"toggle"==d){if(!b)a[_callback]("ifClicked");e?c[_type]!==r&&q(a,g):x(a,g)}}function x(a,b,d){var c=a[0],g=a.parent(),e=b==k,u=b==_indeterminate,
    v=b==n,s=u?_determinate:e?y:"enabled",F=l(a,s+t(c[_type])),B=l(a,b+t(c[_type]));if(!0!==c[b]){if(!d&&b==k&&c[_type]==r&&c.name){var w=a.closest("form"),p='input[name="'+c.name+'"]',p=w.length?w.find(p):f(p);p.each(function(){this!==c&&f(this).data(m)&&q(f(this),b)})}u?(c[b]=!0,c[k]&&q(a,k,"force")):(d||(c[b]=!0),e&&c[_indeterminate]&&q(a,_indeterminate,!1));D(a,e,b,d)}c[n]&&l(a,_cursor,!0)&&g.find("."+C).css(_cursor,"default");g[_add](B||l(a,b)||"");g.attr("role")&&!u&&g.attr("aria-"+(v?n:k),"true");
    g[_remove](F||l(a,s)||"")}function q(a,b,d){var c=a[0],g=a.parent(),e=b==k,f=b==_indeterminate,m=b==n,s=f?_determinate:e?y:"enabled",q=l(a,s+t(c[_type])),r=l(a,b+t(c[_type]));if(!1!==c[b]){if(f||!d||"force"==d)c[b]=!1;D(a,e,s,d)}!c[n]&&l(a,_cursor,!0)&&g.find("."+C).css(_cursor,"pointer");g[_remove](r||l(a,b)||"");g.attr("role")&&!f&&g.attr("aria-"+(m?n:k),"false");g[_add](q||l(a,s)||"")}function E(a,b){if(a.data(m)){a.parent().html(a.attr("style",a.data(m).s||""));if(b)a[_callback](b);a.off(".i").unwrap();
    f(_label+'[for="'+a[0].id+'"]').add(a.closest(_label)).off(".i")}}function l(a,b,f){if(a.data(m))return a.data(m).o[b+(f?"":"Class")]}function t(a){return a.charAt(0).toUpperCase()+a.slice(1)}function D(a,b,f,c){if(!c){if(b)a[_callback]("ifToggled");a[_callback]("ifChanged")[_callback]("if"+t(f))}}var m="iCheck",C=m+"-helper",r="radio",k="checked",y="un"+k,n="disabled";_determinate="determinate";_indeterminate="in"+_determinate;_update="update";_type="type";_click="click";_touch="touchbegin.i touchend.i";
    _add="addClass";_remove="removeClass";_callback="trigger";_label="label";_cursor="cursor";_mobile=/ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);f.fn[m]=function(a,b){var d='input[type="checkbox"], input[type="'+r+'"]',c=f(),g=function(a){a.each(function(){var a=f(this);c=a.is(d)?c.add(a):c.add(a.find(d))})};if(/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(a))return a=a.toLowerCase(),g(this),c.each(function(){var c=
        f(this);"destroy"==a?E(c,"ifDestroyed"):A(c,!0,a);f.isFunction(b)&&b()});if("object"!=typeof a&&a)return this;var e=f.extend({checkedClass:k,disabledClass:n,indeterminateClass:_indeterminate,labelHover:!0},a),l=e.handle,v=e.hoverClass||"hover",s=e.focusClass||"focus",t=e.activeClass||"active",B=!!e.labelHover,w=e.labelHoverClass||"hover",p=(""+e.increaseArea).replace("%","")|0;if("checkbox"==l||l==r)d='input[type="'+l+'"]';-50>p&&(p=-50);g(this);return c.each(function(){var a=f(this);E(a);var c=this,
        b=c.id,g=-p+"%",d=100+2*p+"%",d={position:"absolute",top:g,left:g,display:"block",width:d,height:d,margin:0,padding:0,background:"#fff",border:0,opacity:0},g=_mobile?{position:"absolute",visibility:"hidden"}:p?d:{position:"absolute",opacity:0},l="checkbox"==c[_type]?e.checkboxClass||"icheckbox":e.radioClass||"i"+r,z=f(_label+'[for="'+b+'"]').add(a.closest(_label)),u=!!e.aria,y=m+"-"+Math.random().toString(36).substr(2,6),h='<div class="'+l+'" '+(u?'role="'+c[_type]+'" ':"");u&&z.each(function(){h+=
        'aria-labelledby="';this.id?h+=this.id:(this.id=y,h+=y);h+='"'});h=a.wrap(h+"/>")[_callback]("ifCreated").parent().append(e.insert);d=f('<ins class="'+C+'"/>').css(d).appendTo(h);a.data(m,{o:e,s:a.attr("style")}).css(g);e.inheritClass&&h[_add](c.className||"");e.inheritID&&b&&h.attr("id",m+"-"+b);"static"==h.css("position")&&h.css("position","relative");A(a,!0,_update);if(z.length)z.on(_click+".i mouseover.i mouseout.i "+_touch,function(b){var d=b[_type],e=f(this);if(!c[n]){if(d==_click){if(f(b.target).is("a"))return;
        A(a,!1,!0)}else B&&(/ut|nd/.test(d)?(h[_remove](v),e[_remove](w)):(h[_add](v),e[_add](w)));if(_mobile)b.stopPropagation();else return!1}});a.on(_click+".i focus.i blur.i keyup.i keydown.i keypress.i",function(b){var d=b[_type];b=b.keyCode;if(d==_click)return!1;if("keydown"==d&&32==b)return c[_type]==r&&c[k]||(c[k]?q(a,k):x(a,k)),!1;if("keyup"==d&&c[_type]==r)!c[k]&&x(a,k);else if(/us|ur/.test(d))h["blur"==d?_remove:_add](s)});d.on(_click+" mousedown mouseup mouseover mouseout "+_touch,function(b){var d=
        b[_type],e=/wn|up/.test(d)?t:v;if(!c[n]){if(d==_click)A(a,!1,!0);else{if(/wn|er|in/.test(d))h[_add](e);else h[_remove](e+" "+t);if(z.length&&B&&e==v)z[/ut|nd/.test(d)?_remove:_add](w)}if(_mobile)b.stopPropagation();else return!1}})})}})(window.jQuery||window.Zepto);

define("icheck", function(){});

/*
 This file is part of SMAP.

 SMAP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 uSMAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

 */

/*
 * Open layers 3 functions
 */



define('app/mapOL3',[
        'jquery',
        'modernizr',
        'localise',
        'globals',
        'icheck'],
    function ($, modernizr, lang, globals) {


        var gMap,
            gLayers = [],
            gVectorSources = [],
            gVectorLayers = [],
            gMapUpdatePending = true,
            gSelectFeature;

        return {
            setLayers: setLayers,
            refreshLayer: refreshLayer,
            refreshAllLayers: refreshAllLayers,
            saveLayer: saveLayer,
            deleteLayers: deleteLayers,
            initDynamicMap: initDynamicMap,
            clearSelectFeatures: clearSelectFeatures,
            setSelectedFeature: setSelectedFeature
        };

        function deleteLayers() {
            if(gLayers) {
                for(i = 0; i < gLayers.length; i++) {
                    deleteLayer(i);
                }
            }
        }

        function setLayers(layers, map) {

            var i;

            console.log("====== set layers: ");

            /*
             * Delete existing layers
             */
            deleteLayers();

            /*
             * Add new layers
             */
            gLayers = layers;
            // Add default data layer
            var layer = {
                title: localise.set["c_data"],
                local: true,
                clump: undefined,
                enabled: true,
                fixed: true
            };
            if(gLayers.length < 2) {
                gLayers.push(layer);
            } else {
                gLayers[0] = layer;     // replace
            }
            layer = {
                title: localise.set["c_heatmap"],
                local: true,
                clump: "heatmap",
                enabled: false,
                fixed: true
            };
            if(gLayers.length < 2) {
                gLayers.push(layer);
            } else {
                gLayers[1] = layer;     // replace
            }

            showLayerSelections(map);
        };


        /*
         * Show layer selections on the screen
         */
        function showLayerSelections(map) {
            var h = [],
                idx = -1,
                i;

            for (i = 0; i < gLayers.length; i++) {
                h[++idx] = '<tr>';

                h[++idx] = '<td>';      // Select
                h[++idx] = '<div class="switch custom-control custom-checkbox">';
                h[++idx] = '<input type="checkbox" class="custom-control-input layerSelect" name="columnSelect"';
                if(gLayers[i].enabled) {
                    h[++idx] = 'checked="checked"';
                }
                h[++idx] = ' value="';
                h[++idx] = i;
                h[++idx] = '"';
                h[++idx] = ' id="layer' + i + '"';
                h[++idx] = '>';
                h[++idx] = '<label class="custom-control-label" for="layer' + i + '">';
                h[++idx] = gLayers[i].title;
                h[++idx] = '</label>';
                h[++idx] = '</div>';
                h[++idx] = '</td>';
                h[++idx] = '<td>';      // Delete
                h[++idx] = '<button type="button" data-idx="';
                h[++idx] = i;
                h[++idx] = '" class="btn btn-default btn-sm rm_layer danger"';
                if(gLayers[i].fixed) {
                    h[++idx] = ' disabled';
                }
                h[++idx] = '>';
                h[++idx] = '<span class="glyphicon glyphicon-trash" aria-hidden="true"></span></button>';
                h[++idx] = '</td>';

                h[++idx] = '</tr>';
            }


            $('#layerSelect tbody').empty().html(h.join(''));
            //$('input', '#layerSelect tbody').iCheck({
            //    checkboxClass: 'icheckbox_square-green',
            //    radioClass: 'iradio_square-green'
            //});
            $('.rm_layer', '#layerSelect tbody').click(function() {
                var idx = $(this).data("idx");
                deleteLayer(idx);
                gLayers.splice(idx, 1);
                showLayerSelections(gMap);
            });

            $('.layerSelect').change(function() {
                var $this = $(this);
                var index = $(this).val();
               if($this.prop('checked')) {
                   showLayer(index, map);
               } else {
                   hideLayer(index, map);
               }
            });
        }

        /*
         * Redisplay a single layer
         */
        function refreshLayer(index, map) {

            if (map) {
                var results = globals.gMainTable.rows({
                    order: 'current',  // 'current', 'applied', 'index',  'original'
                    page: 'all',      // 'all',     'current'
                    search: 'applied',     // 'none',    'applied', 'removed'
                }).data();

                updateSingleLayer(index, results, map);
            }
        }

        /*
         * Redisplay all layers
         */
        function refreshAllLayers(mapView, map) {
            console.log("====== refresh all layers: " + mapView);
            if (mapView) {
                if (map) {
                    var i;
                    var results = globals.gMainTable.rows({
                        order: 'current',  // 'current', 'applied', 'index',  'original'
                        page: 'all',      // 'all',     'current'
                        search: 'applied',     // 'none',    'applied', 'removed'
                    }).data();

                    for (i = 0; i < gLayers.length; i++) {
                        deleteLayer(i);
                        updateSingleLayer(i, results, map);
                    }
                }
                gMapUpdatePending = false;
            } else {
                gMapUpdatePending = true;
            }
        }

        /*
         * Set up a single layer
         * This function is called by both refreshLayer and refreshAllLayers as refreshLayer has to do some setup
         *  that is also done by refreshAllLayers
         */
        function updateSingleLayer(index, results, map) {

            var layer = gLayers[index];
            var geoJson = getGeoJson(results, layer);		// Get a geoson of data

            if (!gVectorSources[index]) {
                gVectorSources[index] = new ol.source.Vector();
            } else {
                gVectorSources[index].clear();
            }
            gVectorSources[index].addFeatures((new ol.format.GeoJSON()).readFeatures(geoJson,
                {
                    dataProjection: 'EPSG:4326',
                    featureProjection: 'EPSG:3857'
                }));


            if (layer.clump === "heatmap") {
                gVectorLayers[index] = new ol.layer.Heatmap({
                    source: gVectorSources[index],
                    radius: 5,
                    id: 'heatmap'
                });
            } else {
                gVectorLayers[index] = new ol.layer.Vector({
                    source: gVectorSources[index],
                    style: window.gStyleFn,
                    id: 'base'
                });
            }

            if(layer.enabled) {
                map.addLayer(gVectorLayers[index]);
            }
            map.getView().fit(gVectorSources[index].getExtent(), map.getSize());
        }

        function deleteLayer(index) {

            if (gVectorLayers[index]) {
                gMap.removeLayer(gVectorLayers[index]);
                gVectorSources.splice(index, 1);
                gVectorLayers.splice(index, 1);
            }

        }

        function hideLayer(index) {
            map.removeLayer(gVectorLayers[index]);
        }

        function showLayer(index, map) {
            map.addLayer(gVectorLayers[index]);
        }

        /*
         * Save a layer after the user specifies it in the layer dialog
         */
        function saveLayer(map) {

            var title = $('#ml_title').val(),
                local = $('#usecurrent_tabledata').is(':checked'),
                layer = {};

            // Validation
            if (typeof title === "undefined" || title.trim().length === 0) {
                $('#layerInfo').show().removeClass('alert-success').addClass('alert-danger').html(localise.set["mf_tr"]);
                return false;
            }

            layer.title = title;
            layer.local = local;
            layer.clump = $('input[name=clump]:checked', '#mapForm').val();

            gLayers.push(layer);
            $('#layerEdit').modal("hide");	// All good close the modal

            refreshLayer(gLayers.length - 1, map);
            showLayerSelections(map);

        };

        /*
         * Process the map data according to the layer specification
         */
        function getGeoJson(results, layer) {

            var i, j, k, m;

            var geoJson = {
                type: "FeatureCollection",

                features: []
            };

            for (i = 0; i < results.length; i++) {

                var keep = false;   // default

                if (!results[i]._geolocation) {                      // Invalid Geometry
                    keep = false;
                } else {
                    // Do not show points at 0,0
                    if(results[i]._geolocation.type === "Point") {
                        for (j = 1; j < results[i]._geolocation.coordinates.length; j++) {
                            if (results[i]._geolocation.coordinates[j] != 0) {
                                keep = true;                            // At least one non zero geometry
                                break;
                            }
                        }
                    } else  if(results[i]._geolocation.type === "LineString") {
                        for (j = 0; j < results[i]._geolocation.coordinates.length; j++) {

                            for(k = 0; k < results[i]._geolocation.coordinates[j].length; k++) {
                                if (results[i]._geolocation.coordinates[j][k] != 0) {
                                    keep = true;                            // At least one non zero geometry
                                    break;
                                }
                            }
                        }
                    } else if(results[i]._geolocation.type === "Polygon") {
                        for (j = 0; j < results[i]._geolocation.coordinates.length; j++) {

                            for(k = 0; k < results[i]._geolocation.coordinates[j].length; k++) {
                                for(m = 0; m < results[i]._geolocation.coordinates[j][k].length; m++) {
                                    if (results[i]._geolocation.coordinates[j][k][m] != 0) {
                                        keep = true;                            // At least one non zero geometry
                                        break;
                                    }
                                }
                            }
                        }

                    }


                }

                if (keep) {
                    geoJson.features.push(
                        {
                            "type": "Feature",
                            //"geometry": {"type": "Point", "coordinates": results[i]._geolocation},
                            "geometry": results[i]._geolocation,
                            "properties": {
                                record: i,
                                main: true,
                                _assigned: results[i]._assigned
                            }
                        });
                }
            }

            return geoJson;
        }

        /*
         * Get the shared maps from the server
         */
        function getSharedMapsOL3(map) {

            var url = '/surveyKPI/shared/maps';
            $.ajax({
                url: url,
                dataType: 'json',
                cache: false,
                success: function(data) {
                    globals.gSelector.setSharedMaps(data);
                    addSharedMapsOL3(map, data);
                },
                error: function(xhr, textStatus, err) {
                    if(xhr.readyState == 0 || xhr.status == 0) {
                        return;  // Not an error
                    } else {
                        alert("Error: Failed to get list of shared maps: " + err);
                    }
                }
            });

        }

        /*
         * Add shared maps
         */
        function addSharedMapsOL3(map, sharedMaps) {

            var i,
                layerUrl,
                layer;

            if(sharedMaps) {


                var baseLayers = map.getLayers().item(0).getLayers().getArray();


                for(i = 0; i < sharedMaps.length; i++) {

                    layer = sharedMaps[i];

                    if(layer.type === "mapbox") {
                        //layerUrl = 'http://api.tiles.mapbox.com/v4/' + layer.config.mapid + ".jsonp?access_token=" + globals.gMapboxDefault;
                        layerUrl = "https://api.mapbox.com/styles/v1/" + layer.config.mapid + "/tiles/{z}/{x}/{y}?access_token=" + globals.gMapboxDefault;
                        baseLayers.unshift(new ol.layer.Tile( {
                            title: layer.name,
                            type: 'base',
                            visible: false,
                            source: new ol.source.OSM({
                                url: layerUrl,
                                crossOrigin: 'anonymous'
                            })
                        }));

                    } /* else if(layer.type === "vector") {
                        layerUrl = "/surveyKPI/file/" + layer.config.vectorData + "/organisation";
                        var vectorLayer = new OpenLayers.Layer.Vector(layer.name + ".", {
                            projection: "EPSG:4326",
                            strategies: [new OpenLayers.Strategy.Fixed()],
                            protocol: new OpenLayers.Protocol.HTTP({
                                url: layerUrl,
                                format: new OpenLayers.Format.GeoJSON()
                            })
                        });
                        map.addLayer(vectorLayer);

                    }
                    */
                }
            }
        }


        /*
         ********************************
         * Functions for dynamic maps
         */

        function initDynamicMap (config, setUserLocation, selectCallback, mainMap) {

            // Add the map
            if (!config.map) {

                config.map = new ol.Map({
                    target: config.id,
                    layers: [
                        new ol.layer.Group({
                            'title': 'Base maps',
                            layers: [
                                new ol.layer.Tile({
                                    title: 'HOT',
                                    type: 'base',
                                    visible: true,
                                    source: new ol.source.OSM({
                                        url: 'http://{a-c}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png'
                                    })
                                }),
                                new ol.layer.Tile({
                                    title: 'OSM',
                                    type: 'base',
                                    visible: true,
                                    source: new ol.source.OSM()
                                })
                            ]
                        })
                    ],
                    view: new ol.View(
                        {
                            center: ol.proj.transform([0.0, 0.0], 'EPSG:4326', 'EPSG:3857'),
                            zoom: 1,
                            maxZoom: 21
                        }
                    )

                });

                // Add additional maps specified in the shared resources page
                var sharedMaps = globals.gSelector.getSharedMaps();
                if(!sharedMaps) {
                    getMapboxDefault(getSharedMapsOL3, config.map);
                } else {
                    addSharedMapsOL3(config.map, sharedMaps)
                }

                // Add the vector layer
                var features = [];
                if(config.currentValue) {
                    var currentValue = {
                        "type": "Feature",
                        "geometry": config.currentValue,
                        "properties": {
                            "type": (config.readOnly ? "current" : "old"),      // If editable then set the curent value as the old
                            "label": localise.set["c_to"]
                        }
                    };

                    features.push(currentValue);
                }
                if(config.readOnly && config.oldValue) {       // Only care about old value if we are reviewing and not editing
                    var oldValue = {
                        "type": "Feature",
                        "geometry": config.oldValue,
                        "properties": {
                            "type": "old",
                            "label": localise.set["c_from"]
                        }
                    };

                    features.push(oldValue);
                }

                var collection = {
                    "type": "FeatureCollection",
                    features: features
                };
                window.gStyleFn = function(feature, resolution) {

                    var pointFill;
                    var areaFill;
                    var line;

                    if(feature.get('main')) {
                        if(feature.get('_assigned')=== globals.gLoggedInUser.ident) {
                            pointFill = 'rgba(0, 0, 255, 1.0)';
                        } else if(feature.get('_assigned') === '') {
                            pointFill = 'rgba(255, 165, 0, 1.0)';
                        } else {
                            pointFill = 'rgba(255, 255, 255, 1.0)';
                        }
                        line = 'rgba(255, 255, 255, 0.8)';
                    } else {
                        if (feature.get('type') === 'current') {
                            pointFill = 'rgba(255, 0, 0, 1.0)';
                            areaFill = 'rgba(255, 100, 50, 0.3)';
                            line = 'rgba(255, 10, 10, 0.8)';
                        } else if (feature.get('type') === 'old') {
                            pointFill = 'rgba(0, 0, 255, 1.0)';
                            areaFill = 'rgba(50, 100, 255, 0.3)';
                            line = 'rgba(10, 10, 255, 0.8)';
                        } else {
                            pointFill = 'rgba(0, 255, 255, 1.0)';
                            areaFill = 'rgba(10, 200, 255, 0.3)';
                            line = 'rgba(10, 200, 255, 0.8)';
                        }
                    }


                    return [new ol.style.Style({
                        fill: new ol.style.Fill({
                            color: areaFill
                        }),
                        stroke: new ol.style.Stroke({
                            width: 2,
                            color: line
                        }),
                        image: new ol.style.Circle({
                            fill: new ol.style.Fill({
                                color: pointFill
                            }),
                            stroke: new ol.style.Stroke({
                                width: 2,
                                color: 'rgba(100, 100, 100, 0.8)'
                            }),
                            radius: 7
                        })
                    })];
                };

                if(collection.features.length > 0) {

                    var source = new ol.source.Vector();
                    try {
                        source.addFeatures((new ol.format.GeoJSON()).readFeatures(collection,
                            {
                                dataProjection: 'EPSG:4326',
                                featureProjection: 'EPSG:3857'
                            }));

                        var layer = new ol.layer.Vector({
                            source: source,
                            style: gStyleFn
                        });
                        config.map.addLayer(layer);

                        config.map.getView().fit(source.getExtent(), config.map.getSize());

                    } catch(err) {

                    }

                }

                var layerSwitcher = new ol.control.LayerSwitcher({
                    tipLabel: 'Legend' // Optional label for button
                });
                config.map.addControl(layerSwitcher);


                if(setUserLocation) {
                    config.geolocation = new ol.Geolocation({
                        projection: config.map.getView().getProjection(),
                        tracking: true,
                        trackingOptions: {
                            enableHighAccuracy: true,
                            maximumAge: 2000
                        }
                    });

                    var iconStyle = new ol.style.Style({
                        image: new ol.style.Icon(({
                            anchor: [0.5, 25],
                            anchorXUnits: 'fraction',
                            anchorYUnits: 'pixels',
                            opacity: 1.0,
                            src: '/js/libs/OpenLayers/img/marker-gold.png'
                        }))
                    });

                    // add an empty iconFeature to the source of the layer
                    var iconFeature = new ol.Feature();
                    var iconSource = new ol.source.Vector({
                        features: [iconFeature]
                    });
                    var iconLayer = new ol.layer.Vector({
                        source: iconSource,
                        style : iconStyle
                    });
                    config.map.addLayer(iconLayer);

                    config.geolocation.on('change', function() {
                        var pos = config.geolocation.getPosition();
                        var view = config.map.getView();
                        iconFeature.setGeometry(new ol.geom.Point(pos));
                        view.setCenter(pos);
                        view.setZoom(18);
                    });

                }

                /*
                 * Add events
                 */
                if(mainMap) {

                    config.map.on('click', function(evt) {

                        $('#features').hide().empty();

                        if (selectCallback) {
                            var properties = [];
                            config.map.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
                                properties.push(feature.getProperties());
                            });
                            selectCallback(properties);
                        }
                        ;
                    });

                } else {
                    config.map.on('click', function(evt) {

                        var noFeature = true;
                        var id = config.id;
                        var $tooltip = $('#tooltip_' + id);

                        config.map.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {

                            var properties = feature.getProperties();
                            $tooltip.html(properties.label);
                            $tooltip.css(
                                {
                                    position: "absolute",
                                    left: evt.pixel[0],
                                    top: evt.pixel[1],
                                    "z-index": 20000,
                                    "background-color": "white",
                                    "padding": 2
                                }).show();
                            noFeature = false;

                            if (selectCallback) {
                                selectCallback(properties);
                            }

                        });

                        if (noFeature) {
                            $tooltip.hide();

                            if (!config.readOnly) {
                                var coord = ol.proj.transform(evt.coordinate, "EPSG:900913", 'EPSG:4326');
                                var newValue = {
                                    itemIndex: $('#' + id).data('item'),
                                    value: {
                                        coordinates: coord,
                                        type: "Point"
                                    }
                                };

                                if (config.task) {
                                    $('#taskPropertiesForm').trigger("smap_task::geopoint", newValue);
                                } else {
                                    if (newValue.itemIndex) {
                                        $('#editRecordForm').trigger("smap::geopoint", newValue);
                                    }
                                }

                                setSelectedFeature(config, evt.coordinate, undefined, undefined, false);

                            }
                        }
                    });

                }

                if(mainMap) {
                    gMap = config.map;
                    showLayerSelections(config.map);

                    $('#showlayers').click(function () {
                        globals.gMapLayersShown = !globals.gMapLayersShown;
                        if (globals.gMapLayersShown) {
                            $('#map_content').removeClass("col-md-12").addClass("col-md-8");
                            $('.map_layers').show();
                            gMap.updateSize();
                        } else {
                            $('#map_content').removeClass("col-md-8").addClass("col-md-12");
                            $('.map_layers').hide();
                            gMap.updateSize();
                        }
                    });
                }

            } else {
                console.log('Map ' + config.id + ' already initialised');
            }

            if (mainMap && gMapUpdatePending) {
                refreshAllLayers(true,  config.map);
            }


        }

        function clearSelectFeatures(config) {
            if(config.selectSource) {
                config.selectSource.clear();
                config.map.removeLayer(config.selectLayer);
                config.selectGeometry = undefined;
                config.selectSource = undefined;
                config.selectLayer = undefined;
            }

        }

        function setSelectedFeature(config, coordinate, lon, lat, recenter) {

            if(!coordinate) {
                var coord = [];
                coord.push(lon);
                coord.push(lat);
                // Convert lat lon to coordinates
                coordinate = ol.proj.transform(coord,'EPSG:4326', "EPSG:900913");

            }
            if(config.selectLayer !== undefined) {
                config.selectGeometry.setCoordinates(coordinate);
            } else {
                config.selectGeometry = new ol.geom.Point(coordinate);
                var selectFeature = new ol.Feature({
                    geometry: config.selectGeometry,
                    type: "current",
                    label: localise.set["c_to"]
                });
                config.selectSource = new ol.source.Vector({
                    features: [selectFeature]
                });
                config.selectLayer = new ol.layer.Vector({
                    source: config.selectSource,
                    style: gStyleFn
                });
                config.map.addLayer(config.selectLayer);
            }
            if(recenter) {
                config.map.getView().fit(config.selectSource.getExtent(), config.map.getSize());
            }
        }


    });



(function() {
  var out$ = typeof exports != 'undefined' && exports || typeof define != 'undefined' && {} || this;

  var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" [<!ENTITY nbsp "&#160;">]>';

  function isElement(obj) {
    return obj instanceof HTMLElement || obj instanceof SVGElement;
  }

  function requireDomNode(el) {
    if (!isElement(el)) {
      throw new Error('an HTMLElement or SVGElement is required; got ' + el);
    }
  }

  function isExternal(url) {
    return url && url.lastIndexOf('http',0) == 0 && url.lastIndexOf(window.location.host) == -1;
  }

  function inlineImages(el, callback) {
    requireDomNode(el);

    var images = el.querySelectorAll('image'),
        left = images.length,
        checkDone = function() {
          if (left === 0) {
            callback();
          }
        };

    checkDone();
    for (var i = 0; i < images.length; i++) {
      (function(image) {
        var href = image.getAttributeNS("http://www.w3.org/1999/xlink", "href");
        if (href) {
          if (isExternal(href.value)) {
            console.warn("Cannot render embedded images linking to external hosts: "+href.value);
            return;
          }
        }
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.crossOrigin="anonymous";
        href = href || image.getAttribute('href');
        if (href) {
          img.src = href;
          img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            image.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL('image/png'));
            left--;
            checkDone();
          }
          img.onerror = function() {
            console.log("Could not load "+href);
            left--;
            checkDone();
          }
        } else {
          left--;
          checkDone();
        }
      })(images[i]);
    }
  }

  function styles(el, selectorRemap, modifyStyle) {
    var css = "";
    var sheets = document.styleSheets;
    for (var i = 0; i < sheets.length; i++) {
      try {
        var rules = sheets[i].cssRules;
      } catch (e) {
        console.warn("Stylesheet could not be loaded: "+sheets[i].href);
        continue;
      }

      if (rules != null) {
        for (var j = 0, match; j < rules.length; j++, match = null) {
          var rule = rules[j];
          if (typeof(rule.style) != "undefined") {
            var selectorText;

            try {
              selectorText = rule.selectorText;
            } catch(err) {
              console.warn('The following CSS rule has an invalid selector: "' + rule + '"', err);
            }

            try {
              if (selectorText) {
                match = el.querySelector(selectorText);
              }
            } catch(err) {
              console.warn('Invalid CSS selector "' + selectorText + '"', err);
            }

            if (match) {
              var selector = selectorRemap ? selectorRemap(rule.selectorText) : rule.selectorText;
              var cssText = modifyStyle ? modifyStyle(rule.style.cssText) : rule.style.cssText;
              css += selector + " { " + cssText + " }\n";
            } else if(rule.cssText.match(/^@font-face/)) {
              css += rule.cssText + '\n';
            }
          }
        }
      }
    }
    return css;
  }

  function getDimension(el, clone, dim) {
    var v = (el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim]) ||
      (clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim))) ||
      el.getBoundingClientRect()[dim] ||
      parseInt(clone.style[dim]) ||
      parseInt(window.getComputedStyle(el).getPropertyValue(dim));
    return (typeof v === 'undefined' || v === null || isNaN(parseFloat(v))) ? 0 : v;
  }

  function reEncode(data) {
    data = encodeURIComponent(data);
    data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {
      var c = String.fromCharCode('0x'+p1);
      return c === '%' ? '%25' : c;
    });
    return decodeURIComponent(data);
  }

  out$.svgAsDataUri = function(el, options, cb) {
    requireDomNode(el);

    options = options || {};
    options.scale = options.scale || 1;
    options.responsive = options.responsive || false;
    var xmlns = "http://www.w3.org/2000/xmlns/";

    inlineImages(el, function() {
      var outer = document.createElement("div");
      var clone = el.cloneNode(true);
      var width, height;
      if(el.tagName == 'svg') {
        width = options.width || getDimension(el, clone, 'width');
        height = options.height || getDimension(el, clone, 'height');
      } else if(el.getBBox) {
        var box = el.getBBox();
        width = box.x + box.width;
        height = box.y + box.height;
        clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\(.*?\)/, ''));

        var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')
        svg.appendChild(clone)
        clone = svg;
      } else {
        console.error('Attempted to render non-SVG element', el);
        return;
      }

      clone.setAttribute("version", "1.1");
      if (!clone.getAttribute('xmlns')) {
        clone.setAttributeNS(xmlns, "xmlns", "http://www.w3.org/2000/svg");
      }
      if (!clone.getAttribute('xmlns:xlink')) {
        clone.setAttributeNS(xmlns, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      }

      if (options.responsive) {
        clone.removeAttribute('width');
        clone.removeAttribute('height');
        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      } else {
        clone.setAttribute("width", width * options.scale);
        clone.setAttribute("height", height * options.scale);
      }

      clone.setAttribute("viewBox", [
        options.left || 0,
        options.top || 0,
        width,
        height
      ].join(" "));

      var fos = clone.querySelectorAll('foreignObject > *');
      for (var i = 0; i < fos.length; i++) {
        if (!fos[i].getAttribute('xmlns')) {
          fos[i].setAttributeNS(xmlns, "xmlns", "http://www.w3.org/1999/xhtml");
        }
      }

      outer.appendChild(clone);

      var css = styles(el, options.selectorRemap, options.modifyStyle);
      var s = document.createElement('style');
      s.setAttribute('type', 'text/css');
      s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
      var defs = document.createElement('defs');
      defs.appendChild(s);
      clone.insertBefore(defs, clone.firstChild);

      var svg = doctype + outer.innerHTML;
      var uri = 'data:image/svg+xml;base64,' + window.btoa(reEncode(svg));
      if (cb) {
        cb(uri);
      }
    });
  }
  
  out$.svgAsDataUriSync = function(el, options) {
	    requireDomNode(el);

	    options = options || {};
	    options.scale = options.scale || 1;
	    options.responsive = options.responsive || false;
	    var xmlns = "http://www.w3.org/2000/xmlns/";


      var outer = document.createElement("div");
      var clone = el.cloneNode(true);
      var width, height;
      if(el.tagName == 'svg') {
        width = options.width || getDimension(el, clone, 'width');
        height = options.height || getDimension(el, clone, 'height');
      } else if(el.getBBox) {
        var box = el.getBBox();
        width = box.x + box.width;
        height = box.y + box.height;
        clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\(.*?\)/, ''));

        var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')
        svg.appendChild(clone)
        clone = svg;
      } else {
        console.error('Attempted to render non-SVG element', el);
        return;
      }

      clone.setAttribute("version", "1.1");
      if (!clone.getAttribute('xmlns')) {
        clone.setAttributeNS(xmlns, "xmlns", "http://www.w3.org/2000/svg");
      }
      if (!clone.getAttribute('xmlns:xlink')) {
        clone.setAttributeNS(xmlns, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      }

      if (options.responsive) {
        clone.removeAttribute('width');
        clone.removeAttribute('height');
        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      } else {
        clone.setAttribute("width", width * options.scale);
        clone.setAttribute("height", height * options.scale);
      }

      clone.setAttribute("viewBox", [
        options.left || 0,
        options.top || 0,
        width,
        height
      ].join(" "));

      var fos = clone.querySelectorAll('foreignObject > *');
      for (var i = 0; i < fos.length; i++) {
        if (!fos[i].getAttribute('xmlns')) {
          fos[i].setAttributeNS(xmlns, "xmlns", "http://www.w3.org/1999/xhtml");
        }
      }

      outer.appendChild(clone);

      var css = styles(el, options.selectorRemap, options.modifyStyle);
      var s = document.createElement('style');
      s.setAttribute('type', 'text/css');
      s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
      var defs = document.createElement('defs');
      defs.appendChild(s);
      clone.insertBefore(defs, clone.firstChild);

      var svg = doctype + outer.innerHTML;
      return 'data:image/svg+xml;base64,' + window.btoa(reEncode(svg));
	     
  }

  out$.svgAsImageUriSync = function(el, options) {
	    requireDomNode(el);

	    options = options || {};
	    options.encoderType = options.encoderType || 'image/png';
	    options.encoderOptions = options.encoderOptions || 0.8;

	    var uri = out$.svgAsDataUriSync(el, options);
	    var png;
	    var image = new Image();
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        if(options && options.backgroundColor){
          context.fillStyle = options.backgroundColor;
          context.fillRect(0, 0, canvas.width, canvas.height);
        }
        context.drawImage(image, 0, 0);
        var a = document.createElement('a'), png;
        try {
          png = canvas.toDataURL(options.encoderType, options.encoderOptions);
        } catch (e) {
          if ((typeof SecurityError !== 'undefined' && e instanceof SecurityError) || e.name == "SecurityError") {
            console.error("Rendered SVG images cannot be downloaded in this browser.");
            return;
          } else {
            throw e;
          }
        }

	  
      return png;
  }
  
  out$.svgAsPngUri = function(el, options, cb) {
    requireDomNode(el);

    options = options || {};
    options.encoderType = options.encoderType || 'image/png';
    options.encoderOptions = options.encoderOptions || 0.8;

    out$.svgAsDataUri(el, options, function(uri) {
      var image = new Image();
      image.onload = function() {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        if(options && options.backgroundColor){
          context.fillStyle = options.backgroundColor;
          context.fillRect(0, 0, canvas.width, canvas.height);
        }
        context.drawImage(image, 0, 0);
        var a = document.createElement('a'), png;
        try {
          png = canvas.toDataURL(options.encoderType, options.encoderOptions);
        } catch (e) {
          if ((typeof SecurityError !== 'undefined' && e instanceof SecurityError) || e.name == "SecurityError") {
            console.error("Rendered SVG images cannot be downloaded in this browser.");
            return;
          } else {
            throw e;
          }
        }
        cb(png);
      }
      image.onerror = function() {
        console.error(
          'There was an error loading the data URI as an image on the following SVG\n',
          window.atob(uri.slice(26)), '\n',
          "Open the following link to see browser's diagnosis\n",
          uri);
      }
      image.src = uri;
    });
  }

  function download(name, uri) {
    if (navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(uriToBlob(uri), name);
    } else {
      var saveLink = document.createElement('a');
      var downloadSupported = 'download' in saveLink;
      if (downloadSupported) {
        saveLink.download = name;
        saveLink.href = uri;
        saveLink.style.display = 'none';
        document.body.appendChild(saveLink);
        saveLink.click();
        document.body.removeChild(saveLink);
      }
      else {
        window.open(uri, '_temp', 'menubar=no,toolbar=no,status=no');
      }
    }
  }
  out$.download = download;

  function uriToBlob(uri) {
    var byteString = window.atob(uri.split(',')[1]);
    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0]
    var buffer = new ArrayBuffer(byteString.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < byteString.length; i++) {
      intArray[i] = byteString.charCodeAt(i);
    }
    return new Blob([buffer], {type: mimeString});
  }

  out$.saveSvg = function(el, name, options) {
    requireDomNode(el);

    options = options || {};
    out$.svgAsDataUri(el, options, function(uri) {
      download(name, uri);
    });
  }

  out$.saveSvgAsPng = function(el, name, options) {
    requireDomNode(el);

    options = options || {};
    out$.svgAsPngUri(el, options, function(uri) {
      download(name, uri);
    });
  }

  // if define is defined create as an AMD module
  if (typeof define !== 'undefined') {
    define('svgsave',[],function() {
      return out$;
    });
  }
})();

/*!
 * Knockout JavaScript library v3.4.2
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var x=this||(0,eval)("this"),t=x.document,M=x.navigator,u=x.jQuery,H=x.JSON;(function(n){"function"===typeof define&&define.amd?define('knockout',["exports","require"],n):"object"===typeof exports&&"object"===typeof module?n(module.exports||exports):n(x.ko={})})(function(N,O){function J(a,c){return null===a||typeof a in R?a===c:!1}function S(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function T(b,c){var d;return function(){clearTimeout(d);d=a.a.setTimeout(b,c)}}function U(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            c){c&&c!==E?"beforeChange"===c?this.Ob(a):this.Ja(a,c):this.Pb(a)}function V(a,c){null!==c&&c.k&&c.k()}function W(a,c){var d=this.Mc,e=d[s];e.T||(this.ob&&this.Oa[c]?(d.Sb(c,a,this.Oa[c]),this.Oa[c]=null,--this.ob):e.s[c]||d.Sb(c,a,e.t?{$:a}:d.yc(a)),a.Ha&&a.Hc())}function K(b,c,d,e){a.d[b]={init:function(b,g,h,l,m){var k,r;a.m(function(){var q=g(),p=a.a.c(q),p=!d!==!p,A=!r;if(A||c||p!==k)A&&a.xa.Ca()&&(r=a.a.wa(a.f.childNodes(b),!0)),p?(A||a.f.fa(b,a.a.wa(r)),a.hb(e?e(m,q):m,b)):a.f.za(b),k=p},null,
    {i:b});return{controlsDescendantBindings:!0}}};a.h.va[b]=!1;a.f.aa[b]=!0}var a="undefined"!==typeof N?N:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.H=function(a,c,d){a[c]=d};a.version="3.4.2";a.b("version",a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1};a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=
    b;return a}function e(b,c,d,e){var m=b[c].match(r)||[];a.a.r(d.match(r),function(b){a.a.ra(m,b,e)});b[c]=m.join(" ")}var f={__proto__:[]}instanceof Array,g="function"===typeof Symbol,h={},l={};h[M&&/Firefox\/2/i.test(M.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];h.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(h,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)l[b[c]]=a});var m={propertychange:!0},k=
    t&&function(){for(var a=3,b=t.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),r=/\S+/g;return{gc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],r:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},o:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Vb:function(a,b,c){for(var d=
    0,e=a.length;d<e;d++)if(b.call(c,a[d],d))return a[d];return null},Na:function(b,c){var d=a.a.o(b,c);0<d?b.splice(d,1):0===d&&b.shift()},Wb:function(b){b=b||[];for(var c=[],d=0,e=b.length;d<e;d++)0>a.a.o(c,b[d])&&c.push(b[d]);return c},ib:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)c.push(b(a[d],d));return c},Ma:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)b(a[d],d)&&c.push(a[d]);return c},ta:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<
d;c++)a.push(b[c]);return a},ra:function(b,c,d){var e=a.a.o(a.a.Bb(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},la:f,extend:c,$a:d,ab:f?d:c,D:b,Ea:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},rb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},nc:function(b){b=a.a.W(b);for(var c=(b[0]&&b[0].ownerDocument||t).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.ba(b[d]));return c},wa:function(b,c){for(var d=0,e=b.length,m=[];d<e;d++){var k=
    b[d].cloneNode(!0);m.push(c?a.ba(k):k)}return m},fa:function(b,c){a.a.rb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},uc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],m=e.parentNode,k=0,f=c.length;k<f;k++)m.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ba:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=
    a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},wc:function(a,b){7>k?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===n?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},sd:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},Rc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==
    (b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},qb:function(b){return a.a.Rc(b,b.ownerDocument.documentElement)},Tb:function(b){return!!a.a.Vb(b,a.a.qb)},A:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},Zb:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Zb(b),c)},dc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},q:function(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                c,d){var e=a.a.Zb(d);d=k&&m[c];if(a.options.useOnlyNativeEvents||d||!u)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var f=function(a){e.call(b,a)},l="on"+c;b.attachEvent(l,f);a.a.G.qa(b,function(){b.detachEvent(l,f)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else u(b).bind(c,e)},Fa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===
a.a.A(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!u||d)if("function"==typeof t.createEvent)if("function"==typeof b.dispatchEvent)d=t.createEvent(l[c]||"HTMLEvents"),d.initEvent(c,!0,!0,x,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");
else u(b).trigger(c)},c:function(b){return a.I(b)?b():b},Bb:function(b){return a.I(b)?b.p():b},fb:function(b,c,d){var k;c&&("object"===typeof b.classList?(k=b.classList[d?"add":"remove"],a.a.r(c.match(r),function(a){k.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},bb:function(b,c){var d=a.a.c(c);if(null===d||d===n)d="";var e=a.f.firstChild(b);!e||3!=e.nodeType||a.f.nextSibling(e)?a.f.fa(b,[b.ownerDocument.createTextNode(d)]):e.data=
    d;a.a.Wc(b)},vc:function(a,b){a.name=b;if(7>=k)try{a.mergeAttributes(t.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},Wc:function(a){9<=k&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},Sc:function(a){if(k){var b=a.style.width;a.style.width=0;a.style.width=b}},nd:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},W:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},bc:function(a){return g?Symbol(a):a},xd:6===k,
    yd:7===k,C:k,ic:function(b,c){for(var d=a.a.W(b.getElementsByTagName("input")).concat(a.a.W(b.getElementsByTagName("textarea"))),e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},k=[],m=d.length-1;0<=m;m--)e(d[m])&&k.push(d[m]);return k},kd:function(b){return"string"==typeof b&&(b=a.a.cb(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},Gb:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
        return H.stringify(a.a.c(b),c,d)},ld:function(c,d,e){e=e||{};var k=e.params||{},m=e.includeFields||this.gc,f=c;if("object"==typeof c&&"form"===a.a.A(c))for(var f=c.action,l=m.length-1;0<=l;l--)for(var g=a.a.ic(c,m[l]),h=g.length-1;0<=h;h--)k[g[h].name]=g[h].value;d=a.a.c(d);var r=t.createElement("form");r.style.display="none";r.action=f;r.method="post";for(var n in d)c=t.createElement("input"),c.type="hidden",c.name=n,c.value=a.a.Gb(a.a.c(d[n])),r.appendChild(c);b(k,function(a,b){var c=t.createElement("input");
        c.type="hidden";c.name=a;c.value=b;r.appendChild(c)});t.body.appendChild(r);e.submitter?e.submitter(r):r.submit();setTimeout(function(){r.parentNode.removeChild(r)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.r);a.b("utils.arrayFirst",a.a.Vb);a.b("utils.arrayFilter",a.a.Ma);a.b("utils.arrayGetDistinctValues",a.a.Wb);a.b("utils.arrayIndexOf",a.a.o);a.b("utils.arrayMap",a.a.ib);a.b("utils.arrayPushAll",a.a.ta);a.b("utils.arrayRemoveItem",a.a.Na);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
    a.a.gc);a.b("utils.getFormFields",a.a.ic);a.b("utils.peekObservable",a.a.Bb);a.b("utils.postJson",a.a.ld);a.b("utils.parseJson",a.a.kd);a.b("utils.registerEventHandler",a.a.q);a.b("utils.stringifyJson",a.a.Gb);a.b("utils.range",a.a.nd);a.b("utils.toggleDomNodeCssClass",a.a.fb);a.b("utils.triggerEvent",a.a.Fa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.D);a.b("utils.addOrRemoveItem",a.a.ra);a.b("utils.setTextContent",a.a.bb);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=
    function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.e=new function(){function a(b,g){var h=b[d];if(!h||"null"===h||!e[h]){if(!g)return n;h=b[d]="ko"+c++;e[h]={}}return e[h]}var c=0,d="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===n?n:e[d]},set:function(c,d,e){if(e!==n||a(c,!1)!==n)a(c,!0)[d]=
    e},clear:function(a){var b=a[d];return b?(delete e[b],a[d]=null,!0):!1},J:function(){return c++ +d}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.G=new function(){function b(b,c){var e=a.a.e.get(b,d);e===n&&c&&(e=[],a.a.e.set(b,d,e));return e}function c(d){var e=b(d,!1);if(e)for(var e=e.slice(0),l=0;l<e.length;l++)e[l](d);a.a.e.clear(d);a.a.G.cleanExternalData(d);if(f[d.nodeType])for(e=d.firstChild;d=e;)e=d.nextSibling,8===d.nodeType&&c(d)}var d=a.a.e.J(),e={1:!0,8:!0,9:!0},
    f={1:!0,9:!0};return{qa:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},tc:function(c,e){var f=b(c,!1);f&&(a.a.Na(f,e),0==f.length&&a.a.e.set(c,d,n))},ba:function(b){if(e[b.nodeType]&&(c(b),f[b.nodeType])){var d=[];a.a.ta(d,b.getElementsByTagName("*"));for(var l=0,m=d.length;l<m;l++)c(d[l])}return b},removeNode:function(b){a.ba(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){u&&"function"==typeof u.cleanData&&u.cleanData([a])}}};
    a.ba=a.a.G.ba;a.removeNode=a.a.G.removeNode;a.b("cleanNode",a.ba);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.G);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.G.qa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.G.tc);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},
        g=8>=a.a.C;a.a.na=function(c,d){var e;if(u)if(u.parseHTML)e=u.parseHTML(c,d)||[];else{if((e=u.clean([c],d))&&e[0]){for(var k=e[0];k.parentNode&&11!==k.parentNode.nodeType;)k=k.parentNode;k.parentNode&&k.parentNode.removeChild(k)}}else{(e=d)||(e=t);var k=e.parentWindow||e.defaultView||x,r=a.a.cb(c).toLowerCase(),q=e.createElement("div"),p;p=(r=r.match(/^<([a-z]+)[ >]/))&&f[r[1]]||b;r=p[0];p="ignored<div>"+p[1]+c+p[2]+"</div>";"function"==typeof k.innerShiv?q.appendChild(k.innerShiv(p)):(g&&e.appendChild(q),
        q.innerHTML=p,g&&q.parentNode.removeChild(q));for(;r--;)q=q.lastChild;e=a.a.W(q.lastChild.childNodes)}return e};a.a.Eb=function(b,c){a.a.rb(b);c=a.a.c(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),u)u(b).html(c);else for(var d=a.a.na(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.na);a.b("utils.setHtml",a.a.Eb);a.N=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.N.pc(c.nodeValue);null!=f&&e.push({Qc:c,hd:f})}else if(1==c.nodeType)for(var f=
        0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],e)}var c={};return{yb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},Bc:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),
        !0}finally{delete c[a]}},Cc:function(c,e){var f=[];b(c,f);for(var g=0,h=f.length;g<h;g++){var l=f[g].Qc,m=[l];e&&a.a.ta(m,e);a.N.Bc(f[g].hd,m);l.nodeValue="";l.parentNode&&l.parentNode.removeChild(l)}},pc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.N);a.b("memoization.memoize",a.N.yb);a.b("memoization.unmemoize",a.N.Bc);a.b("memoization.parseMemoText",a.N.pc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.N.Cc);a.Z=function(){function b(){if(e)for(var b=
        e,c=0,m;g<e;)if(m=d[g++]){if(g>b){if(5E3<=++c){g=e;a.a.dc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=e}try{m()}catch(k){a.a.dc(k)}}}function c(){b();g=e=d.length=0}var d=[],e=0,f=1,g=0;return{scheduler:x.MutationObserver?function(a){var b=t.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):t&&"onreadystatechange"in t.createElement("script")?function(a){var b=t.createElement("script");b.onreadystatechange=
        function(){b.onreadystatechange=null;t.documentElement.removeChild(b);b=null;a()};t.documentElement.appendChild(b)}:function(a){setTimeout(a,0)},Za:function(b){e||a.Z.scheduler(c);d[e++]=b;return f++},cancel:function(a){a-=f-e;a>=g&&a<e&&(d[a]=null)},resetForTesting:function(){var a=e-g;g=e=d.length=0;return a},rd:b}}();a.b("tasks",a.Z);a.b("tasks.schedule",a.Z.Za);a.b("tasks.runEarly",a.Z.rd);a.Aa={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.B({read:b,write:function(e){clearTimeout(d);
        d=a.a.setTimeout(function(){b(e)},c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.gb=!1;f="notifyWhenChangesStop"==e?T:S;a.Wa(function(a){return f(a,d)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.gb||(b.gb=!0,b.Wa(function(c){var e,f=!1;return function(){if(!f){a.Z.cancel(e);e=a.Z.Za(c);try{f=!0,b.notifySubscribers(n,"dirty")}finally{f=
        !1}}}}))},notify:function(a,c){a.equalityComparer="always"==c?null:J}};var R={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Aa);a.zc=function(b,c,d){this.$=b;this.jb=c;this.Pc=d;this.T=!1;a.H(this,"dispose",this.k)};a.zc.prototype.k=function(){this.T=!0;this.Pc()};a.K=function(){a.a.ab(this,D);D.ub(this)};var E="change",D={ub:function(a){a.F={change:[]};a.Qb=1},Y:function(b,c,d){var e=this;d=d||E;var f=new a.zc(e,c?b.bind(c):b,function(){a.a.Na(e.F[d],f);e.Ka&&e.Ka(d)});e.ua&&e.ua(d);
        e.F[d]||(e.F[d]=[]);e.F[d].push(f);return f},notifySubscribers:function(b,c){c=c||E;c===E&&this.Kb();if(this.Ra(c)){var d=c===E&&this.Fc||this.F[c].slice(0);try{a.l.Xb();for(var e=0,f;f=d[e];++e)f.T||f.jb(b)}finally{a.l.end()}}},Pa:function(){return this.Qb},Zc:function(a){return this.Pa()!==a},Kb:function(){++this.Qb},Wa:function(b){var c=this,d=a.I(c),e,f,g,h;c.Ja||(c.Ja=c.notifySubscribers,c.notifySubscribers=U);var l=b(function(){c.Ha=!1;d&&h===c&&(h=c.Mb?c.Mb():c());var a=f||c.Ua(g,h);f=e=!1;
        a&&c.Ja(g=h)});c.Pb=function(a){c.Fc=c.F[E].slice(0);c.Ha=e=!0;h=a;l()};c.Ob=function(a){e||(g=a,c.Ja(a,"beforeChange"))};c.Hc=function(){c.Ua(g,c.p(!0))&&(f=!0)}},Ra:function(a){return this.F[a]&&this.F[a].length},Xc:function(b){if(b)return this.F[b]&&this.F[b].length||0;var c=0;a.a.D(this.F,function(a,b){"dirty"!==a&&(c+=b.length)});return c},Ua:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},extend:function(b){var c=this;b&&a.a.D(b,function(b,e){var f=a.Aa[b];"function"==
    typeof f&&(c=f(c,e)||c)});return c}};a.H(D,"subscribe",D.Y);a.H(D,"extend",D.extend);a.H(D,"getSubscriptionsCount",D.Xc);a.a.la&&a.a.$a(D,Function.prototype);a.K.fn=D;a.lc=function(a){return null!=a&&"function"==typeof a.Y&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.K);a.b("isSubscribable",a.lc);a.xa=a.l=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{Xb:b,end:c,sc:function(b){if(e){if(!a.lc(b))throw Error("Only subscribable things can act as dependencies");
        e.jb.call(e.Lc,b,b.Gc||(b.Gc=++f))}},w:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},Ca:function(){if(e)return e.m.Ca()},Va:function(){if(e)return e.Va}}}();a.b("computedContext",a.xa);a.b("computedContext.getDependenciesCount",a.xa.Ca);a.b("computedContext.isInitial",a.xa.Va);a.b("ignoreDependencies",a.wd=a.l.w);var F=a.a.bc("_latestValue");a.O=function(b){function c(){if(0<arguments.length)return c.Ua(c[F],arguments[0])&&(c.ia(),c[F]=arguments[0],c.ha()),this;a.l.sc(c);return c[F]}
        c[F]=b;a.a.la||a.a.extend(c,a.K.fn);a.K.fn.ub(c);a.a.ab(c,B);a.options.deferUpdates&&a.Aa.deferred(c,!0);return c};var B={equalityComparer:J,p:function(){return this[F]},ha:function(){this.notifySubscribers(this[F])},ia:function(){this.notifySubscribers(this[F],"beforeChange")}};a.a.la&&a.a.$a(B,a.K.fn);var I=a.O.md="__ko_proto__";B[I]=a.O;a.Qa=function(b,c){return null===b||b===n||b[I]===n?!1:b[I]===c?!0:a.Qa(b[I],c)};a.I=function(b){return a.Qa(b,a.O)};a.Da=function(b){return"function"==typeof b&&
    b[I]===a.O||"function"==typeof b&&b[I]===a.B&&b.$c?!0:!1};a.b("observable",a.O);a.b("isObservable",a.I);a.b("isWriteableObservable",a.Da);a.b("isWritableObservable",a.Da);a.b("observable.fn",B);a.H(B,"peek",B.p);a.H(B,"valueHasMutated",B.ha);a.H(B,"valueWillMutate",B.ia);a.ma=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.O(b);a.a.ab(b,a.ma.fn);return b.extend({trackArrayChanges:!0})};
    a.ma.fn={remove:function(b){for(var c=this.p(),d=[],e="function"!=typeof b||a.I(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];e(g)&&(0===d.length&&this.ia(),d.push(g),c.splice(f,1),f--)}d.length&&this.ha();return d},removeAll:function(b){if(b===n){var c=this.p(),d=c.slice(0);this.ia();c.splice(0,c.length);this.ha();return d}return b?this.remove(function(c){return 0<=a.a.o(b,c)}):[]},destroy:function(b){var c=this.p(),d="function"!=typeof b||a.I(b)?function(a){return a===b}:b;this.ia();
        for(var e=c.length-1;0<=e;e--)d(c[e])&&(c[e]._destroy=!0);this.ha()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.o(b,c)}):[]},indexOf:function(b){var c=this();return a.a.o(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ia(),this.p()[d]=c,this.ha())}};a.a.la&&a.a.$a(a.ma.fn,a.O.fn);a.a.r("pop push reverse shift sort splice unshift".split(" "),function(b){a.ma.fn[b]=function(){var a=this.p();this.ia();this.Yb(a,b,arguments);
        var d=a[b].apply(a,arguments);this.ha();return d===a?this:d}});a.a.r(["slice"],function(b){a.ma.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.ma);a.Aa.trackArrayChanges=function(b,c){function d(){if(!e){e=!0;l=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==E||++h;return l.apply(this,arguments)};var c=[].concat(b.p()||[]);f=null;g=b.Y(function(d){d=[].concat(d||[]);if(b.Ra("arrayChange")){var e;if(!f||1<h)f=a.a.lb(c,d,b.kb);e=f}c=d;f=null;h=0;
        e&&e.length&&b.notifySubscribers(e,"arrayChange")})}}b.kb={};c&&"object"==typeof c&&a.a.extend(b.kb,c);b.kb.sparse=!0;if(!b.Yb){var e=!1,f=null,g,h=0,l,m=b.ua,k=b.Ka;b.ua=function(a){m&&m.call(b,a);"arrayChange"===a&&d()};b.Ka=function(a){k&&k.call(b,a);"arrayChange"!==a||b.Ra("arrayChange")||(l&&(b.notifySubscribers=l,l=n),g.k(),e=!1)};b.Yb=function(b,c,d){function k(a,b,c){return m[m.length]={status:a,value:b,index:c}}if(e&&!h){var m=[],l=b.length,g=d.length,G=0;switch(c){case "push":G=l;case "unshift":for(c=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              0;c<g;c++)k("added",d[c],G+c);break;case "pop":G=l-1;case "shift":l&&k("deleted",b[G],G);break;case "splice":c=Math.min(Math.max(0,0>d[0]?l+d[0]:d[0]),l);for(var l=1===g?l:Math.min(c+(d[1]||0),l),g=c+g-2,G=Math.max(l,g),n=[],s=[],w=2;c<G;++c,++w)c<l&&s.push(k("deleted",b[c],c)),c<g&&n.push(k("added",d[w],c));a.a.hc(s,n);break;default:return}f=m}}}};var s=a.a.bc("_state");a.m=a.B=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.sb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
        return this}a.l.sc(e);(g.V||g.t&&e.Sa())&&e.U();return g.M}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={M:n,da:!0,V:!0,Ta:!1,Hb:!1,T:!1,Ya:!1,t:!1,od:d.read,sb:c||d.owner,i:d.disposeWhenNodeIsRemoved||d.i||null,ya:d.disposeWhen||d.ya,pb:null,s:{},L:0,fc:null};e[s]=g;e.$c="function"===typeof f;a.a.la||a.a.extend(e,a.K.fn);a.K.fn.ub(e);a.a.ab(e,z);d.pure?(g.Ya=!0,g.t=!0,a.a.extend(e,
        Y)):d.deferEvaluation&&a.a.extend(e,Z);a.options.deferUpdates&&a.Aa.deferred(e,!0);g.i&&(g.Hb=!0,g.i.nodeType||(g.i=null));g.t||d.deferEvaluation||e.U();g.i&&e.ca()&&a.a.G.qa(g.i,g.pb=function(){e.k()});return e};var z={equalityComparer:J,Ca:function(){return this[s].L},Sb:function(a,c,d){if(this[s].Ya&&c===this)throw Error("A 'pure' computed must not be called recursively");this[s].s[a]=d;d.Ia=this[s].L++;d.pa=c.Pa()},Sa:function(){var a,c,d=this[s].s;for(a in d)if(d.hasOwnProperty(a)&&(c=d[a],this.oa&&
        c.$.Ha||c.$.Zc(c.pa)))return!0},gd:function(){this.oa&&!this[s].Ta&&this.oa(!1)},ca:function(){var a=this[s];return a.V||0<a.L},qd:function(){this.Ha?this[s].V&&(this[s].da=!0):this.ec()},yc:function(a){if(a.gb&&!this[s].i){var c=a.Y(this.gd,this,"dirty"),d=a.Y(this.qd,this);return{$:a,k:function(){c.k();d.k()}}}return a.Y(this.ec,this)},ec:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[s].fc),this[s].fc=a.a.setTimeout(function(){b.U(!0)},c)):b.oa?b.oa(!0):b.U(!0)},U:function(b){var c=
        this[s],d=c.ya,e=!1;if(!c.Ta&&!c.T){if(c.i&&!a.a.qb(c.i)||d&&d()){if(!c.Hb){this.k();return}}else c.Hb=!1;c.Ta=!0;try{e=this.Vc(b)}finally{c.Ta=!1}c.L||this.k();return e}},Vc:function(b){var c=this[s],d=!1,e=c.Ya?n:!c.L,f={Mc:this,Oa:c.s,ob:c.L};a.l.Xb({Lc:f,jb:W,m:this,Va:e});c.s={};c.L=0;f=this.Uc(c,f);this.Ua(c.M,f)&&(c.t||this.notifySubscribers(c.M,"beforeChange"),c.M=f,c.t?this.Kb():b&&this.notifySubscribers(c.M),d=!0);e&&this.notifySubscribers(c.M,"awake");return d},Uc:function(b,c){try{var d=
        b.od;return b.sb?d.call(b.sb):d()}finally{a.l.end(),c.ob&&!b.t&&a.a.D(c.Oa,V),b.da=b.V=!1}},p:function(a){var c=this[s];(c.V&&(a||!c.L)||c.t&&this.Sa())&&this.U();return c.M},Wa:function(b){a.K.fn.Wa.call(this,b);this.Mb=function(){this[s].da?this.U():this[s].V=!1;return this[s].M};this.oa=function(a){this.Ob(this[s].M);this[s].V=!0;a&&(this[s].da=!0);this.Pb(this)}},k:function(){var b=this[s];!b.t&&b.s&&a.a.D(b.s,function(a,b){b.k&&b.k()});b.i&&b.pb&&a.a.G.tc(b.i,b.pb);b.s=null;b.L=0;b.T=!0;b.da=
        !1;b.V=!1;b.t=!1;b.i=null}},Y={ua:function(b){var c=this,d=c[s];if(!d.T&&d.t&&"change"==b){d.t=!1;if(d.da||c.Sa())d.s=null,d.L=0,c.U()&&c.Kb();else{var e=[];a.a.D(d.s,function(a,b){e[b.Ia]=a});a.a.r(e,function(a,b){var e=d.s[a],l=c.yc(e.$);l.Ia=b;l.pa=e.pa;d.s[a]=l})}d.T||c.notifySubscribers(d.M,"awake")}},Ka:function(b){var c=this[s];c.T||"change"!=b||this.Ra("change")||(a.a.D(c.s,function(a,b){b.k&&(c.s[a]={$:b.$,Ia:b.Ia,pa:b.pa},b.k())}),c.t=!0,this.notifySubscribers(n,"asleep"))},Pa:function(){var b=
        this[s];b.t&&(b.da||this.Sa())&&this.U();return a.K.fn.Pa.call(this)}},Z={ua:function(a){"change"!=a&&"beforeChange"!=a||this.p()}};a.a.la&&a.a.$a(z,a.K.fn);var P=a.O.md;a.m[P]=a.O;z[P]=a.m;a.bd=function(b){return a.Qa(b,a.m)};a.cd=function(b){return a.Qa(b,a.m)&&b[s]&&b[s].Ya};a.b("computed",a.m);a.b("dependentObservable",a.m);a.b("isComputed",a.bd);a.b("isPureComputed",a.cd);a.b("computed.fn",z);a.H(z,"peek",z.p);a.H(z,"dispose",z.k);a.H(z,"isActive",z.ca);a.H(z,"getDependenciesCount",z.Ca);a.rc=
        function(b,c){if("function"===typeof b)return a.m(b,c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.m(b,c)};a.b("pureComputed",a.rc);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var k=
        g.get(d);h[c]=k!==n?k:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.Lb=[]}a.Ac=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.I(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Ac(b);return a.a.Gb(b,c,d)};d.prototype={save:function(b,c){var d=a.a.o(this.keys,
        b);0<=d?this.Lb[d]=c:(this.keys.push(b),this.Lb.push(c))},get:function(b){b=a.a.o(this.keys,b);return 0<=b?this.Lb[b]:n}}})();a.b("toJS",a.Ac);a.b("toJSON",a.toJSON);(function(){a.j={u:function(b){switch(a.a.A(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.zb):7>=a.a.C?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex]):n;default:return b.value}},ja:function(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       c,d){switch(a.a.A(b)){case "option":switch(typeof c){case "string":a.a.e.set(b,a.d.options.zb,n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.e.set(b,a.d.options.zb,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof c?c:""}break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.j.u(b.options[f]),h==c||""==h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e;break;default:if(null===
        c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.j);a.b("selectExtensions.readValue",a.j.u);a.b("selectExtensions.writeValue",a.j.ja);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),r,h=[],p=0;if(d){d.push(",");for(var A=0,y;y=d[A];++A){var v=y.charCodeAt(0);if(44===v){if(0>=p){c.push(r&&h.length?{key:r,value:h.join("")}:{unknown:r||h.join("")});r=p=0;h=[];continue}}else if(58===v){if(!p&&!r&&1===h.length){r=h.pop();continue}}else 47===
    v&&A&&1<y.length?(v=d[A-1].match(f))&&!g[v[0]]&&(b=b.substr(b.indexOf(y)+1),d=b.match(e),d.push(","),A=-1,y="/"):40===v||123===v||91===v?++p:41===v||125===v||93===v?--p:r||h.length||34!==v&&39!==v||(y=y.slice(1,-1));h.push(y)}}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,
        g={"in":1,"return":1,"typeof":1},h={};return{va:[],ga:h,Ab:b,Xa:function(e,m){function k(b,e){var m;if(!A){var l=a.getBindingHandler(b);if(l&&l.preprocess&&!(e=l.preprocess(e,b,k)))return;if(l=h[b])m=e,0<=a.a.o(c,m)?m=!1:(l=m.match(d),m=null===l?!1:l[1]?"Object("+l[1]+")"+l[2]:m),l=m;l&&g.push("'"+b+"':function(_z){"+m+"=_z}")}p&&(e="function(){return "+e+" }");f.push("'"+b+"':"+e)}m=m||{};var f=[],g=[],p=m.valueAccessors,A=m.bindingParams,y="string"===typeof e?b(e):e;a.a.r(y,function(a){k(a.key||
        a.unknown,a.value)});g.length&&k("_ko_property_writers","{"+g.join(",")+" }");return f.join(",")},fd:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},Ga:function(b,c,d,e,f){if(b&&a.I(b))!a.Da(b)||f&&b.p()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.va);a.b("expressionRewriting.parseObjectLiteral",a.h.Ab);a.b("expressionRewriting.preProcessBindings",a.h.Xa);a.b("expressionRewriting._twoWayBindings",
        a.h.ga);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.Xa);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(a,d){for(var e=a,f=1,l=[];e=e.nextSibling;){if(c(e)&&(f--,0===f))return l;l.push(e);b(e)&&f++}if(!d)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var c=d(a,b);return c?0<c.length?c[c.length-
    1].nextSibling:a.nextSibling:null}var f=t&&"\x3c!--test--\x3e"===t.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,l={ul:!0,ol:!0};a.f={aa:{},childNodes:function(a){return b(a)?d(a):a.childNodes},za:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.rb(c)},fa:function(c,d){if(b(c)){a.f.za(c);for(var e=c.nextSibling,f=0,l=d.length;f<l;f++)e.parentNode.insertBefore(d[f],
        e)}else a.a.fa(c,d)},qc:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},kc:function(c,d,e){e?b(c)?c.parentNode.insertBefore(d,e.nextSibling):e.nextSibling?c.insertBefore(d,e.nextSibling):c.appendChild(d):a.f.qc(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||c(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&c(a.nextSibling)?null:a.nextSibling},Yc:b,vd:function(a){return(a=
        (f?a.text:a.nodeValue).match(g))?a[1]:null},oc:function(d){if(l[a.a.A(d)]){var k=d.firstChild;if(k){do if(1===k.nodeType){var f;f=k.firstChild;var g=null;if(f){do if(g)g.push(f);else if(b(f)){var h=e(f,!0);h?f=h:g=[f]}else c(f)&&(g=[f]);while(f=f.nextSibling)}if(f=g)for(g=k.nextSibling,h=0;h<f.length;h++)g?d.insertBefore(f[h],g):d.appendChild(f[h])}while(k=k.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.aa);a.b("virtualElements.emptyNode",a.f.za);a.b("virtualElements.insertAfter",
        a.f.kc);a.b("virtualElements.prepend",a.f.qc);a.b("virtualElements.setDomNodeChildren",a.f.fa);(function(){a.S=function(){this.Kc={}};a.a.extend(a.S.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.Yc(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.g.Rb(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,
        c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.g.Rb(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.f.vd(b);default:return null}},parseBindingsString:function(b,c,d,e){try{var f=this.Kc,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var l,m="with($context){with($data||{}){return{"+a.h.Xa(b,e)+"}}}";l=new Function("$context","$element",m);h=f[g]=l}return h(c,d)}catch(k){throw k.message="Unable to parse bindings.\nBindings value: "+
        b+"\nMessage: "+k.message,k;}}});a.S.instance=new a.S})();a.b("bindingProvider",a.S);(function(){function b(a){return function(){return a}}function c(a){return a()}function d(b){return a.a.Ea(a.l.w(b),function(a,c){return function(){return b()[c]}})}function e(c,e,k){return"function"===typeof c?d(c.bind(null,e,k)):a.a.Ea(c,b)}function f(a,b){return d(this.getBindings.bind(this,a,b))}function g(b,c,d){var e,k=a.f.firstChild(c),f=a.S.instance,m=f.preprocessNode;if(m){for(;e=k;)k=a.f.nextSibling(e),
        m.call(f,e);k=a.f.firstChild(c)}for(;e=k;)k=a.f.nextSibling(e),h(b,e,d)}function h(b,c,d){var e=!0,k=1===c.nodeType;k&&a.f.oc(c);if(k&&d||a.S.instance.nodeHasBindings(c))e=m(c,null,b,d).shouldBindDescendants;e&&!r[a.a.A(c)]&&g(b,c,!k)}function l(b){var c=[],d={},e=[];a.a.D(b,function X(k){if(!d[k]){var f=a.getBindingHandler(k);f&&(f.after&&(e.push(k),a.a.r(f.after,function(c){if(b[c]){if(-1!==a.a.o(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
        X(c)}}),e.length--),c.push({key:k,jc:f}));d[k]=!0}});return c}function m(b,d,e,k){var m=a.a.e.get(b,q);if(!d){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&k&&a.xc(b,e);var g;if(d&&"function"!==typeof d)g=d;else{var h=a.S.instance,r=h.getBindingAccessors||f,p=a.B(function(){(g=d?d(e,b):r.call(h,b,e))&&e.Q&&e.Q();return g},null,{i:b});g&&p.ca()||(p=null)}var s;if(g){var t=p?function(a){return function(){return c(p()[a])}}:function(a){return g[a]},
        u=function(){return a.a.Ea(p?p():g,c)};u.get=function(a){return g[a]&&c(t(a))};u.has=function(a){return a in g};k=l(g);a.a.r(k,function(c){var d=c.jc.init,k=c.jc.update,f=c.key;if(8===b.nodeType&&!a.f.aa[f])throw Error("The binding '"+f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.l.w(function(){var a=d(b,t(f),u,e.$data,e);if(a&&a.controlsDescendantBindings){if(s!==n)throw Error("Multiple bindings ("+s+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
        s=f}}),"function"==typeof k&&a.B(function(){k(b,t(f),u,e.$data,e)},null,{i:b})}catch(m){throw m.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+m.message,m;}})}return{shouldBindDescendants:s===n}}function k(b){return b&&b instanceof a.R?b:new a.R(b)}a.d={};var r={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.d[b]};a.R=function(b,c,d,e,k){function f(){var k=g?b():b,m=a.a.c(k);c?(c.Q&&c.Q(),a.a.extend(l,c),l.Q=r):(l.$parents=[],l.$root=m,l.ko=a);l.$rawData=
        k;l.$data=m;d&&(l[d]=m);e&&e(l,c,m);return l.$data}function m(){return h&&!a.a.Tb(h)}var l=this,g="function"==typeof b&&!a.I(b),h,r;k&&k.exportDependencies?f():(r=a.B(f,null,{ya:m,i:!0}),r.ca()&&(l.Q=r,r.equalityComparer=null,h=[],r.Dc=function(b){h.push(b);a.a.G.qa(b,function(b){a.a.Na(h,b);h.length||(r.k(),l.Q=r=n)})}))};a.R.prototype.createChildContext=function(b,c,d,e){return new a.R(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);
        d&&d(a)},e)};a.R.prototype.extend=function(b){return new a.R(this.Q||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};a.R.prototype.ac=function(a,b){return this.createChildContext(a,b,null,{exportDependencies:!0})};var q=a.a.e.J(),p=a.a.e.J();a.xc=function(b,c){if(2==arguments.length)a.a.e.set(b,p,c),c.Q&&c.Q.Dc(b);else return a.a.e.get(b,p)};a.La=function(b,c,d){1===b.nodeType&&a.f.oc(b);return m(b,c,k(d),!0)};a.Ic=function(b,c,d){d=k(d);return a.La(b,
        e(c,d,b),d)};a.hb=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(k(a),b,!0)};a.Ub=function(a,b){!u&&x.jQuery&&(u=x.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||x.document.body;h(k(a),b,!0)};a.nb=function(b){switch(b.nodeType){case 1:case 8:var c=a.xc(b);if(c)return c;if(b.parentNode)return a.nb(b.parentNode)}return n};a.Oc=function(b){return(b=a.nb(b))?b.$data:n};a.b("bindingHandlers",
        a.d);a.b("applyBindings",a.Ub);a.b("applyBindingsToDescendants",a.hb);a.b("applyBindingAccessorsToNode",a.La);a.b("applyBindingsToNode",a.Ic);a.b("contextFor",a.nb);a.b("dataFor",a.Oc)})();(function(b){function c(c,e){var m=f.hasOwnProperty(c)?f[c]:b,k;m?m.Y(e):(m=f[c]=new a.K,m.Y(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,dd:e};delete f[c];k||e?m.notifySubscribers(b):a.Z.Za(function(){m.notifySubscribers(b)})}),k=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",
        [a,c],function(a){b(a,c)}):b(null,null)})}function e(c,d,f,k){k||(k=a.g.loaders.slice(0));var g=k.shift();if(g){var q=g[c];if(q){var p=!1;if(q.apply(g,d.concat(function(a){p?f(null):null!==a?f(a):e(c,d,f,k)}))!==b&&(p=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,k)}else f(null)}var f={},g={};a.g={get:function(d,e){var f=g.hasOwnProperty(d)?g[d]:b;f?f.dd?a.l.w(function(){e(f.definition)}):
        a.Z.Za(function(){e(f.definition)}):c(d,e)},$b:function(a){delete g[a]},Nb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.$b)})();(function(){function b(b,c,d,e){function g(){0===--y&&e(h)}var h={},y=2,v=d.template;d=d.viewModel;v?f(c,v,function(c){a.g.Nb("loadTemplate",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.g.Nb("loadViewModel",[b,c],function(a){h[l]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
    else if("function"===typeof b[l])d(b[l]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.A(b)){case "script":return a.a.na(b.text);case "textarea":return a.a.na(b.value);case "template":if(e(b.content))return a.a.wa(b.content.childNodes)}return a.a.wa(b.childNodes)}function e(a){return x.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
        O||x.require?(O||x.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.g.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.wb(b))throw Error("Component "+b+" is already registered");h[b]=c};a.g.wb=function(a){return h.hasOwnProperty(a)};a.g.ud=function(b){delete h[b];a.g.$b(b)};a.g.cc={getConfig:function(a,b){b(h.hasOwnProperty(a)?h[a]:null)},loadComponent:function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.na(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.W(c.childNodes));else if(c.element)if(c=c.element,x.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var l=t.getElementById(c);l?f(d(l)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),
        b,d)}};var l="createViewModel";a.b("components.register",a.g.register);a.b("components.isRegistered",a.g.wb);a.b("components.unregister",a.g.ud);a.b("components.defaultLoader",a.g.cc);a.g.loaders.push(a.g.cc);a.g.Ec=h})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ea(f,function(c){return a.m(c,null,{i:b})}),g=a.a.Ea(f,function(c){var e=c.p();return c.ca()?a.m({read:function(){return a.a.c(c())},write:a.Da(e)&&
    function(a){c()(a)},i:b}):e});g.hasOwnProperty("$raw")||(g.$raw=f);return g}return{$raw:{}}}a.g.getComponentNameForNode=function(b){var c=a.a.A(b);if(a.g.wb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.C&&b.tagName===c))return c};a.g.Rb=function(c,e,f,g){if(1===e.nodeType){var h=a.g.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var l={name:h,params:b(e,f)};c.component=g?function(){return l}:
        l}}return c};var c=new a.S;9>a.a.C&&(a.g.register=function(a){return function(b){t.createElement(b);return a.apply(this,arguments)}}(a.g.register),t.createDocumentFragment=function(b){return function(){var c=b(),f=a.g.Ec,g;for(g in f)f.hasOwnProperty(g)&&c.createElement(g);return c}}(t.createDocumentFragment))})();(function(b){function c(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.wa(c);a.f.fa(d,b)}function d(a,b,c,d){var e=a.createViewModel;return e?e.call(a,
        d,{element:b,templateNodes:c}):d}var e=0;a.d.component={init:function(f,g,h,l,m){function k(){var a=r&&r.dispose;"function"===typeof a&&a.call(r);q=r=null}var r,q,p=a.a.W(a.f.childNodes(f));a.a.G.qa(f,k);a.m(function(){var l=a.a.c(g()),h,v;"string"===typeof l?h=l:(h=a.a.c(l.name),v=a.a.c(l.params));if(!h)throw Error("No component name specified");var n=q=++e;a.g.get(h,function(e){if(q===n){k();if(!e)throw Error("Unknown component '"+h+"'");c(h,e,f);var l=d(e,f,p,v);e=m.createChildContext(l,b,function(a){a.$component=
        l;a.$componentTemplateNodes=p});r=l;a.hb(e,f)}})},null,{i:f});return{controlsDescendantBindings:!0}}};a.f.aa.component=!0})();var Q={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,c){var d=a.a.c(c())||{};a.a.D(d,function(c,d){d=a.a.c(d);var g=!1===d||null===d||d===n;g&&b.removeAttribute(c);8>=a.a.C&&c in Q?(c=Q[c],g?b.removeAttribute(c):b[c]=d):g||b.setAttribute(c,d.toString());"name"===c&&a.a.vc(b,g?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 c,d){function e(){var e=b.checked,f=p?g():e;if(!a.xa.Va()&&(!l||e)){var h=a.l.w(c);if(k){var m=r?h.p():h;q!==f?(e&&(a.a.ra(m,f,!0),a.a.ra(m,q,!1)),q=f):a.a.ra(m,f,e);r&&a.Da(h)&&h(m)}else a.h.Ga(h,d,"checked",f,!0)}}function f(){var d=a.a.c(c());b.checked=k?0<=a.a.o(d,g()):h?d:g()===d}var g=a.rc(function(){return d.has("checkedValue")?a.a.c(d.get("checkedValue")):d.has("value")?a.a.c(d.get("value")):b.value}),h="checkbox"==b.type,l="radio"==b.type;if(h||l){var m=c(),k=h&&a.a.c(m)instanceof Array,
        r=!(k&&m.push&&m.splice),q=k?g():n,p=l||k;l&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.m(e,null,{i:b});a.a.q(b,"click",e);a.m(f,null,{i:b});m=n}}};a.h.ga.checked=!0;a.d.checkedValue={update:function(b,c){b.value=a.a.c(c())}}})();a.d.css={update:function(b,c){var d=a.a.c(c());null!==d&&"object"==typeof d?a.a.D(d,function(c,d){d=a.a.c(d);a.a.fb(b,c,d)}):(d=a.a.cb(String(d||"")),a.a.fb(b,b.__ko__cssValue,!1),b.__ko__cssValue=d,a.a.fb(b,d,!0))}};a.d.enable={update:function(b,c){var d=a.a.c(c());
        d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,c){a.d.enable.update(b,function(){return!a.a.c(c())})}};a.d.event={init:function(b,c,d,e,f){var g=c()||{};a.a.D(g,function(g){"string"==typeof g&&a.a.q(b,g,function(b){var m,k=c()[g];if(k){try{var r=a.a.W(arguments);e=f.$data;r.unshift(e);m=k.apply(e,r)}finally{!0!==m&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};
    a.d.foreach={mc:function(b){return function(){var c=b(),d=a.a.Bb(c);if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.X.vb};a.a.c(c);return{foreach:d.data,as:d.as,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.X.vb}}},init:function(b,c){return a.d.template.init(b,a.d.foreach.mc(c))},update:function(b,c,d,e,f){return a.d.template.update(b,a.d.foreach.mc(c),
        d,e,f)}};a.h.va.foreach=!1;a.f.aa.foreach=!0;a.d.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(k){g=f.body}e=g===b}f=c();a.h.Ga(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.q(b,"focus",f);a.a.q(b,"focusin",f);a.a.q(b,"blur",g);a.a.q(b,"focusout",g)},update:function(b,c){var d=!!a.a.c(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
    d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.l.w(a.a.Fa,null,[b,d?"focusin":"focusout"]))}};a.h.ga.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.ga.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Eb(b,c())}};K("if");K("ifnot",!1,!0);K("with",!0,!1,function(a,c){return a.ac(c)});var L={};a.d.options={init:function(b){if("select"!==a.a.A(b))throw Error("options binding applies only to SELECT elements");for(;0<
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.Ma(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,e){if(A&&k)a.j.ja(b,a.a.c(d.get("value")),!0);else if(p.length){var f=0<=a.a.o(p,a.j.u(e[0]));a.a.wc(e[0],f);A&&!f&&a.l.w(a.a.Fa,null,[b,"change"])}}var h=b.multiple,l=0!=b.length&&h?b.scrollTop:null,m=a.a.c(c()),k=d.get("valueAllowUnset")&&d.has("value"),r=
        d.get("optionsIncludeDestroyed");c={};var q,p=[];k||(h?p=a.a.ib(e(),a.j.u):0<=b.selectedIndex&&p.push(a.j.u(b.options[b.selectedIndex])));m&&("undefined"==typeof m.length&&(m=[m]),q=a.a.Ma(m,function(b){return r||b===n||null===b||!a.a.c(b._destroy)}),d.has("optionsCaption")&&(m=a.a.c(d.get("optionsCaption")),null!==m&&m!==n&&q.unshift(L)));var A=!1;c.beforeRemove=function(a){b.removeChild(a)};m=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(m=function(b,c){g(0,c);
        a.l.w(d.get("optionsAfterRender"),null,[c[0],b!==L?b:n])});a.a.Db(b,q,function(c,e,g){g.length&&(p=!k&&g[0].selected?[a.j.u(g[0])]:[],A=!0);e=b.ownerDocument.createElement("option");c===L?(a.a.bb(e,d.get("optionsCaption")),a.j.ja(e,n)):(g=f(c,d.get("optionsValue"),c),a.j.ja(e,a.a.c(g)),c=f(c,d.get("optionsText"),g),a.a.bb(e,c));return[e]},c,m);a.l.w(function(){k?a.j.ja(b,a.a.c(d.get("value")),!0):(h?p.length&&e().length<p.length:p.length&&0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex])!==p[0]:
        p.length||0<=b.selectedIndex)&&a.a.Fa(b,"change")});a.a.Sc(b);l&&20<Math.abs(l-b.scrollTop)&&(b.scrollTop=l)}};a.d.options.zb=a.a.e.J();a.d.selectedOptions={after:["options","foreach"],init:function(b,c,d){a.a.q(b,"change",function(){var e=c(),f=[];a.a.r(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.j.u(b))});a.h.Ga(e,d,"selectedOptions",f)})},update:function(b,c){if("select"!=a.a.A(b))throw Error("values binding applies only to SELECT elements");var d=a.a.c(c()),e=b.scrollTop;
        d&&"number"==typeof d.length&&a.a.r(b.getElementsByTagName("option"),function(b){var c=0<=a.a.o(d,a.j.u(b));b.selected!=c&&a.a.wc(b,c)});b.scrollTop=e}};a.h.ga.selectedOptions=!0;a.d.style={update:function(b,c){var d=a.a.c(c()||{});a.a.D(d,function(c,d){d=a.a.c(d);if(null===d||d===n||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.q(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,
        b)}finally{!0!==d&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.bb(b,c())}};a.f.aa.text=!0;(function(){if(x&&x.navigator)var b=function(a){if(a)return parseFloat(a[1])},c=x.opera&&x.opera.version&&parseInt(x.opera.version()),d=x.navigator.userAgent,e=b(d.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),f=b(d.match(/Firefox\/([^ ]*)/));if(10>a.a.C)var g=a.a.e.J(),h=a.a.e.J(),l=function(b){var c=
        this.activeElement;(c=c&&a.a.e.get(c,h))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,g)||(a.a.e.set(d,g,!0),a.a.q(d,"selectionchange",l));a.a.e.set(b,h,c)};a.d.textInput={init:function(b,d,g){function l(c,d){a.a.q(b,c,d)}function h(){var c=a.a.c(d());if(null===c||c===n)c="";u!==n&&c===u?a.a.setTimeout(h,4):b.value!==c&&(s=c,b.value=c)}function y(){t||(u=b.value,t=a.a.setTimeout(v,4))}function v(){clearTimeout(t);u=t=n;var c=b.value;s!==c&&(s=c,a.h.Ga(d(),g,"textInput",c))}var s=b.value,
        t,u,x=9==a.a.C?y:v;10>a.a.C?(l("propertychange",function(a){"value"===a.propertyName&&x(a)}),8==a.a.C&&(l("keyup",v),l("keydown",v)),8<=a.a.C&&(m(b,x),l("dragend",y))):(l("input",v),5>e&&"textarea"===a.a.A(b)?(l("keydown",y),l("paste",y),l("cut",y)):11>c?l("keydown",y):4>f&&(l("DOMAutoComplete",v),l("dragdrop",v),l("drop",v)));l("change",v);a.m(h,null,{i:b})}};a.h.ga.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+
        ++a.d.uniqueName.Nc;a.a.vc(b,d)}}};a.d.uniqueName.Nc=0;a.d.value={after:["options","foreach"],init:function(b,c,d){if("input"!=b.tagName.toLowerCase()||"checkbox"!=b.type&&"radio"!=b.type){var e=["change"],f=d.get("valueUpdate"),g=!1,h=null;f&&("string"==typeof f&&(f=[f]),a.a.ta(e,f),e=a.a.Wb(e));var l=function(){h=null;g=!1;var e=c(),f=a.j.u(b);a.h.Ga(e,d,"value",f)};!a.a.C||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.o(e,"propertychange")||
    (a.a.q(b,"propertychange",function(){g=!0}),a.a.q(b,"focus",function(){g=!1}),a.a.q(b,"blur",function(){g&&l()}));a.a.r(e,function(c){var d=l;a.a.sd(c,"after")&&(d=function(){h=a.j.u(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.q(b,c,d)});var m=function(){var e=a.a.c(c()),f=a.j.u(b);if(null!==h&&e===h)a.a.setTimeout(m,0);else if(e!==f)if("select"===a.a.A(b)){var g=d.get("valueAllowUnset"),f=function(){a.j.ja(b,e,g)};f();g||e===a.j.u(b)?a.a.setTimeout(f,0):a.l.w(a.a.Fa,null,[b,"change"])}else a.j.ja(b,
        e)};a.m(m,null,{i:b})}else a.La(b,{checkedValue:c})},update:function(){}};a.h.ga.value=!0;a.d.visible={update:function(b,c){var d=a.a.c(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(c,d,e,f,g){return a.d.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");a.P=function(){};a.P.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.P.prototype.createJavaScriptEvaluatorBlock=
        function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.P.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||t;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.v.n(d)}if(1==b.nodeType||8==b.nodeType)return new a.v.sa(b);throw Error("Unknown template type: "+b);};a.P.prototype.renderTemplate=function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.P.prototype.isTemplateRewritten=function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.P.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.P);a.Ib=function(){function b(b,c,d,h){b=a.h.Ab(b);for(var l=a.h.va,m=0;m<b.length;m++){var k=b[m].key;if(l.hasOwnProperty(k)){var r=l[k];if("function"===typeof r){if(k=r(b[m].value))throw Error(k);}else if(!r)throw Error("This template engine does not support the '"+
        k+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.Xa(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{Tc:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.Ib.jd(b,
        c)},d)},jd:function(a,f){return a.replace(c,function(a,c,d,e,k){return b(k,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},Jc:function(b,c){return a.N.yb(function(d,h){var l=d.nextSibling;l&&l.nodeName.toLowerCase()===c&&a.La(l,b,h)})}}}();a.b("__tr_ambtns",a.Ib.Jc);(function(){a.v={};a.v.n=function(b){if(this.n=b){var c=a.a.A(b);this.eb="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4}};a.v.n.prototype.text=function(){var b=1===
    this.eb?"text":2===this.eb?"value":"innerHTML";if(0==arguments.length)return this.n[b];var c=arguments[0];"innerHTML"===b?a.a.Eb(this.n,c):this.n[b]=c};var b=a.a.e.J()+"_";a.v.n.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.n,b+c);a.a.e.set(this.n,b+c,arguments[1])};var c=a.a.e.J();a.v.n.prototype.nodes=function(){var b=this.n;if(0==arguments.length)return(a.a.e.get(b,c)||{}).mb||(3===this.eb?b.content:4===this.eb?b:n);a.a.e.set(b,c,{mb:arguments[0]})};a.v.sa=function(a){this.n=
        a};a.v.sa.prototype=new a.v.n;a.v.sa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.n,c)||{};b.Jb===n&&b.mb&&(b.Jb=b.mb.innerHTML);return b.Jb}a.a.e.set(this.n,c,{Jb:arguments[0]})};a.b("templateSources",a.v);a.b("templateSources.domElement",a.v.n);a.b("templateSources.anonymousTemplate",a.v.sa)})();(function(){function b(b,c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=
        a.S.instance,n=h.preprocessNode;if(n){b(e,f,function(a,b){var c=a.previousSibling,d=n.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):(c.push(e,f),a.a.Ba(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.Ub(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.N.Cc(b,[d])});a.a.Ba(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,q){q=q||{};var p=(b&&d(b)||f||{}).ownerDocument,n=q.templateEngine||g;
        a.Ib.Tc(f,n,p);f=n.renderTemplate(f,h,q,p);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");p=!1;switch(e){case "replaceChildren":a.f.fa(b,f);p=!0;break;case "replaceNode":a.a.uc(b,f);p=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}p&&(c(f,h),q.afterRender&&a.l.w(q.afterRender,null,[f,h.$data]));return f}function f(b,c,d){return a.I(b)?b():"function"===typeof b?b(c,d):b}
        var g;a.Fb=function(b){if(b!=n&&!(b instanceof a.P))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Cb=function(b,c,k,h,q){k=k||{};if((k.templateEngine||g)==n)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(h){var p=d(h);return a.B(function(){var g=c&&c instanceof a.R?c:new a.R(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(h,q,n,g,k);"replaceNode"==q&&(h=g,p=d(h))},null,{ya:function(){return!p||!a.a.qb(p)},i:p&&
        "replaceNode"==q?p.parentNode:p})}return a.N.yb(function(d){a.Cb(b,c,k,d,"replaceNode")})};a.pd=function(b,d,g,h,q){function p(a,b){c(b,t);g.afterRender&&g.afterRender(b,a);t=null}function s(a,c){t=q.createChildContext(a,g.as,function(a){a.$index=c});var d=f(b,a,t);return e(null,"ignoreTargetNode",d,t,g)}var t;return a.B(function(){var b=a.a.c(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.Ma(b,function(b){return g.includeDestroyed||b===n||null===b||!a.a.c(b._destroy)});a.l.w(a.a.Db,null,[h,b,
            s,g,p])},null,{i:h})};var h=a.a.e.J();a.d.template={init:function(b,c){var d=a.a.c(c());if("string"==typeof d||d.name)a.f.za(b);else{if("nodes"in d){if(d=d.nodes||[],a.I(d))throw Error('The "nodes" option must be a plain, non-observable array.');}else d=a.f.childNodes(b);d=a.a.nc(d);(new a.v.sa(b)).nodes(d)}return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.c(g);d=!0;e=null;"string"==typeof c?c={}:(g=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)));
            "foreach"in c?e=a.pd(g||b,d&&c.foreach||[],c,b,f):d?(f="data"in c?f.ac(c.data,c.as):f,e=a.Cb(g||b,f,c,b)):a.f.za(b);f=e;(c=a.a.e.get(b,h))&&"function"==typeof c.k&&c.k();a.a.e.set(b,h,f&&f.ca()?f:n)}};a.h.va.template=function(b){b=a.h.Ab(b);return 1==b.length&&b[0].unknown||a.h.fd(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.aa.template=!0})();a.b("setTemplateEngine",a.Fb);a.b("renderTemplate",a.Cb);a.a.hc=function(a,c,d){if(a.length&&
        c.length){var e,f,g,h,l;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;l=c[g];++g)if(h.value===l.value){h.moved=l.index;l.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.lb=function(){function b(b,d,e,f,g){var h=Math.min,l=Math.max,m=[],k,n=b.length,q,p=d.length,s=p-n||1,t=n+p+1,v,u,x;for(k=0;k<=n;k++)for(u=v,m.push(v=[]),x=h(p,k+s),q=l(0,k-1);q<=x;q++)v[q]=q?k?b[k-1]===d[q-1]?u[q-1]:h(u[q]||t,v[q-1]||t)+1:q+1:k+1;h=[];l=[];s=[];k=n;for(q=p;k||q;)p=m[k][q]-1,q&&p===m[k][q-1]?l.push(h[h.length]={status:e,
        value:d[--q],index:q}):k&&p===m[k-1][q]?s.push(h[h.length]={status:f,value:b[--k],index:k}):(--q,--k,g.sparse||h.push({status:"retained",value:d[q]}));a.a.hc(s,l,!g.dontLimitMoves&&10*n);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.lb);(function(){function b(b,c,d,h,l){var m=[],k=a.B(function(){var k=c(d,l,a.a.Ba(m,b))||[];0<
    m.length&&(a.a.uc(m,k),h&&a.l.w(h,null,[d,k,l]));m.length=0;a.a.ta(m,k)},null,{i:b,ya:function(){return!a.a.Tb(m)}});return{ea:m,B:k.ca()?k:n}}var c=a.a.e.J(),d=a.a.e.J();a.a.Db=function(e,f,g,h,l){function m(b,c){w=q[c];u!==c&&(D[b]=w);w.tb(u++);a.a.Ba(w.ea,e);t.push(w);z.push(w)}function k(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.r(c[d].ea,function(a){b(a,d,c[d].ka)})}f=f||[];h=h||{};var r=a.a.e.get(e,c)===n,q=a.a.e.get(e,c)||[],p=a.a.ib(q,function(a){return a.ka}),s=a.a.lb(p,f,h.dontLimitMoves),
        t=[],v=0,u=0,x=[],z=[];f=[];for(var D=[],p=[],w,C=0,B,E;B=s[C];C++)switch(E=B.moved,B.status){case "deleted":E===n&&(w=q[v],w.B&&(w.B.k(),w.B=n),a.a.Ba(w.ea,e).length&&(h.beforeRemove&&(t.push(w),z.push(w),w.ka===d?w=null:f[C]=w),w&&x.push.apply(x,w.ea)));v++;break;case "retained":m(C,v++);break;case "added":E!==n?m(C,E):(w={ka:B.value,tb:a.O(u++)},t.push(w),z.push(w),r||(p[C]=w))}a.a.e.set(e,c,t);k(h.beforeMove,D);a.a.r(x,h.beforeRemove?a.ba:a.removeNode);for(var C=0,r=a.f.firstChild(e),F;w=z[C];C++){w.ea||
    a.a.extend(w,b(e,g,w.ka,l,w.tb));for(v=0;s=w.ea[v];r=s.nextSibling,F=s,v++)s!==r&&a.f.kc(e,s,F);!w.ad&&l&&(l(w.ka,w.ea,w.tb),w.ad=!0)}k(h.beforeRemove,f);for(C=0;C<f.length;++C)f[C]&&(f[C].ka=d);k(h.afterMove,D);k(h.afterAdd,p)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Db);a.X=function(){this.allowTemplateRewriting=!1};a.X.prototype=new a.P;a.X.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.C?0:b.nodes)?b.nodes():null)return a.a.W(c.cloneNode(!0).childNodes);b=b.text();
        return a.a.na(b,e)};a.X.vb=new a.X;a.Fb(a.X.vb);a.b("nativeTemplateEngine",a.X);(function(){a.xb=function(){var a=this.ed=function(){if(!u||!u.tmpl)return 0;try{if(0<=u.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,f,g){g=g||t;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=u.template(null,"{{ko_with $item.koBindingContext}}"+
        h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=u.extend({koBindingContext:e},f.templateOptions);e=u.tmpl(h,b,e);e.appendTo(g.createElement("div"));u.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){t.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(u.tmpl.tag.ko_code={open:"__.push($1 || '');"},u.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.xb.prototype=
        new a.P;var b=new a.xb;0<b.ed&&a.Fb(b);a.b("jqueryTmplTemplateEngine",a.xb)})()})})();})();
/**
 * Bootstrap Multiselect (http://davidstutz.de/bootstrap-multiselect/)
 *
 * Apache License, Version 2.0:
 * Copyright (c) 2012 - 2018 David Stutz
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * BSD 3-Clause License:
 * Copyright (c) 2012 - 2018 David Stutz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    - Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *    - Neither the name of David Stutz nor the names of its contributors may be
 *      used to endorse or promote products derived from this software without
 *      specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
(function (root, factory) {
    // check to see if 'knockout' AMD module is specified if using requirejs
    if (typeof define === 'function' && define.amd &&
        typeof require === 'function' && typeof require.specified === 'function' && require.specified('knockout')) {

        // AMD. Register as an anonymous module.
        define('multiselect',['jquery', 'knockout'], factory);
    } else {
        // Browser globals
        factory(root.jQuery, root.ko);
    }
})(this, function ($, ko) {
    "use strict";// jshint ;_;

    if (typeof ko !== 'undefined' && ko.bindingHandlers && !ko.bindingHandlers.multiselect) {
        ko.bindingHandlers.multiselect = {
            after: ['options', 'value', 'selectedOptions', 'enable', 'disable'],

            init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
                var $element = $(element);
                var config = ko.toJS(valueAccessor());

                $element.multiselect(config);

                if (allBindings.has('options')) {
                    var options = allBindings.get('options');
                    if (ko.isObservable(options)) {
                        ko.computed({
                            read: function() {
                                options();
                                setTimeout(function() {
                                    var ms = $element.data('multiselect');
                                    if (ms)
                                        ms.updateOriginalOptions();//Not sure how beneficial this is.
                                    $element.multiselect('rebuild');
                                }, 1);
                            },
                            disposeWhenNodeIsRemoved: element
                        });
                    }
                }

                //value and selectedOptions are two-way, so these will be triggered even by our own actions.
                //It needs some way to tell if they are triggered because of us or because of outside change.
                //It doesn't loop but it's a waste of processing.
                if (allBindings.has('value')) {
                    var value = allBindings.get('value');
                    if (ko.isObservable(value)) {
                        ko.computed({
                            read: function() {
                                value();
                                setTimeout(function() {
                                    $element.multiselect('refresh');
                                }, 1);
                            },
                            disposeWhenNodeIsRemoved: element
                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
                    }
                }

                //Switched from arrayChange subscription to general subscription using 'refresh'.
                //Not sure performance is any better using 'select' and 'deselect'.
                if (allBindings.has('selectedOptions')) {
                    var selectedOptions = allBindings.get('selectedOptions');
                    if (ko.isObservable(selectedOptions)) {
                        ko.computed({
                            read: function() {
                                selectedOptions();
                                setTimeout(function() {
                                    $element.multiselect('refresh');
                                }, 1);
                            },
                            disposeWhenNodeIsRemoved: element
                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
                    }
                }

                var setEnabled = function (enable) {
                    setTimeout(function () {
                        if (enable)
                            $element.multiselect('enable');
                        else
                            $element.multiselect('disable');
                    });
                };

                if (allBindings.has('enable')) {
                    var enable = allBindings.get('enable');
                    if (ko.isObservable(enable)) {
                        ko.computed({
                            read: function () {
                                setEnabled(enable());
                            },
                            disposeWhenNodeIsRemoved: element
                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
                    } else {
                        setEnabled(enable);
                    }
                }

                if (allBindings.has('disable')) {
                    var disable = allBindings.get('disable');
                    if (ko.isObservable(disable)) {
                        ko.computed({
                            read: function () {
                                setEnabled(!disable());
                            },
                            disposeWhenNodeIsRemoved: element
                        }).extend({ rateLimit: 100, notifyWhenChangesStop: true });
                    } else {
                        setEnabled(!disable);
                    }
                }

                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                    $element.multiselect('destroy');
                });
            },

            update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
                var $element = $(element);
                var config = ko.toJS(valueAccessor());

                $element.multiselect('setOptions', config);
                $element.multiselect('rebuild');
            }
        };
    }

    function forEach(array, callback) {
        for (var index = 0; index < array.length; ++index) {
            callback(array[index], index);
        }
    }

    /**
     * Constructor to create a new multiselect using the given select.
     *
     * @param {jQuery} select
     * @param {Object} options
     * @returns {Multiselect}
     */
    function Multiselect(select, options) {

        this.$select = $(select);
        this.options = this.mergeOptions($.extend({}, options, this.$select.data()));

        // Placeholder via data attributes
        if (this.$select.attr("data-placeholder")) {
            this.options.nonSelectedText = this.$select.data("placeholder");
        }

        // Initialization.
        // We have to clone to create a new reference.
        this.originalOptions = this.$select.clone()[0].options;
        this.query = '';
        this.searchTimeout = null;
        this.lastToggledInput = null;

        this.options.multiple = this.$select.attr('multiple') === "multiple";
        this.options.onChange = $.proxy(this.options.onChange, this);
        this.options.onSelectAll = $.proxy(this.options.onSelectAll, this);
        this.options.onDeselectAll = $.proxy(this.options.onDeselectAll, this);
        this.options.onDropdownShow = $.proxy(this.options.onDropdownShow, this);
        this.options.onDropdownHide = $.proxy(this.options.onDropdownHide, this);
        this.options.onDropdownShown = $.proxy(this.options.onDropdownShown, this);
        this.options.onDropdownHidden = $.proxy(this.options.onDropdownHidden, this);
        this.options.onInitialized = $.proxy(this.options.onInitialized, this);
        this.options.onFiltering = $.proxy(this.options.onFiltering, this);

        // Build select all if enabled.
        this.buildContainer();
        this.buildButton();
        this.buildDropdown();
        this.buildReset();
        this.buildSelectAll();
        this.buildDropdownOptions();
        this.buildFilter();

        this.updateButtonText();
        this.updateSelectAll(true);

        if (this.options.enableClickableOptGroups && this.options.multiple) {
            this.updateOptGroups();
        }

        this.options.wasDisabled = this.$select.prop('disabled');
        if (this.options.disableIfEmpty && $('option', this.$select).length <= 0) {
            this.disable();
        }

        this.$select.wrap('<span class="multiselect-native-select" />').after(this.$container);
        this.options.onInitialized(this.$select, this.$container);
    }

    Multiselect.prototype = {

        defaults: {
            /**
             * Default text function will either print 'None selected' in case no
             * option is selected or a list of the selected options up to a length
             * of 3 selected options.
             *
             * @param {jQuery} options
             * @param {jQuery} select
             * @returns {String}
             */
            buttonText: function(options, select) {
                if (this.disabledText.length > 0
                    && (select.prop('disabled') || (options.length == 0 && this.disableIfEmpty)))  {

                    return this.disabledText;
                }
                else if (options.length === 0) {
                    return this.nonSelectedText;
                }
                else if (this.allSelectedText
                    && options.length === $('option', $(select)).length
                    && $('option', $(select)).length !== 1
                    && this.multiple) {

                    if (this.selectAllNumber) {
                        return this.allSelectedText + ' (' + options.length + ')';
                    }
                    else {
                        return this.allSelectedText;
                    }
                }
                else if (this.numberDisplayed != 0 && options.length > this.numberDisplayed) {
                    return options.length + ' ' + this.nSelectedText;
                }
                else {
                    var selected = '';
                    var delimiter = this.delimiterText;

                    options.each(function() {
                        var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).text();
                        selected += label + delimiter;
                    });

                    return selected.substr(0, selected.length - this.delimiterText.length);
                }
            },
            /**
             * Updates the title of the button similar to the buttonText function.
             *
             * @param {jQuery} options
             * @param {jQuery} select
             * @returns {@exp;selected@call;substr}
             */
            buttonTitle: function(options, select) {
                if (options.length === 0) {
                    return this.nonSelectedText;
                }
                else {
                    var selected = '';
                    var delimiter = this.delimiterText;

                    options.each(function () {
                        var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).text();
                        selected += label + delimiter;
                    });
                    return selected.substr(0, selected.length - this.delimiterText.length);
                }
            },
            checkboxName: function(option) {
                return false; // no checkbox name
            },
            /**
             * Create a label.
             *
             * @param {jQuery} element
             * @returns {String}
             */
            optionLabel: function(element){
                return $(element).attr('label') || $(element).text();
            },
            /**
             * Create a class.
             *
             * @param {jQuery} element
             * @returns {String}
             */
            optionClass: function(element) {
                return $(element).attr('class') || '';
            },
            /**
             * Triggered on change of the multiselect.
             *
             * Not triggered when selecting/deselecting options manually.
             *
             * @param {jQuery} option
             * @param {Boolean} checked
             */
            onChange : function(option, checked) {

            },
            /**
             * Triggered when the dropdown is shown.
             *
             * @param {jQuery} event
             */
            onDropdownShow: function(event) {

            },
            /**
             * Triggered when the dropdown is hidden.
             *
             * @param {jQuery} event
             */
            onDropdownHide: function(event) {

            },
            /**
             * Triggered after the dropdown is shown.
             *
             * @param {jQuery} event
             */
            onDropdownShown: function(event) {

            },
            /**
             * Triggered after the dropdown is hidden.
             *
             * @param {jQuery} event
             */
            onDropdownHidden: function(event) {

            },
            /**
             * Triggered on select all.
             */
            onSelectAll: function() {

            },
            /**
             * Triggered on deselect all.
             */
            onDeselectAll: function() {

            },
            /**
             * Triggered after initializing.
             *
             * @param {jQuery} $select
             * @param {jQuery} $container
             */
            onInitialized: function($select, $container) {

            },
            /**
             * Triggered on filtering.
             *
             * @param {jQuery} $filter
             */
            onFiltering: function($filter) {

            },
            enableHTML: false,
            buttonClass: 'btn btn-default',
            inheritClass: false,
            buttonWidth: 'auto',
            buttonContainer: '<div class="btn-group" />',
            dropRight: false,
            dropUp: false,
            selectedClass: 'active',
            // Maximum height of the dropdown menu.
            // If maximum height is exceeded a scrollbar will be displayed.
            maxHeight: false,
            includeSelectAllOption: false,
            includeSelectAllIfMoreThan: 0,
            selectAllText: ' Select all',
            selectAllValue: 'multiselect-all',
            selectAllName: false,
            selectAllNumber: true,
            selectAllJustVisible: true,
            enableFiltering: false,
            enableCaseInsensitiveFiltering: false,
            enableFullValueFiltering: false,
            enableClickableOptGroups: false,
            enableCollapsibleOptGroups: false,
            collapseOptGroupsByDefault: false,
            filterPlaceholder: 'Search',
            // possible options: 'text', 'value', 'both'
            filterBehavior: 'text',
            includeFilterClearBtn: true,
            preventInputChangeEvent: false,
            nonSelectedText: 'None selected',
            nSelectedText: 'selected',
            allSelectedText: 'All selected',
            numberDisplayed: 3,
            disableIfEmpty: false,
            disabledText: '',
            delimiterText: ', ',
            includeResetOption: false,
            includeResetDivider: false,
            resetText: 'Reset',
            templates: {
                //button: '<button type="button" class="multiselect dropdown-toggle" data-toggle="dropdown"><span class="multiselect-selected-text"></span> <b class="caret"></b></button>',
                button: '<button type="button" class="multiselect dropdown-toggle" data-toggle="dropdown"><span class="multiselect-selected-text"></span></button>',        // smap for bootstrap 4
                ul: '<ul class="multiselect-container dropdown-menu"></ul>',
                filter: '<li class="multiselect-item multiselect-filter"><div class="input-group"><span class="input-group-addon"><i class="glyphicon glyphicon-search"></i></span><input class="form-control multiselect-search" type="text" /></div></li>',
                filterClearBtn: '<span class="input-group-btn"><button class="btn btn-default multiselect-clear-filter" type="button"><i class="glyphicon glyphicon-remove-circle"></i></button></span>',
                li: '<li><a tabindex="0"><label></label></a></li>',
                divider: '<li class="multiselect-item divider"></li>',
                liGroup: '<li class="multiselect-item multiselect-group"><label></label></li>',
                resetButton: '<li class="multiselect-reset text-center"><div class="input-group"><a class="btn btn-default btn-block"></a></div></li>'
            }
        },

        constructor: Multiselect,

        /**
         * Builds the container of the multiselect.
         */
        buildContainer: function() {
            this.$container = $(this.options.buttonContainer);
            this.$container.on('show.bs.dropdown', this.options.onDropdownShow);
            this.$container.on('hide.bs.dropdown', this.options.onDropdownHide);
            this.$container.on('shown.bs.dropdown', this.options.onDropdownShown);
            this.$container.on('hidden.bs.dropdown', this.options.onDropdownHidden);
        },

        /**
         * Builds the button of the multiselect.
         */
        buildButton: function() {
            this.$button = $(this.options.templates.button).addClass(this.options.buttonClass);
            if (this.$select.attr('class') && this.options.inheritClass) {
                this.$button.addClass(this.$select.attr('class'));
            }
            // Adopt active state.
            if (this.$select.prop('disabled')) {
                this.disable();
            }
            else {
                this.enable();
            }

            // Manually add button width if set.
            if (this.options.buttonWidth && this.options.buttonWidth !== 'auto') {
                this.$button.css({
                    'width' : '100%', //this.options.buttonWidth,
                    'overflow' : 'hidden',
                    'text-overflow' : 'ellipsis'
                });
                this.$container.css({
                    'width': this.options.buttonWidth
                });
            }

            // Keep the tab index from the select.
            var tabindex = this.$select.attr('tabindex');
            if (tabindex) {
                this.$button.attr('tabindex', tabindex);
            }

            this.$container.prepend(this.$button);
        },

        /**
         * Builds the ul representing the dropdown menu.
         */
        buildDropdown: function() {

            // Build ul.
            this.$ul = $(this.options.templates.ul);

            if (this.options.dropRight) {
                this.$ul.addClass('pull-right');
            }

            // Set max height of dropdown menu to activate auto scrollbar.
            if (this.options.maxHeight) {
                // TODO: Add a class for this option to move the css declarations.
                this.$ul.css({
                    'max-height': this.options.maxHeight + 'px',
                    'overflow-y': 'auto',
                    'overflow-x': 'hidden'
                });
            }

            if (this.options.dropUp) {

                var height = Math.min(this.options.maxHeight, $('option[data-role!="divider"]', this.$select).length*26 + $('option[data-role="divider"]', this.$select).length*19 + (this.options.includeSelectAllOption ? 26 : 0) + (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering ? 44 : 0));
                var moveCalc = height + 34;

                this.$ul.css({
                    'max-height': height + 'px',
                    'overflow-y': 'auto',
                    'overflow-x': 'hidden',
                    'margin-top': "-" + moveCalc + 'px'
                });
            }

            this.$container.append(this.$ul);
        },

        /**
         * Build the dropdown options and binds all necessary events.
         *
         * Uses createDivider and createOptionValue to create the necessary options.
         */
        buildDropdownOptions: function() {

            this.$select.children().each($.proxy(function(index, element) {

                var $element = $(element);
                // Support optgroups and options without a group simultaneously.
                var tag = $element.prop('tagName')
                    .toLowerCase();

                if ($element.prop('value') === this.options.selectAllValue) {
                    return;
                }

                if (tag === 'optgroup') {
                    this.createOptgroup(element);
                }
                else if (tag === 'option') {

                    if ($element.data('role') === 'divider') {
                        this.createDivider();
                    }
                    else {
                        this.createOptionValue(element);
                    }

                }

                // Other illegal tags will be ignored.
            }, this));

            // Bind the change event on the dropdown elements.
            $(this.$ul).off('change', 'li:not(.multiselect-group) input[type="checkbox"], li:not(.multiselect-group) input[type="radio"]');
            $(this.$ul).on('change', 'li:not(.multiselect-group) input[type="checkbox"], li:not(.multiselect-group) input[type="radio"]', $.proxy(function(event) {
                var $target = $(event.target);

                var checked = $target.prop('checked') || false;
                var isSelectAllOption = $target.val() === this.options.selectAllValue;

                // Apply or unapply the configured selected class.
                if (this.options.selectedClass) {
                    if (checked) {
                        $target.closest('li')
                            .addClass(this.options.selectedClass);
                    }
                    else {
                        $target.closest('li')
                            .removeClass(this.options.selectedClass);
                    }
                }

                // Get the corresponding option.
                var value = $target.val();
                var $option = this.getOptionByValue(value);

                var $optionsNotThis = $('option', this.$select).not($option);
                var $checkboxesNotThis = $('input', this.$container).not($target);

                if (isSelectAllOption) {

                    if (checked) {
                        this.selectAll(this.options.selectAllJustVisible, true);
                    }
                    else {
                        this.deselectAll(this.options.selectAllJustVisible, true);
                    }
                }
                else {
                    if (checked) {
                        $option.prop('selected', true);

                        if (this.options.multiple) {
                            // Simply select additional option.
                            $option.prop('selected', true);
                        }
                        else {
                            // Unselect all other options and corresponding checkboxes.
                            if (this.options.selectedClass) {
                                $($checkboxesNotThis).closest('li').removeClass(this.options.selectedClass);
                            }

                            $($checkboxesNotThis).prop('checked', false);
                            $optionsNotThis.prop('selected', false);

                            // It's a single selection, so close.
                            this.$button.click();
                        }

                        if (this.options.selectedClass === "active") {
                            $optionsNotThis.closest("a").css("outline", "");
                        }
                    }
                    else {
                        // Unselect option.
                        $option.prop('selected', false);
                    }

                    // To prevent select all from firing onChange: #575
                    this.options.onChange($option, checked);

                    // Do not update select all or optgroups on select all change!
                    this.updateSelectAll();

                    if (this.options.enableClickableOptGroups && this.options.multiple) {
                        this.updateOptGroups();
                    }
                }

                this.$select.change();
                this.updateButtonText();

                if(this.options.preventInputChangeEvent) {
                    return false;
                }
            }, this));

            $('li a', this.$ul).on('mousedown', function(e) {
                if (e.shiftKey) {
                    // Prevent selecting text by Shift+click
                    return false;
                }
            });

            $(this.$ul).on('touchstart click', 'li a', $.proxy(function(event) {
                event.stopPropagation();

                var $target = $(event.target);

                if (event.shiftKey && this.options.multiple) {
                    if($target.is("label")){ // Handles checkbox selection manually (see https://github.com/davidstutz/bootstrap-multiselect/issues/431)
                        event.preventDefault();
                        $target = $target.find("input");
                        $target.prop("checked", !$target.prop("checked"));
                    }
                    var checked = $target.prop('checked') || false;

                    if (this.lastToggledInput !== null && this.lastToggledInput !== $target) { // Make sure we actually have a range
                        var from = this.$ul.find("li:visible").index($target.parents("li"));
                        var to = this.$ul.find("li:visible").index(this.lastToggledInput.parents("li"));

                        if (from > to) { // Swap the indices
                            var tmp = to;
                            to = from;
                            from = tmp;
                        }

                        // Make sure we grab all elements since slice excludes the last index
                        ++to;

                        // Change the checkboxes and underlying options
                        var range = this.$ul.find("li").not(".multiselect-filter-hidden").slice(from, to).find("input");

                        range.prop('checked', checked);

                        if (this.options.selectedClass) {
                            range.closest('li')
                                .toggleClass(this.options.selectedClass, checked);
                        }

                        for (var i = 0, j = range.length; i < j; i++) {
                            var $checkbox = $(range[i]);

                            var $option = this.getOptionByValue($checkbox.val());

                            $option.prop('selected', checked);
                        }
                    }

                    // Trigger the select "change" event
                    $target.trigger("change");
                }

                // Remembers last clicked option
                if($target.is("input") && !$target.closest("li").is(".multiselect-item")){
                    this.lastToggledInput = $target;
                }

                $target.blur();
            }, this));

            // Keyboard support.
            this.$container.off('keydown.multiselect').on('keydown.multiselect', $.proxy(function(event) {
                if ($('input[type="text"]', this.$container).is(':focus')) {
                    return;
                }

                if (event.keyCode === 9 && this.$container.hasClass('open')) {
                    this.$button.click();
                }
                else {
                    var $items = $(this.$container).find("li:not(.divider):not(.disabled) a").filter(":visible");

                    if (!$items.length) {
                        return;
                    }

                    var index = $items.index($items.filter(':focus'));

                    // Navigation up.
                    if (event.keyCode === 38 && index > 0) {
                        index--;
                    }
                    // Navigate down.
                    else if (event.keyCode === 40 && index < $items.length - 1) {
                        index++;
                    }
                    else if (!~index) {
                        index = 0;
                    }

                    var $current = $items.eq(index);
                    $current.focus();

                    if (event.keyCode === 32 || event.keyCode === 13) {
                        var $checkbox = $current.find('input');

                        $checkbox.prop("checked", !$checkbox.prop("checked"));
                        $checkbox.change();
                    }

                    event.stopPropagation();
                    event.preventDefault();
                }
            }, this));

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                $("li.multiselect-group input", this.$ul).on("change", $.proxy(function(event) {
                    event.stopPropagation();

                    var $target = $(event.target);
                    var checked = $target.prop('checked') || false;

                    var $li = $(event.target).closest('li');
                    var $group = $li.nextUntil("li.multiselect-group")
                        .not('.multiselect-filter-hidden')
                        .not('.disabled');

                    var $inputs = $group.find("input");

                    var values = [];
                    var $options = [];

                    if (this.options.selectedClass) {
                        if (checked) {
                            $li.addClass(this.options.selectedClass);
                        }
                        else {
                            $li.removeClass(this.options.selectedClass);
                        }
                    }

                    $.each($inputs, $.proxy(function(index, input) {
                        var value = $(input).val();
                        var $option = this.getOptionByValue(value);

                        if (checked) {
                            $(input).prop('checked', true);
                            $(input).closest('li')
                                .addClass(this.options.selectedClass);

                            $option.prop('selected', true);
                        }
                        else {
                            $(input).prop('checked', false);
                            $(input).closest('li')
                                .removeClass(this.options.selectedClass);

                            $option.prop('selected', false);
                        }

                        $options.push(this.getOptionByValue(value));
                    }, this))

                    // Cannot use select or deselect here because it would call updateOptGroups again.

                    this.options.onChange($options, checked);

                    this.$select.change();
                    this.updateButtonText();
                    this.updateSelectAll();
                }, this));
            }

            if (this.options.enableCollapsibleOptGroups && this.options.multiple) {
                $("li.multiselect-group .caret-container", this.$ul).on("click", $.proxy(function(event) {
                    var $li = $(event.target).closest('li');
                    var $inputs = $li.nextUntil("li.multiselect-group")
                        .not('.multiselect-filter-hidden');

                    var visible = true;
                    $inputs.each(function() {
                        visible = visible && !$(this).hasClass('multiselect-collapsible-hidden');
                    });

                    if (visible) {
                        $inputs.hide()
                            .addClass('multiselect-collapsible-hidden');
                    }
                    else {
                        $inputs.show()
                            .removeClass('multiselect-collapsible-hidden');
                    }
                }, this));

                $("li.multiselect-all", this.$ul).css('background', '#f3f3f3').css('border-bottom', '1px solid #eaeaea');
                $("li.multiselect-all > a > label.checkbox", this.$ul).css('padding', '3px 20px 3px 35px');
                $("li.multiselect-group > a > input", this.$ul).css('margin', '4px 0px 5px -20px');
            }
        },

        /**
         * Create an option using the given select option.
         *
         * @param {jQuery} element
         */
        createOptionValue: function(element) {
            var $element = $(element);
            if ($element.is(':selected')) {
                $element.prop('selected', true);
            }

            // Support the label attribute on options.
            var label = this.options.optionLabel(element);
            var classes = this.options.optionClass(element);
            var value = $element.val();
            var inputType = this.options.multiple ? "checkbox" : "radio";

            var $li = $(this.options.templates.li);
            var $label = $('label', $li);
            $label.addClass(inputType);
            $label.attr("title", label);
            $li.addClass(classes);

            // Hide all children items when collapseOptGroupsByDefault is true
            if (this.options.collapseOptGroupsByDefault && $(element).parent().prop("tagName").toLowerCase() === "optgroup") {
                $li.addClass("multiselect-collapsible-hidden");
                $li.hide();
            }

            if (this.options.enableHTML) {
                $label.html(" " + label);
            }
            else {
                $label.text(" " + label);
            }

            var $checkbox = $('<input/>').attr('type', inputType);

            var name = this.options.checkboxName($element);
            if (name) {
                $checkbox.attr('name', name);
            }

            $label.prepend($checkbox);

            var selected = $element.prop('selected') || false;
            $checkbox.val(value);

            if (value === this.options.selectAllValue) {
                $li.addClass("multiselect-item multiselect-all");
                $checkbox.parent().parent()
                    .addClass('multiselect-all');
            }

            $label.attr('title', $element.attr('title'));

            this.$ul.append($li);

            if ($element.is(':disabled')) {
                $checkbox.attr('disabled', 'disabled')
                    .prop('disabled', true)
                    .closest('a')
                    .attr("tabindex", "-1")
                    .closest('li')
                    .addClass('disabled');
            }

            $checkbox.prop('checked', selected);

            if (selected && this.options.selectedClass) {
                $checkbox.closest('li')
                    .addClass(this.options.selectedClass);
            }
        },

        /**
         * Creates a divider using the given select option.
         *
         * @param {jQuery} element
         */
        createDivider: function(element) {
            var $divider = $(this.options.templates.divider);
            this.$ul.append($divider);
        },

        /**
         * Creates an optgroup.
         *
         * @param {jQuery} group
         */
        createOptgroup: function(group) {
            var label = $(group).attr("label");
            var value = $(group).attr("value");
            var $li = $('<li class="multiselect-item multiselect-group"><a href="javascript:void(0);"><label><b></b></label></a></li>');

            var classes = this.options.optionClass(group);
            $li.addClass(classes);

            if (this.options.enableHTML) {
                $('label b', $li).html(" " + label);
            }
            else {
                $('label b', $li).text(" " + label);
            }

            if (this.options.enableCollapsibleOptGroups && this.options.multiple) {
                $('a', $li).append('<span class="caret-container"><b class="caret"></b></span>');
            }

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                $('a label', $li).prepend('<input type="checkbox" value="' + value + '"/>');
            }

            if ($(group).is(':disabled')) {
                $li.addClass('disabled');
            }

            this.$ul.append($li);

            $("option", group).each($.proxy(function($, group) {
                this.createOptionValue(group);
            }, this))
        },

        /**
         * Build the reset.
         *
         */
        buildReset: function() {
            if (this.options.includeResetOption) {

                // Check whether to add a divider after the reset.
                if (this.options.includeResetDivider) {
                    this.$ul.prepend($(this.options.templates.divider));
                }

                var $resetButton = $(this.options.templates.resetButton);

                if (this.options.enableHTML) {
                    $('a', $resetButton).html(this.options.resetText);
                }
                else {
                    $('a', $resetButton).text(this.options.resetText);
                }

                $('a', $resetButton).click($.proxy(function(){
                    this.clearSelection();
                }, this));

                this.$ul.prepend($resetButton);
            }
        },

        /**
         * Build the select all.
         *
         * Checks if a select all has already been created.
         */
        buildSelectAll: function() {
            if (typeof this.options.selectAllValue === 'number') {
                this.options.selectAllValue = this.options.selectAllValue.toString();
            }

            var alreadyHasSelectAll = this.hasSelectAll();

            if (!alreadyHasSelectAll && this.options.includeSelectAllOption && this.options.multiple
                && $('option', this.$select).length > this.options.includeSelectAllIfMoreThan) {

                // Check whether to add a divider after the select all.
                if (this.options.includeSelectAllDivider) {
                    this.$ul.prepend($(this.options.templates.divider));
                }

                var $li = $(this.options.templates.li);
                $('label', $li).addClass("checkbox");

                if (this.options.enableHTML) {
                    $('label', $li).html(" " + this.options.selectAllText);
                }
                else {
                    $('label', $li).text(" " + this.options.selectAllText);
                }

                if (this.options.selectAllName) {
                    $('label', $li).prepend('<input type="checkbox" name="' + this.options.selectAllName + '" />');
                }
                else {
                    $('label', $li).prepend('<input type="checkbox" />');
                }

                var $checkbox = $('input', $li);
                $checkbox.val(this.options.selectAllValue);

                $li.addClass("multiselect-item multiselect-all");
                $checkbox.parent().parent()
                    .addClass('multiselect-all');

                this.$ul.prepend($li);

                $checkbox.prop('checked', false);
            }
        },

        /**
         * Builds the filter.
         */
        buildFilter: function() {

            // Build filter if filtering OR case insensitive filtering is enabled and the number of options exceeds (or equals) enableFilterLength.
            if (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering) {
                var enableFilterLength = Math.max(this.options.enableFiltering, this.options.enableCaseInsensitiveFiltering);

                if (this.$select.find('option').length >= enableFilterLength) {

                    this.$filter = $(this.options.templates.filter);
                    $('input', this.$filter).attr('placeholder', this.options.filterPlaceholder);

                    // Adds optional filter clear button
                    if(this.options.includeFilterClearBtn) {
                        var clearBtn = $(this.options.templates.filterClearBtn);
                        clearBtn.on('click', $.proxy(function(event){
                            clearTimeout(this.searchTimeout);

                            this.query = '';
                            this.$filter.find('.multiselect-search').val('');
                            $('li', this.$ul).show().removeClass('multiselect-filter-hidden');

                            this.updateSelectAll();

                            if (this.options.enableClickableOptGroups && this.options.multiple) {
                                this.updateOptGroups();
                            }

                        }, this));
                        this.$filter.find('.input-group').append(clearBtn);
                    }

                    this.$ul.prepend(this.$filter);

                    this.$filter.val(this.query).on('click', function(event) {
                        event.stopPropagation();
                    }).on('input keydown', $.proxy(function(event) {
                        // Cancel enter key default behaviour
                        if (event.which === 13) {
                            event.preventDefault();
                        }

                        // This is useful to catch "keydown" events after the browser has updated the control.
                        clearTimeout(this.searchTimeout);

                        this.searchTimeout = this.asyncFunction($.proxy(function() {

                            if (this.query !== event.target.value) {
                                this.query = event.target.value;

                                var currentGroup, currentGroupVisible;
                                $.each($('li', this.$ul), $.proxy(function(index, element) {
                                    var value = $('input', element).length > 0 ? $('input', element).val() : "";
                                    var text = $('label', element).text();

                                    var filterCandidate = '';
                                    if ((this.options.filterBehavior === 'text')) {
                                        filterCandidate = text;
                                    }
                                    else if ((this.options.filterBehavior === 'value')) {
                                        filterCandidate = value;
                                    }
                                    else if (this.options.filterBehavior === 'both') {
                                        filterCandidate = text + '\n' + value;
                                    }

                                    if (value !== this.options.selectAllValue && text) {

                                        // By default lets assume that element is not
                                        // interesting for this search.
                                        var showElement = false;

                                        if (this.options.enableCaseInsensitiveFiltering) {
                                            filterCandidate = filterCandidate.toLowerCase();
                                            this.query = this.query.toLowerCase();
                                        }

                                        if (this.options.enableFullValueFiltering && this.options.filterBehavior !== 'both') {
                                            var valueToMatch = filterCandidate.trim().substring(0, this.query.length);
                                            if (this.query.indexOf(valueToMatch) > -1) {
                                                showElement = true;
                                            }
                                        }
                                        else if (filterCandidate.indexOf(this.query) > -1) {
                                            showElement = true;
                                        }

                                        // Toggle current element (group or group item) according to showElement boolean.
                                        if(!showElement){
                                            $(element).css('display', 'none');
                                            $(element).addClass('multiselect-filter-hidden');
                                        }
                                        if(showElement){
                                            $(element).css('display', 'block');
                                            $(element).removeClass('multiselect-filter-hidden');
                                        }

                                        // Differentiate groups and group items.
                                        if ($(element).hasClass('multiselect-group')) {
                                            // Remember group status.
                                            currentGroup = element;
                                            currentGroupVisible = showElement;
                                        }
                                        else {
                                            // Show group name when at least one of its items is visible.
                                            if (showElement) {
                                                $(currentGroup).show()
                                                    .removeClass('multiselect-filter-hidden');
                                            }

                                            // Show all group items when group name satisfies filter.
                                            if (!showElement && currentGroupVisible) {
                                                $(element).show()
                                                    .removeClass('multiselect-filter-hidden');
                                            }
                                        }
                                    }
                                }, this));
                            }

                            this.updateSelectAll();

                            if (this.options.enableClickableOptGroups && this.options.multiple) {
                                this.updateOptGroups();
                            }

                            this.options.onFiltering(event.target);

                        }, this), 300, this);
                    }, this));
                }
            }
        },

        /**
         * Unbinds the whole plugin.
         */
        destroy: function() {
            this.$container.remove();
            this.$select.show();

            // reset original state
            this.$select.prop('disabled', this.options.wasDisabled);

            this.$select.data('multiselect', null);
        },

        /**
         * Refreshs the multiselect based on the selected options of the select.
         */
        refresh: function () {
            var inputs = {};
            $('li input', this.$ul).each(function() {
                inputs[$(this).val()] = $(this);
            });

            $('option', this.$select).each($.proxy(function (index, element) {
                var $elem = $(element);
                var $input = inputs[$(element).val()];

                if ($elem.is(':selected')) {
                    $input.prop('checked', true);

                    if (this.options.selectedClass) {
                        $input.closest('li')
                            .addClass(this.options.selectedClass);
                    }
                }
                else {
                    $input.prop('checked', false);

                    if (this.options.selectedClass) {
                        $input.closest('li')
                            .removeClass(this.options.selectedClass);
                    }
                }

                if ($elem.is(":disabled")) {
                    $input.attr('disabled', 'disabled')
                        .prop('disabled', true)
                        .closest('li')
                        .addClass('disabled');
                }
                else {
                    $input.prop('disabled', false)
                        .closest('li')
                        .removeClass('disabled');
                }
            }, this));

            this.updateButtonText();
            this.updateSelectAll();

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }
        },

        /**
         * Select all options of the given values.
         *
         * If triggerOnChange is set to true, the on change event is triggered if
         * and only if one value is passed.
         *
         * @param {Array} selectValues
         * @param {Boolean} triggerOnChange
         */
        select: function(selectValues, triggerOnChange) {
            if(!$.isArray(selectValues)) {
                selectValues = [selectValues];
            }

            for (var i = 0; i < selectValues.length; i++) {
                var value = selectValues[i];

                if (value === null || value === undefined) {
                    continue;
                }

                var $option = this.getOptionByValue(value);
                var $checkbox = this.getInputByValue(value);

                if($option === undefined || $checkbox === undefined) {
                    continue;
                }

                if (!this.options.multiple) {
                    this.deselectAll(false);
                }

                if (this.options.selectedClass) {
                    $checkbox.closest('li')
                        .addClass(this.options.selectedClass);
                }

                $checkbox.prop('checked', true);
                $option.prop('selected', true);

                if (triggerOnChange) {
                    this.options.onChange($option, true);
                }
            }

            this.updateButtonText();
            this.updateSelectAll();

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }
        },

        /**
         * Clears all selected items.
         */
        clearSelection: function () {
            this.deselectAll(false);
            this.updateButtonText();
            this.updateSelectAll();

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }
        },

        /**
         * Deselects all options of the given values.
         *
         * If triggerOnChange is set to true, the on change event is triggered, if
         * and only if one value is passed.
         *
         * @param {Array} deselectValues
         * @param {Boolean} triggerOnChange
         */
        deselect: function(deselectValues, triggerOnChange) {
            if(!$.isArray(deselectValues)) {
                deselectValues = [deselectValues];
            }

            for (var i = 0; i < deselectValues.length; i++) {
                var value = deselectValues[i];

                if (value === null || value === undefined) {
                    continue;
                }

                var $option = this.getOptionByValue(value);
                var $checkbox = this.getInputByValue(value);

                if($option === undefined || $checkbox === undefined) {
                    continue;
                }

                if (this.options.selectedClass) {
                    $checkbox.closest('li')
                        .removeClass(this.options.selectedClass);
                }

                $checkbox.prop('checked', false);
                $option.prop('selected', false);

                if (triggerOnChange) {
                    this.options.onChange($option, false);
                }
            }

            this.updateButtonText();
            this.updateSelectAll();

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }
        },

        /**
         * Selects all enabled & visible options.
         *
         * If justVisible is true or not specified, only visible options are selected.
         *
         * @param {Boolean} justVisible
         * @param {Boolean} triggerOnSelectAll
         */
        selectAll: function (justVisible, triggerOnSelectAll) {

            var justVisible = typeof justVisible === 'undefined' ? true : justVisible;
            var allLis = $("li:not(.divider):not(.disabled):not(.multiselect-group)", this.$ul);
            var visibleLis = $("li:not(.divider):not(.disabled):not(.multiselect-group):not(.multiselect-filter-hidden):not(.multiselect-collapisble-hidden)", this.$ul).filter(':visible');

            if(justVisible) {
                $('input:enabled' , visibleLis).prop('checked', true);
                visibleLis.addClass(this.options.selectedClass);

                $('input:enabled' , visibleLis).each($.proxy(function(index, element) {
                    var value = $(element).val();
                    var option = this.getOptionByValue(value);
                    $(option).prop('selected', true);
                }, this));
            }
            else {
                $('input:enabled' , allLis).prop('checked', true);
                allLis.addClass(this.options.selectedClass);

                $('input:enabled' , allLis).each($.proxy(function(index, element) {
                    var value = $(element).val();
                    var option = this.getOptionByValue(value);
                    $(option).prop('selected', true);
                }, this));
            }

            $('li input[value="' + this.options.selectAllValue + '"]', this.$ul).prop('checked', true);

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }

            if (triggerOnSelectAll) {
                this.options.onSelectAll();
            }
        },

        /**
         * Deselects all options.
         *
         * If justVisible is true or not specified, only visible options are deselected.
         *
         * @param {Boolean} justVisible
         */
        deselectAll: function (justVisible, triggerOnDeselectAll) {

            var justVisible = typeof justVisible === 'undefined' ? true : justVisible;
            var allLis = $("li:not(.divider):not(.disabled):not(.multiselect-group)", this.$ul);
            var visibleLis = $("li:not(.divider):not(.disabled):not(.multiselect-group):not(.multiselect-filter-hidden):not(.multiselect-collapisble-hidden)", this.$ul).filter(':visible');

            if(justVisible) {
                $('input[type="checkbox"]:enabled' , visibleLis).prop('checked', false);
                visibleLis.removeClass(this.options.selectedClass);

                $('input[type="checkbox"]:enabled' , visibleLis).each($.proxy(function(index, element) {
                    var value = $(element).val();
                    var option = this.getOptionByValue(value);
                    $(option).prop('selected', false);
                }, this));
            }
            else {
                $('input[type="checkbox"]:enabled' , allLis).prop('checked', false);
                allLis.removeClass(this.options.selectedClass);

                $('input[type="checkbox"]:enabled' , allLis).each($.proxy(function(index, element) {
                    var value = $(element).val();
                    var option = this.getOptionByValue(value);
                    $(option).prop('selected', false);
                }, this));
            }

            $('li input[value="' + this.options.selectAllValue + '"]', this.$ul).prop('checked', false);

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }

            if (triggerOnDeselectAll) {
                this.options.onDeselectAll();
            }
        },

        /**
         * Rebuild the plugin.
         *
         * Rebuilds the dropdown, the filter and the select all option.
         */
        rebuild: function() {
            this.$ul.html('');

            // Important to distinguish between radios and checkboxes.
            this.options.multiple = this.$select.attr('multiple') === "multiple";

            this.buildSelectAll();
            this.buildDropdownOptions();
            this.buildFilter();

            this.updateButtonText();
            this.updateSelectAll(true);

            if (this.options.enableClickableOptGroups && this.options.multiple) {
                this.updateOptGroups();
            }

            if (this.options.disableIfEmpty && $('option', this.$select).length <= 0) {
                this.disable();
            }
            else {
                this.enable();
            }

            if (this.options.dropRight) {
                this.$ul.addClass('pull-right');
            }
        },

        /**
         * The provided data will be used to build the dropdown.
         */
        dataprovider: function(dataprovider) {

            var groupCounter = 0;
            var $select = this.$select.empty();

            $.each(dataprovider, function (index, option) {
                var $tag;

                if ($.isArray(option.children)) { // create optiongroup tag
                    groupCounter++;

                    $tag = $('<optgroup/>').attr({
                        label: option.label || 'Group ' + groupCounter,
                        disabled: !!option.disabled,
                        value: option.value
                    });

                    forEach(option.children, function(subOption) { // add children option tags
                        var attributes = {
                            value: subOption.value,
                            label: subOption.label || subOption.value,
                            title: subOption.title,
                            selected: !!subOption.selected,
                            disabled: !!subOption.disabled
                        };

                        //Loop through attributes object and add key-value for each attribute
                        for (var key in subOption.attributes) {
                            attributes['data-' + key] = subOption.attributes[key];
                        }
                        //Append original attributes + new data attributes to option
                        $tag.append($('<option/>').attr(attributes));
                    });
                }
                else {

                    var attributes = {
                        'value': option.value,
                        'label': option.label || option.value,
                        'title': option.title,
                        'class': option['class'],
                        'selected': !!option['selected'],
                        'disabled': !!option['disabled']
                    };
                    //Loop through attributes object and add key-value for each attribute
                    for (var key in option.attributes) {
                        attributes['data-' + key] = option.attributes[key];
                    }
                    //Append original attributes + new data attributes to option
                    $tag = $('<option/>').attr(attributes);

                    $tag.text(option.label || option.value);
                }

                $select.append($tag);
            });

            this.rebuild();
        },

        /**
         * Enable the multiselect.
         */
        enable: function() {
            this.$select.prop('disabled', false);
            this.$button.prop('disabled', false)
                .removeClass('disabled');
        },

        /**
         * Disable the multiselect.
         */
        disable: function() {
            this.$select.prop('disabled', true);
            this.$button.prop('disabled', true)
                .addClass('disabled');
        },

        /**
         * Set the options.
         *
         * @param {Array} options
         */
        setOptions: function(options) {
            this.options = this.mergeOptions(options);
        },

        /**
         * Merges the given options with the default options.
         *
         * @param {Array} options
         * @returns {Array}
         */
        mergeOptions: function(options) {
            return $.extend(true, {}, this.defaults, this.options, options);
        },

        /**
         * Checks whether a select all checkbox is present.
         *
         * @returns {Boolean}
         */
        hasSelectAll: function() {
            return $('li.multiselect-all', this.$ul).length > 0;
        },

        /**
         * Update opt groups.
         */
        updateOptGroups: function() {
            var $groups = $('li.multiselect-group', this.$ul)
            var selectedClass = this.options.selectedClass;

            $groups.each(function() {
                var $options = $(this).nextUntil('li.multiselect-group')
                    .not('.multiselect-filter-hidden')
                    .not('.disabled');

                var checked = true;
                $options.each(function() {
                    var $input = $('input', this);

                    if (!$input.prop('checked')) {
                        checked = false;
                    }
                });

                if (selectedClass) {
                    if (checked) {
                        $(this).addClass(selectedClass);
                    }
                    else {
                        $(this).removeClass(selectedClass);
                    }
                }

                $('input', this).prop('checked', checked);
            });
        },

        /**
         * Updates the select all checkbox based on the currently displayed and selected checkboxes.
         */
        updateSelectAll: function(notTriggerOnSelectAll) {
            if (this.hasSelectAll()) {
                var allBoxes = $("li:not(.multiselect-item):not(.multiselect-filter-hidden):not(.multiselect-group):not(.disabled) input:enabled", this.$ul);
                var allBoxesLength = allBoxes.length;
                var checkedBoxesLength = allBoxes.filter(":checked").length;
                var selectAllLi  = $("li.multiselect-all", this.$ul);
                var selectAllInput = selectAllLi.find("input");

                if (checkedBoxesLength > 0 && checkedBoxesLength === allBoxesLength) {
                    selectAllInput.prop("checked", true);
                    selectAllLi.addClass(this.options.selectedClass);
                }
                else {
                    selectAllInput.prop("checked", false);
                    selectAllLi.removeClass(this.options.selectedClass);
                }
            }
        },

        /**
         * Update the button text and its title based on the currently selected options.
         */
        updateButtonText: function() {
            var options = this.getSelected();

            // First update the displayed button text.
            if (this.options.enableHTML) {
                $('.multiselect .multiselect-selected-text', this.$container).html(this.options.buttonText(options, this.$select));
            }
            else {
                $('.multiselect .multiselect-selected-text', this.$container).text(this.options.buttonText(options, this.$select));
            }

            // Now update the title attribute of the button.
            $('.multiselect', this.$container).attr('title', this.options.buttonTitle(options, this.$select));
        },

        /**
         * Get all selected options.
         *
         * @returns {jQUery}
         */
        getSelected: function() {
            return $('option', this.$select).filter(":selected");
        },

        /**
         * Gets a select option by its value.
         *
         * @param {String} value
         * @returns {jQuery}
         */
        getOptionByValue: function (value) {

            var options = $('option', this.$select);
            var valueToCompare = value.toString();

            for (var i = 0; i < options.length; i = i + 1) {
                var option = options[i];
                if (option.value === valueToCompare) {
                    return $(option);
                }
            }
        },

        /**
         * Get the input (radio/checkbox) by its value.
         *
         * @param {String} value
         * @returns {jQuery}
         */
        getInputByValue: function (value) {

            var checkboxes = $('li input:not(.multiselect-search)', this.$ul);
            var valueToCompare = value.toString();

            for (var i = 0; i < checkboxes.length; i = i + 1) {
                var checkbox = checkboxes[i];
                if (checkbox.value === valueToCompare) {
                    return $(checkbox);
                }
            }
        },

        /**
         * Used for knockout integration.
         */
        updateOriginalOptions: function() {
            this.originalOptions = this.$select.clone()[0].options;
        },

        asyncFunction: function(callback, timeout, self) {
            var args = Array.prototype.slice.call(arguments, 3);
            return setTimeout(function() {
                callback.apply(self || window, args);
            }, timeout);
        },

        setAllSelectedText: function(allSelectedText) {
            this.options.allSelectedText = allSelectedText;
            this.updateButtonText();
        }
    };

    $.fn.multiselect = function(option, parameter, extraOptions) {
        return this.each(function() {
            var data = $(this).data('multiselect');
            var options = typeof option === 'object' && option;

            // Initialize the multiselect.
            if (!data) {
                data = new Multiselect(this, options);
                $(this).data('multiselect', data);
            }

            // Call multiselect method.
            if (typeof option === 'string') {
                data[option](parameter, extraOptions);

                if (option === 'destroy') {
                    $(this).data('multiselect', false);
                }
            }
        });
    };

    $.fn.multiselect.Constructor = Multiselect;

    $(function() {
        $("select[data-role=multiselect]").multiselect();
    });

});
/*
 This file is part of SMAP.

 SMAP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 uSMAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

 */



define('app/actioncommon',[
        'jquery',
        'common',
        'modernizr',
        'localise',
        'globals',
        'app/mapOL3',
        'multiselect'],
    function ($, common, modernizr, lang, globals, map) {

        return {
            showEditRecordForm: showEditRecordForm,
            showBulkEditForm: showBulkEditForm,
            addCellMarkup: addCellMarkup,
            addCellMap: addCellMap,
            initialiseDynamicMaps: initialiseDynamicMaps
        };

        /*
	     * Refresh any select lists that are dependent on entered values
         */
        function refreshSelectLists(schema, record, changedItemIndex, prefix) {

            var  columns = schema.columns;
            var changedItem = columns[changedItemIndex];
            for (i = 0; i < columns.length; i++) {
                var column = columns[i];
                if (column.mgmt) {
                    if (column.type === "select1" || column.type === "select" || column.type === "select_one") {
                        var value = record[column.column_name];
                        getChoiceList(schema, column, i, value, record, changedItem.column_name, prefix);
                    }
                }

            }
        }

        /*
         * Add HTML to show a form to edit a record
         */
        function showEditRecordForm(record, schema, $editForm, $surveyForm, editable, includeMaps) {
            var
                h = [],
                idx = -1,
                m = [],
                cnt = -1,
                i,
                configItem,
                first = true,
                columns = schema.columns,
                prefix = 'er';

            globals.gRecordMaps = [];     // Initialise the list of maps we are going to show
            gTasks.gPriKey = record["prikey"];

            // Clear the update array
            gTasks.gUpdate = [];
            $('.saverecord').prop("disabled", true);

            for (i = 0; i < columns.length; i++) {
                configItem = columns[i];

                if (configItem.mgmt) {

                    h[++idx] = getEditMarkup(configItem, i, first, record, schema, editable, true, prefix);

                } //else {
                // Always add the read only original
                m[++cnt] = getEditMarkup(configItem, i, first, record, schema, false, true, prefix);
                //}
                if (!configItem.readonly) {
                    first = false;
                }
            }

            if($editForm) {
                $editForm.html(h.join(''));
            }
            if($surveyForm) {
                $surveyForm.html(m.join(''));
            }

            // Set up date fields
            $editForm.find('.date').datetimepicker({
                locale: gUserLocale || 'en',
                useCurrent: false,
                showTodayButton: true
            });

            // Set up multi selects
            $('.select', $editForm).multiselect({
                onChange: function(option, checked, select) {

                    var $sel = option.closest('select');
                    var itemIndex = $sel.data("item");
                    var val = '';
                    if ($sel.val()) {
                        val = $sel.val().join(' ');
                    }
                    var config = {
                        itemIndex: itemIndex,
                        value: val
                    };
                    dataChanged(config);
                }
            });

            // Set up the map fields
            if(includeMaps) {
                initialiseDynamicMaps(globals.gRecordMaps);
            }

            // Respond to changes in the data by creating an update object
            $editForm.find('.form-control, select').bind("click propertychange paste change keyup input", function () {
                if(!$(this).hasClass('select')) { // Ignore select multiples
                    var $this = $(this);
                    var config = {
                        itemIndex: $this.data("item"),
                        value: $this.val()
                    };
                    dataChanged(config);
                    refreshSelectLists(schema, record, $this.data("item"), prefix);
                }
            });
            $editForm.find('.date').on("dp.change", function () {
                var $this = $(this).find('input');
                var config = {
                    itemIndex: $this.data("item"),
                    value: $this.val()
                };
                dataChanged(config);
            });
            $('#editRecordForm').on("smap::geopoint", function (event, config) {
                console.log("New geopoint");
                dataChanged(config);
            });

            // Set focus to first editable data item
            $editForm.find('[autofocus]').focus();
        }

        /*
         * Add HTML to allow bulk ediitng
         */
        function showBulkEditForm(record, schema, $editForm) {
            var
                h = [],
                idx = -1,
                m = [],
                cnt = -1,
                i,
                configItem,
                first = true,
                columns = schema.columns,
                prefix = 'be';

            for (i = 0; i < columns.length; i++) {
                configItem = columns[i];

                if (configItem.mgmt) {
                    h[++idx] = '<div class="row bulkquestion">';
                    h[++idx] = '<div class="col-sm-8">';

                    var cloneItem = JSON.parse(JSON.stringify(configItem));
                    if(configItem.type === 'select') {
                        cloneItem.type = 'select1';     // With select multiples the bulk change is to set or clear one value
                    }
                    h[++idx] = getEditMarkup(cloneItem, i, first, record, schema, true, false, prefix);
                    h[++idx] = '</div>';    // Question column
                    h[++idx] = '<div class="col-sm-4">';    // clear
                    if(configItem.type === 'select') {
                        h[++idx] = '<div class="switch">';
                        h[++idx] = '<input type="checkbox" class="selectClear">';
                        h[++idx] = '</div>';
                    }
                    h[++idx] = '</div>';    // clear
                    h[++idx] = '</div>';    // row
                }

                if (!configItem.readonly) {
                    first = false;
                }
            }

            if($editForm) {
                $editForm.html(h.join(''));
            }

            // Set up date fields
            $editForm.find('.date').datetimepicker({
                locale: gUserLocale || 'en',
                useCurrent: false,
                showTodayButton: true
            });


            // Respond to changes in the data by creating an update object
            $editForm.find('.form-control, select').bind("click propertychange paste change keyup input", function () {
                var $this = $(this);
                var config = {
                    itemIndex: $this.data("item"),
                    value: $this.val(),
                    clear: $this.closest(".bulkquestion").find(".selectClear").is(':checked')
                };
                bulkDataChanged(config);
                refreshSelectLists(schema, record, $this.data("item"), prefix);
            });

            // Respond to changes in a clear checkbox
            $editForm.find('.selectClear').bind("change", function () {
                var $this = $(this);
                var $q = $this.closest(".bulkquestion").find(".form-control")
                var config = {
                    itemIndex: $q.data("item"),
                    value: $q.val(),
                    clear: $this.is(':checked')
                };

                bulkDataChanged(config);
                refreshSelectLists(schema, record, $this.data("item"), prefix);
            });

            // Set focus to first editable data item
            $editForm.find('[autofocus]').focus();
        }

        /*
         * Get the markup to edit the record
         */
        function getEditMarkup(configItem, itemIndex, first, record, schema, editable, setvalue, prefix) {

            var h = [],
                idx = -1,
                value;

            if(record && setvalue) {
                var name = configItem.column_name;
                value = record[name];
            }

            // Add form group and label
            h[++idx] = '<div class="form-group row"><label class="col-md-4 control-label">';
            h[++idx] = htmlEncode(configItem.displayName);
            h[++idx] = '</label>';

            // Add Data
            h[++idx] = ' <div class="col-md-8">';

            if(configItem.type === 'geopoint' || configItem.type === 'geoshape' || configItem.type === 'geotrace') {
                h[++idx] = addCellMap(
                    configItem.readonly || !editable,
                    'record_maps_',
                    globals.gRecordMaps,
                    configItem,
                    value,
                    undefined,
                    itemIndex);
            } else if (configItem.readonly || !editable) {		// Read only text
                h[++idx] = addCellMarkup(value);
            } else {
                h[++idx] = addEditableColumnMarkup(configItem, value, itemIndex, first, schema, record, prefix);
                first = false;
            }
            h[++idx] = '</div>';

            // Close form group
            h[++idx] = '</div>';

            return h.join('');
        }

        /*
         * Add the markup for an editable column
         */
        function addEditableColumnMarkup(column, value, itemIndex, first, schema, record, prefix) {
            var h = [],
                idx = -1,
                i,
                sourceColumn;

            // Check for a source column
            if(column.parameters && column.parameters.source) {
                var sourceColumn = getColumn(column.parameters.source, schema.columns);
            }

            if(sourceColumn) {
                h[++idx] = addSourceQuestion(sourceColumn, record, column.parameters.rows);
            }

            if (column.type === "decimal" || column.type === "integer"  || column.type === "int") {
                h[++idx] = ' <input type="number"';
                if(column.type === "integer"  || column.type === "int") {
                    h[++idx] = ' step="1"';
                }
                h[++idx] = ' class="form-control editable" value="';
                h[++idx] = value;
                h[++idx] = '" data-item="';
                h[++idx] = itemIndex;
                if (first) {
                    h[++idx] = '" autofocus/>';
                } else {
                    h[++idx] = '"/>';
                }
            } else if (column.type === "date") {
                h[++idx] = '<div class="input-group date" data-container="body">';
                h[++idx] = '<input type="text" class="form-control editable" data-date-format="YYYY-MM-DD" value="';
                h[++idx] = value;
                h[++idx] = '" data-item="';
                h[++idx] = itemIndex;
                if (first) {
                    h[++idx] = '" autofocus/>';
                } else {
                    h[++idx] = '"/>';
                }
                h[++idx] = '<span class="input-group-addon"><span class="glyphicon glyphicon-calendar"></span></span>';
                h[++idx] = '</div>';
            } else if (column.type === "select1" || column.type === "select" || column.type === "select_one") {
                h[++idx] = ' <select id="select_';
                h[++idx] = prefix + itemIndex;
                h[++idx] = '" class="form-control editable ';
                if (column.type === "select") {
                    h[++idx] = ' select';
                }
                h[++idx] = '" data-item="';
                h[++idx] = itemIndex;
                h[++idx] = '"';
                if (column.type === "select") {
                    h[++idx] = ' multiple="multiple"'
                }
                h[++idx] = '>';

                // Add the empty choice
                if (column.type !== "select") {
                    h[++idx] = '<option value=""></option>';
                }

                var choices = getChoiceList(schema, column, itemIndex, value, record, undefined, prefix);
                if (choices) {
                    h[++idx] = getChoicesHTML(column, choices, value, true);
                }
                h[++idx] = '</select>';

            } else {        // Text + Default

                var v = addAnchors(value)[0];
                
                if(v && v.indexOf('<') == 0) {
                    h[++idx] = v;
                } else {
                    if(column.parameters && column.parameters.rows) {
                        h[++idx] = ' <textarea rows=';
                        h[++idx] = column.parameters.rows;
                        h[++idx] = ' class="form-control editable" ';
                        h[++idx] = '" data-item="';
                        h[++idx] = itemIndex;
                        if (first) {
                            h[++idx] = '" autofocus>';
                        } else {
                            h[++idx] = '">';
                        }
                        h[++idx] = value;
                        h[++idx] = '</textarea>';
                    } else {
                        h[++idx] = ' <input type="text"';
                        h[++idx] = '" class="form-control editable" value="';
                        h[++idx] = value;
                        h[++idx] = '" data-item="';
                        h[++idx] = itemIndex;
                        if (first) {
                            h[++idx] = '" autofocus/>';
                        } else {
                            h[++idx] = '"/>';
                        }
                    }
                }

            }

            return h.join('');
        }

        /*
         * Get the choicelist for a select question
         */
        function getChoiceList(schema, col, itemIndex, value, record, changed_column, prefix) {

            // Get the choice list
            var listId = col.l_id;
            var i;
            var choices;

            if (schema && schema.choiceLists && schema.choiceLists.length) {
                for (i = 0; i < schema.choiceLists.length; i++) {
                    if (schema.choiceLists[i].l_id === listId) {
                        choices = schema.choiceLists[i].choices;
                        break;
                    }
                }
            }
            if(choices && choices.length > 0) {

                if (col.appearance && (col.appearance.indexOf('search(') >= 0 || col.appearance.indexOf('lookup_choices(') >= 0)) {
                    // External choices
                    var params = getAppearanceParams(col.appearance);
                    var changeParam1 = false;
                    var changeParam2 = false;
                    var changeExpr = false;
                    var dependentColumn;
                    if (params.length > 0) {
                        // todo consider fixed values
                        var sIdent = globals.gGroupSurveys[globals.gCurrentSurvey];
                        var value_column = choices[0].k;
                        var label_column = choices[0].v;
                        var url = '/lookup/choices/' + sIdent + '/' + params.filename + '/' + value_column + '/' + label_column;
                        if(typeof params.filter !== "undefined") {
                            if(params.filter === 'eval') {
                                if (typeof params.expression !== "undefined") {
                                    // Replace ${question_name} elements with values
                                    const regex = /\$\{.+?\}/g;
                                    const found = params.expression.match(regex);
                                    if(found && found.length > 0) {
                                        for(i = 0; i < found.length; i++) {
                                            var token = found[i];
                                            dependentColumn = token.substring(2, token.length - 1);
                                            var depValue = record[dependentColumn];
                                            depValue = getUpdate(dependentColumn, depValue);  // Replace the value if there has been an update
                                            var type = getQuestionType(schema, dependentColumn);
                                            if(type !== 'int') {
                                                depValue = '\'' + depValue + '\'';
                                            }
                                            params.expression = params.expression.replace(token, depValue);


                                            if (changed_column && dependentColumn === changed_column) {        // Set a flag if this refresh in response to a changed value and this param is wha changed
                                                changeExpr = true;
                                            }
                                        }
                                    }

                                    var encodedExpression = encodeURIComponent(params.expression);
                                    // manually encode some characters that are missed by encodeUriComponent and ned to be encoded
                                    encodedExpression = encodedExpression.replace(/\(/g, "%28");
                                    encodedExpression = encodedExpression.replace(/\)/g, "%29");
                                    url += '?expression=' + encodedExpression;

                                }
                            } else {
                                if (typeof params.filter_column !== "undefined" && typeof params.filter_value !== "undefined") {
                                    // Add first filter
                                    url += '?search_type=' + params.filter;
                                    url += '&q_column=' + params.filter_column;
                                    if (params.filter_value.indexOf('${') == 0) {
                                        dependentColumn = params.filter_value.substring(2, params.filter_value.length - 1);
                                        params.filter_value = record[dependentColumn];

                                        params.filter_value = getUpdate(params.filter_column, params.filter_value);  // Replace the value if there has been an update
                                        if (changed_column && dependentColumn === changed_column) {        // Set a flag if this refresh in response to a changed value and this param is wha changed
                                            changeParam1 = true;
                                        }
                                    }

                                    url += '&q_value=' + params.filter_value;
                                    if (typeof params.second_filter_column !== "undefined"
                                        && typeof params.second_filter_value !== "undefined") {
                                        url += '&f_column=' + params.second_filter_column;
                                        if (params.second_filter_value.indexOf('${') == 0) {
                                            dependentColumn = params.second_filter_value.substring(2, params.second_filter_value.length - 1);
                                            params.second_filter_value = record[dependentColumn];

                                            params.second_filter_value = getUpdate(params.second_filter_column, params.second_filter_value);    // Replace the value if there has been an update
                                            if (changed_column && dependentColumn === changed_column) {        // Set a flag if this refresh in response to a changed value and this param is wha changed
                                                changeParam2 = true;
                                            }
                                        }
                                        url += '&f_value=' + params.second_filter_value;
                                    }
                                }
                            }
                        }

                        if(!changed_column || changeParam1 || changeParam2 || changeExpr) {
                            $.ajax({   // Get the existing report details to edit
                                url: url,
                                cache: false,
                                success: function (data, status) {
                                    var el = '#select_' + prefix + itemIndex;
                                    var selValue = value;
                                    var html = getChoicesHTML(col, data, selValue, false);
                                    $(el).empty().append(html);

                                    // Set up multi selects
                                    if (col.type === 'select') {
                                        $(el).multiselect('rebuild');
                                    }

                                }, error: function (data, status) {
                                    alert("Error: " + data.responseText);
                                }
                            });
                        }
                    } else {
                        alert("invalid search for: " + col.question_name);
                    }
                } else {
                    // Local choices
                    return choices;
                }
            }
        }

        /*
         * Get an updated value
         */
        function getUpdate(col, def) {
            if(gTasks.gUpdate && gTasks.gUpdate.length > 0) {
                var i;
                for(i = 0; i < gTasks.gUpdate.length; i++) {
                    if(gTasks.gUpdate[i].name === col) {
                        return gTasks.gUpdate[i].value;
                    }
                }
            }
            return def;
        }

        /*
         * Add the markup for a map
         */
        function addCellMap(readOnly, idbase, maps, column, currentValue, oldValue, itemIndex) {
            var h = [],
                idx = -1;

            // Make sure values are JSON objects
            if(typeof currentValue === "string") {
                try {
                    currentValue = JSON.parse(currentValue);
                } catch(err) {

                }
            }
            if(typeof oldValue === "string") {
                try {
                    oldValue = JSON.parse(oldValue);
                } catch (err) {

                }
            }

            var config = {
                readOnly: readOnly,
                id: idbase + maps.length,
                currentValue: currentValue,
                oldValue: oldValue
            };

            h[++idx] = '<div id="';
            h[++idx] = config.id;
            h[++idx] = '" data-item="';
            h[++idx] = itemIndex;
            h[++idx] = '" class="small_map">';
            h[++idx] = '<div id="tooltip_';
            h[++idx] = config.id;
            h[++idx] = '"></div>';
            h[++idx] = '</div>';

            maps.push(config);

            return h.join('');
        }

        function getColumn(qname, columns) {
            var i,
                col;
            for(i = 0; i < columns.length; i++) {
                // Hack.  For forms the human name is the question name that has not been modified to act as a database column
                if((columns[i].mgmt && qname === columns[i].name) || (!columns[i].mgmt && qname === columns[i].displayName)) {
                    col = columns[i];
                    break;
                }
            }
            return col;

        }


        function addSourceQuestion(column, record, ref_rows) {
            var name = column.mgmt ? column.name : column.column_name;        // Name hack
            var v = addAnchors(record[name])[0];
            var h = [];
            var idx = -1;

            if(v.indexOf('<') == 0) {
                h[++idx] = v;
            } else {
                if(!ref_rows || ref_rows <= 1) {
                    ref_rows = 1;
                }
                h[++idx] = ' <textarea readonly style="overflow-y:scroll;" rows=';
                h[++idx] = ref_rows;
                h[++idx] = ' class="form-control">';
                h[++idx] = v;
                h[++idx] = '</textarea>';
            }

            return h.join('');
        }

        /*
         * User has changed a managed value
         */
        function dataChanged(config) {

            var
                itemIndex = config.itemIndex,
                value = config.value,
                record = gTasks.gSelectedRecord,
                columns = gTasks.cache.currentData.schema.columns,
                currentValue,
                column_name = columns[itemIndex].column_name,
                displayName = columns[itemIndex].displayName,
                i,
                foundExistingUpdate;

            currentValue = record[column_name];
            if (typeof currentValue === "undefined") {
                currentValue = "";
            }
            if(typeof currentValue === "object") {
                currentValue = JSON.stringify(currentValue);
            }
            if(typeof value === "object") {
                value = JSON.stringify(value);
            }

            if (currentValue !== value) {
                // Add new value to array, or update existing
                foundExistingUpdate = false;
                for (i = 0; i < gTasks.gUpdate.length; i++) {
                    if (gTasks.gUpdate[i].name === column_name) {
                        foundExistingUpdate = true;
                        gTasks.gUpdate[i].value = value;
                        break;
                    }
                }

                if (!foundExistingUpdate) {
                    // Add new value
                    gTasks.gUpdate.push({
                        name: column_name,                 // Update name is the column name
                        displayName: displayName,
                        value: value,
                        currentValue: currentValue,
                        itemIndex: itemIndex
                    });
                }

            } else {
                // Delete value from array of updates
                for (i = 0; i < gTasks.gUpdate.length; i++) {
                    if (gTasks.gUpdate[i].name === column_name) {
                        gTasks.gUpdate.splice(i, 1);
                        break;
                    }
                }
            }

            if (gTasks.gUpdate.length > 0) {
                $('.saverecord').prop("disabled", false);
            } else {
                $('.saverecord').prop("disabled", true);
            }

            $('.re_alert').hide();
        }

        /*
         * User has changed a bulk managed value
         */
        function bulkDataChanged(config) {

            var
                itemIndex = config.itemIndex,
                value = config.value,
                clear = config.clear,
                columns = gTasks.cache.currentData.schema.columns,
                column_name = columns[itemIndex].column_name,
                displayName = columns[itemIndex].displayName,
                i,
                foundExistingUpdate;

            if(typeof value === "object") {
                value = JSON.stringify(value);
            }

            // Add new value to array, or update existing
            foundExistingUpdate = false;
            for (i = 0; i < gTasks.gUpdate.length; i++) {
                if (gTasks.gUpdate[i].name === column_name) {
                    foundExistingUpdate = true;
                    gTasks.gUpdate[i].value = value;
                    gTasks.gUpdate[i].clear = clear;
                    break;
                }
            }

            if (!foundExistingUpdate) {
                // Add new value
                gTasks.gUpdate.push({
                    name: column_name,
                    displayName: displayName,
                    value: value,
                    clear: clear,
                    itemIndex: itemIndex
                });
            }


            if (gTasks.gUpdate.length > 0) {
                $('.saverecord').prop("disabled", false);
            } else {
                $('.saveRecord').prop("disabled", true);
            }

            $('.re_alert').hide();
        }

        /*
         * Add markup for a single cell
         */
        function addCellMarkup(input) {
            var v = addAnchors(input)[0],
                h = [],
                idx = -1;
            if(v && v.indexOf('<') == 0) {
                h[++idx] = v;
            } else {
                h[++idx] = ' <textarea readonly style="overflow-y:scroll;" rows=1';
                h[++idx] = ' class="form-control">';
                h[++idx] = v;
                h[++idx] = '</textarea>';
            }
            return h.join('');

        }

        /*
	     * Initialise maps
	     */
        function initialiseDynamicMaps(maps, mapId) {
            var i;

            for(i = 0; i < maps.length; i++) {
                if(!mapId || mapId === maps[i].id) {
                    map.initDynamicMap(maps[i]);
                }
            }

        }

        /*
         * Support both internal arrays and external
         * Internal
         *    value: k
         *    label: v
         * External
         *    value: value
         *    label: labelInnerText
         */
        function getChoicesHTML(column, choices, value, internal) {
            var i,
                idx = -1,
                h = [],
                vArray,
                v,
                l;

            if (column.type === "select") {
                vArray = value.split(' ');
            } else {
                // Add the empty option
                h[++idx] = '<option value=""></option>';
            }
            for (i = 0; i < choices.length; i++) {
                if(internal) {
                    v = choices[i].k;
                    l = choices[i].v;
                } else {
                    v = choices[i].value;
                    l = choices[i].labelInnerText;
                }
                h[++idx] = '<option';
                if (column.type === "select") {
                    if (vArray.indexOf(v) > -1) {
                        h[++idx] = ' selected="selected"';
                    }
                } else {
                    if (v === value) {
                        h[++idx] = ' selected="selected"';
                    }
                }
                h[++idx] = ' value="';
                h[++idx] = v;
                h[++idx] = '">';
                h[++idx] = l;
                h[++idx] = '</option>';
            }
            return h.join('');
        }
    });
/*! version : 4.17.47
 =========================================================
 bootstrap-datetimejs
 https://github.com/Eonasdan/bootstrap-datetimepicker
 Copyright (c) 2015 Jonathan Peterson
 =========================================================
 */
/*
 The MIT License (MIT)

 Copyright (c) 2015 Jonathan Peterson

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */
/*global define:false */
/*global exports:false */
/*global require:false */
/*global jQuery:false */
/*global moment:false */
(function (factory) {
	'use strict';
	if (typeof define === 'function' && define.amd) {
		// AMD is used - Register as an anonymous module.
		define('datetimepicker',['jquery', 'moment'], factory);
	} else if (typeof exports === 'object') {
		module.exports = factory(require('jquery'), require('moment'));
	} else {
		// Neither AMD nor CommonJS used. Use global variables.
		if (typeof jQuery === 'undefined') {
			throw 'bootstrap-datetimepicker requires jQuery to be loaded first';
		}
		if (typeof moment === 'undefined') {
			throw 'bootstrap-datetimepicker requires Moment.js to be loaded first';
		}
		factory(jQuery, moment);
	}
}(function ($, moment) {
	'use strict';
	if (!moment) {
		throw new Error('bootstrap-datetimepicker requires Moment.js to be loaded first');
	}

	var dateTimePicker = function (element, options) {
		var picker = {},
			date,
			viewDate,
			unset = true,
			input,
			component = false,
			widget = false,
			use24Hours,
			minViewModeNumber = 0,
			actualFormat,
			parseFormats,
			currentViewMode,
			datePickerModes = [
				{
					clsName: 'days',
					navFnc: 'M',
					navStep: 1
				},
				{
					clsName: 'months',
					navFnc: 'y',
					navStep: 1
				},
				{
					clsName: 'years',
					navFnc: 'y',
					navStep: 10
				},
				{
					clsName: 'decades',
					navFnc: 'y',
					navStep: 100
				}
			],
			viewModes = ['days', 'months', 'years', 'decades'],
			verticalModes = ['top', 'bottom', 'auto'],
			horizontalModes = ['left', 'right', 'auto'],
			toolbarPlacements = ['default', 'top', 'bottom'],
			keyMap = {
				'up': 38,
				38: 'up',
				'down': 40,
				40: 'down',
				'left': 37,
				37: 'left',
				'right': 39,
				39: 'right',
				'tab': 9,
				9: 'tab',
				'escape': 27,
				27: 'escape',
				'enter': 13,
				13: 'enter',
				'pageUp': 33,
				33: 'pageUp',
				'pageDown': 34,
				34: 'pageDown',
				'shift': 16,
				16: 'shift',
				'control': 17,
				17: 'control',
				'space': 32,
				32: 'space',
				't': 84,
				84: 't',
				'delete': 46,
				46: 'delete'
			},
			keyState = {},

			/********************************************************************************
			 *
			 * Private functions
			 *
			 ********************************************************************************/

			hasTimeZone = function () {
				return moment.tz !== undefined && options.timeZone !== undefined && options.timeZone !== null && options.timeZone !== '';
			},

			getMoment = function (d) {
				var returnMoment;

				if (d === undefined || d === null) {
					returnMoment = moment(); //TODO should this use format? and locale?
				} else if (moment.isDate(d) || moment.isMoment(d)) {
					// If the date that is passed in is already a Date() or moment() object,
					// pass it directly to moment.
					returnMoment = moment(d);
				} else if (hasTimeZone()) { // There is a string to parse and a default time zone
					// parse with the tz function which takes a default time zone if it is not in the format string
					returnMoment = moment.tz(d, parseFormats, options.useStrict, options.timeZone);
				} else {
					returnMoment = moment(d, parseFormats, options.useStrict);
				}

				if (hasTimeZone()) {
					returnMoment.tz(options.timeZone);
				}

				return returnMoment;
			},

			isEnabled = function (granularity) {
				if (typeof granularity !== 'string' || granularity.length > 1) {
					throw new TypeError('isEnabled expects a single character string parameter');
				}
				switch (granularity) {
					case 'y':
						return actualFormat.indexOf('Y') !== -1;
					case 'M':
						return actualFormat.indexOf('M') !== -1;
					case 'd':
						return actualFormat.toLowerCase().indexOf('d') !== -1;
					case 'h':
					case 'H':
						return actualFormat.toLowerCase().indexOf('h') !== -1;
					case 'm':
						return actualFormat.indexOf('m') !== -1;
					case 's':
						return actualFormat.indexOf('s') !== -1;
					default:
						return false;
				}
			},

			hasTime = function () {
				return (isEnabled('h') || isEnabled('m') || isEnabled('s'));
			},

			hasDate = function () {
				return (isEnabled('y') || isEnabled('M') || isEnabled('d'));
			},

			getDatePickerTemplate = function () {
				var headTemplate = $('<thead>')
						.append($('<tr>')
							.append($('<th>').addClass('prev').attr('data-action', 'previous')
								.append($('<span>').addClass(options.icons.previous))
							)
							.append($('<th>').addClass('picker-switch').attr('data-action', 'pickerSwitch').attr('colspan', (options.calendarWeeks ? '6' : '5')))
							.append($('<th>').addClass('next').attr('data-action', 'next')
								.append($('<span>').addClass(options.icons.next))
							)
						),
					contTemplate = $('<tbody>')
						.append($('<tr>')
							.append($('<td>').attr('colspan', (options.calendarWeeks ? '8' : '7')))
						);

				return [
					$('<div>').addClass('datepicker-days')
						.append($('<table>').addClass('table-condensed')
							.append(headTemplate)
							.append($('<tbody>'))
						),
					$('<div>').addClass('datepicker-months')
						.append($('<table>').addClass('table-condensed')
							.append(headTemplate.clone())
							.append(contTemplate.clone())
						),
					$('<div>').addClass('datepicker-years')
						.append($('<table>').addClass('table-condensed')
							.append(headTemplate.clone())
							.append(contTemplate.clone())
						),
					$('<div>').addClass('datepicker-decades')
						.append($('<table>').addClass('table-condensed')
							.append(headTemplate.clone())
							.append(contTemplate.clone())
						)
				];
			},

			getTimePickerMainTemplate = function () {
				var topRow = $('<tr>'),
					middleRow = $('<tr>'),
					bottomRow = $('<tr>');

				if (isEnabled('h')) {
					topRow.append($('<td>')
						.append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.incrementHour }).addClass('btn').attr('data-action', 'incrementHours').append($('<span>').addClass(options.icons.up))));
					middleRow.append($('<td>')
						.append($('<span>').addClass('timepicker-hour').attr({ 'data-time-component': 'hours', 'title': options.tooltips.pickHour }).attr('data-action', 'showHours')));
					bottomRow.append($('<td>')
						.append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.decrementHour }).addClass('btn').attr('data-action', 'decrementHours').append($('<span>').addClass(options.icons.down))));
				}
				if (isEnabled('m')) {
					if (isEnabled('h')) {
						topRow.append($('<td>').addClass('separator'));
						middleRow.append($('<td>').addClass('separator').html(':'));
						bottomRow.append($('<td>').addClass('separator'));
					}
					topRow.append($('<td>')
						.append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.incrementMinute }).addClass('btn').attr('data-action', 'incrementMinutes')
							.append($('<span>').addClass(options.icons.up))));
					middleRow.append($('<td>')
						.append($('<span>').addClass('timepicker-minute').attr({ 'data-time-component': 'minutes', 'title': options.tooltips.pickMinute }).attr('data-action', 'showMinutes')));
					bottomRow.append($('<td>')
						.append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.decrementMinute }).addClass('btn').attr('data-action', 'decrementMinutes')
							.append($('<span>').addClass(options.icons.down))));
				}
				if (isEnabled('s')) {
					if (isEnabled('m')) {
						topRow.append($('<td>').addClass('separator'));
						middleRow.append($('<td>').addClass('separator').html(':'));
						bottomRow.append($('<td>').addClass('separator'));
					}
					topRow.append($('<td>')
						.append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.incrementSecond }).addClass('btn').attr('data-action', 'incrementSeconds')
							.append($('<span>').addClass(options.icons.up))));
					middleRow.append($('<td>')
						.append($('<span>').addClass('timepicker-second').attr({ 'data-time-component': 'seconds', 'title': options.tooltips.pickSecond }).attr('data-action', 'showSeconds')));
					bottomRow.append($('<td>')
						.append($('<a>').attr({ href: '#', tabindex: '-1', 'title': options.tooltips.decrementSecond }).addClass('btn').attr('data-action', 'decrementSeconds')
							.append($('<span>').addClass(options.icons.down))));
				}

				if (!use24Hours) {
					topRow.append($('<td>').addClass('separator'));
					middleRow.append($('<td>')
						.append($('<button>').addClass('btn btn-primary').attr({ 'data-action': 'togglePeriod', tabindex: '-1', 'title': options.tooltips.togglePeriod })));
					bottomRow.append($('<td>').addClass('separator'));
				}

				return $('<div>').addClass('timepicker-picker')
					.append($('<table>').addClass('table-condensed')
						.append([topRow, middleRow, bottomRow]));
			},

			getTimePickerTemplate = function () {
				var hoursView = $('<div>').addClass('timepicker-hours')
						.append($('<table>').addClass('table-condensed')),
					minutesView = $('<div>').addClass('timepicker-minutes')
						.append($('<table>').addClass('table-condensed')),
					secondsView = $('<div>').addClass('timepicker-seconds')
						.append($('<table>').addClass('table-condensed')),
					ret = [getTimePickerMainTemplate()];

				if (isEnabled('h')) {
					ret.push(hoursView);
				}
				if (isEnabled('m')) {
					ret.push(minutesView);
				}
				if (isEnabled('s')) {
					ret.push(secondsView);
				}

				return ret;
			},

			getToolbar = function () {
				var row = [];
				if (options.showTodayButton) {
					row.push($('<td>').append($('<a>').attr({ 'data-action': 'today', 'title': options.tooltips.today }).append($('<span>').addClass(options.icons.today))));
				}
				if (!options.sideBySide && hasDate() && hasTime()) {
					row.push($('<td>').append($('<a>').attr({ 'data-action': 'togglePicker', 'title': options.tooltips.selectTime }).append($('<span>').addClass(options.icons.time))));
				}
				if (options.showClear) {
					row.push($('<td>').append($('<a>').attr({ 'data-action': 'clear', 'title': options.tooltips.clear }).append($('<span>').addClass(options.icons.clear))));
				}
				if (options.showClose) {
					row.push($('<td>').append($('<a>').attr({ 'data-action': 'close', 'title': options.tooltips.close }).append($('<span>').addClass(options.icons.close))));
				}
				return $('<table>').addClass('table-condensed').append($('<tbody>').append($('<tr>').append(row)));
			},

			getTemplate = function () {
				var template = $('<div>').addClass('bootstrap-datetimepicker-widget dropdown-menu'),
					dateView = $('<div>').addClass('datepicker').append(getDatePickerTemplate()),
					timeView = $('<div>').addClass('timepicker').append(getTimePickerTemplate()),
					content = $('<ul>').addClass('list-unstyled'),
					toolbar = $('<li>').addClass('picker-switch' + (options.collapse ? ' accordion-toggle' : '')).append(getToolbar());

				if (options.inline) {
					template.removeClass('dropdown-menu');
				}

				if (use24Hours) {
					template.addClass('usetwentyfour');
				}

				if (isEnabled('s') && !use24Hours) {
					template.addClass('wider');
				}

				if (options.sideBySide && hasDate() && hasTime()) {
					template.addClass('timepicker-sbs');
					if (options.toolbarPlacement === 'top') {
						template.append(toolbar);
					}
					template.append(
						$('<div>').addClass('row')
							.append(dateView.addClass('col-md-6'))
							.append(timeView.addClass('col-md-6'))
					);
					if (options.toolbarPlacement === 'bottom') {
						template.append(toolbar);
					}
					return template;
				}

				if (options.toolbarPlacement === 'top') {
					content.append(toolbar);
				}
				if (hasDate()) {
					content.append($('<li>').addClass((options.collapse && hasTime() ? 'collapse show' : '')).append(dateView));  // smap bootstrap v4
				}
				if (options.toolbarPlacement === 'default') {
					content.append(toolbar);
				}
				if (hasTime()) {
					content.append($('<li>').addClass((options.collapse && hasDate() ? 'collapse' : '')).append(timeView));
				}
				if (options.toolbarPlacement === 'bottom') {
					content.append(toolbar);
				}
				return template.append(content);
			},

			dataToOptions = function () {
				var eData,
					dataOptions = {};

				if (element.is('input') || options.inline) {
					eData = element.data();
				} else {
					eData = element.find('input').data();
				}

				if (eData.dateOptions && eData.dateOptions instanceof Object) {
					dataOptions = $.extend(true, dataOptions, eData.dateOptions);
				}

				$.each(options, function (key) {
					var attributeName = 'date' + key.charAt(0).toUpperCase() + key.slice(1);
					if (eData[attributeName] !== undefined) {
						dataOptions[key] = eData[attributeName];
					}
				});
				return dataOptions;
			},

			place = function () {
				var position = (component || element).position(),
					offset = (component || element).offset(),
					vertical = options.widgetPositioning.vertical,
					horizontal = options.widgetPositioning.horizontal,
					parent;

				if (options.widgetParent) {
					parent = options.widgetParent.append(widget);
				} else if (element.is('input')) {
					parent = element.after(widget).parent();
				} else if (options.inline) {
					parent = element.append(widget);
					return;
				} else {
					parent = element;
					element.children().first().after(widget);
				}

				// Top and bottom logic
				if (vertical === 'auto') {
					if (offset.top + widget.height() * 1.5 >= $(window).height() + $(window).scrollTop() &&
						widget.height() + element.outerHeight() < offset.top) {
						vertical = 'top';
					} else {
						vertical = 'bottom';
					}
				}

				// Left and right logic
				if (horizontal === 'auto') {
					if (parent.width() < offset.left + widget.outerWidth() / 2 &&
						offset.left + widget.outerWidth() > $(window).width()) {
						horizontal = 'right';
					} else {
						horizontal = 'left';
					}
				}

				if (vertical === 'top') {
					widget.addClass('top').removeClass('bottom');
				} else {
					widget.addClass('bottom').removeClass('top');
				}

				if (horizontal === 'right') {
					widget.addClass('pull-right');
				} else {
					widget.removeClass('pull-right');
				}

				// find the first parent element that has a non-static css positioning
				if (parent.css('position') === 'static') {
					parent = parent.parents().filter(function () {
						return $(this).css('position') !== 'static';
					}).first();
				}

				if (parent.length === 0) {
					throw new Error('datetimepicker component should be placed within a non-static positioned container');
				}

				widget.css({
					top: vertical === 'top' ? 'auto' : position.top + element.outerHeight(),
					bottom: vertical === 'top' ? parent.outerHeight() - (parent === element ? 0 : position.top) : 'auto',
					left: horizontal === 'left' ? (parent === element ? 0 : position.left) : 'auto',
					right: horizontal === 'left' ? 'auto' : parent.outerWidth() - element.outerWidth() - (parent === element ? 0 : position.left)
				});
			},

			notifyEvent = function (e) {
				if (e.type === 'dp.change' && ((e.date && e.date.isSame(e.oldDate)) || (!e.date && !e.oldDate))) {
					return;
				}
				element.trigger(e);
			},

			viewUpdate = function (e) {
				if (e === 'y') {
					e = 'YYYY';
				}
				notifyEvent({
					type: 'dp.update',
					change: e,
					viewDate: viewDate.clone()
				});
			},

			showMode = function (dir) {
				if (!widget) {
					return;
				}
				if (dir) {
					currentViewMode = Math.max(minViewModeNumber, Math.min(3, currentViewMode + dir));
				}
				widget.find('.datepicker > div').hide().filter('.datepicker-' + datePickerModes[currentViewMode].clsName).show();
			},

			fillDow = function () {
				var row = $('<tr>'),
					currentDate = viewDate.clone().startOf('w').startOf('d');

				if (options.calendarWeeks === true) {
					row.append($('<th>').addClass('cw').text('#'));
				}

				while (currentDate.isBefore(viewDate.clone().endOf('w'))) {
					row.append($('<th>').addClass('dow').text(currentDate.format('dd')));
					currentDate.add(1, 'd');
				}
				widget.find('.datepicker-days thead').append(row);
			},

			isInDisabledDates = function (testDate) {
				return options.disabledDates[testDate.format('YYYY-MM-DD')] === true;
			},

			isInEnabledDates = function (testDate) {
				return options.enabledDates[testDate.format('YYYY-MM-DD')] === true;
			},

			isInDisabledHours = function (testDate) {
				return options.disabledHours[testDate.format('H')] === true;
			},

			isInEnabledHours = function (testDate) {
				return options.enabledHours[testDate.format('H')] === true;
			},

			isValid = function (targetMoment, granularity) {
				if (!targetMoment.isValid()) {
					return false;
				}
				if (options.disabledDates && granularity === 'd' && isInDisabledDates(targetMoment)) {
					return false;
				}
				if (options.enabledDates && granularity === 'd' && !isInEnabledDates(targetMoment)) {
					return false;
				}
				if (options.minDate && targetMoment.isBefore(options.minDate, granularity)) {
					return false;
				}
				if (options.maxDate && targetMoment.isAfter(options.maxDate, granularity)) {
					return false;
				}
				if (options.daysOfWeekDisabled && granularity === 'd' && options.daysOfWeekDisabled.indexOf(targetMoment.day()) !== -1) {
					return false;
				}
				if (options.disabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && isInDisabledHours(targetMoment)) {
					return false;
				}
				if (options.enabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && !isInEnabledHours(targetMoment)) {
					return false;
				}
				if (options.disabledTimeIntervals && (granularity === 'h' || granularity === 'm' || granularity === 's')) {
					var found = false;
					$.each(options.disabledTimeIntervals, function () {
						if (targetMoment.isBetween(this[0], this[1])) {
							found = true;
							return false;
						}
					});
					if (found) {
						return false;
					}
				}
				return true;
			},

			fillMonths = function () {
				var spans = [],
					monthsShort = viewDate.clone().startOf('y').startOf('d');
				while (monthsShort.isSame(viewDate, 'y')) {
					spans.push($('<span>').attr('data-action', 'selectMonth').addClass('month').text(monthsShort.format('MMM')));
					monthsShort.add(1, 'M');
				}
				widget.find('.datepicker-months td').empty().append(spans);
			},

			updateMonths = function () {
				var monthsView = widget.find('.datepicker-months'),
					monthsViewHeader = monthsView.find('th'),
					months = monthsView.find('tbody').find('span');

				monthsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevYear);
				monthsViewHeader.eq(1).attr('title', options.tooltips.selectYear);
				monthsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextYear);

				monthsView.find('.disabled').removeClass('disabled');

				if (!isValid(viewDate.clone().subtract(1, 'y'), 'y')) {
					monthsViewHeader.eq(0).addClass('disabled');
				}

				monthsViewHeader.eq(1).text(viewDate.year());

				if (!isValid(viewDate.clone().add(1, 'y'), 'y')) {
					monthsViewHeader.eq(2).addClass('disabled');
				}

				months.removeClass('active');
				if (date.isSame(viewDate, 'y') && !unset) {
					months.eq(date.month()).addClass('active');
				}

				months.each(function (index) {
					if (!isValid(viewDate.clone().month(index), 'M')) {
						$(this).addClass('disabled');
					}
				});
			},

			updateYears = function () {
				var yearsView = widget.find('.datepicker-years'),
					yearsViewHeader = yearsView.find('th'),
					startYear = viewDate.clone().subtract(5, 'y'),
					endYear = viewDate.clone().add(6, 'y'),
					html = '';

				yearsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevDecade);
				yearsViewHeader.eq(1).attr('title', options.tooltips.selectDecade);
				yearsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextDecade);

				yearsView.find('.disabled').removeClass('disabled');

				if (options.minDate && options.minDate.isAfter(startYear, 'y')) {
					yearsViewHeader.eq(0).addClass('disabled');
				}

				yearsViewHeader.eq(1).text(startYear.year() + '-' + endYear.year());

				if (options.maxDate && options.maxDate.isBefore(endYear, 'y')) {
					yearsViewHeader.eq(2).addClass('disabled');
				}

				while (!startYear.isAfter(endYear, 'y')) {
					html += '<span data-action="selectYear" class="year' + (startYear.isSame(date, 'y') && !unset ? ' active' : '') + (!isValid(startYear, 'y') ? ' disabled' : '') + '">' + startYear.year() + '</span>';
					startYear.add(1, 'y');
				}

				yearsView.find('td').html(html);
			},

			updateDecades = function () {
				var decadesView = widget.find('.datepicker-decades'),
					decadesViewHeader = decadesView.find('th'),
					startDecade = moment({ y: viewDate.year() - (viewDate.year() % 100) - 1 }),
					endDecade = startDecade.clone().add(100, 'y'),
					startedAt = startDecade.clone(),
					minDateDecade = false,
					maxDateDecade = false,
					endDecadeYear,
					html = '';

				decadesViewHeader.eq(0).find('span').attr('title', options.tooltips.prevCentury);
				decadesViewHeader.eq(2).find('span').attr('title', options.tooltips.nextCentury);

				decadesView.find('.disabled').removeClass('disabled');

				if (startDecade.isSame(moment({ y: 1900 })) || (options.minDate && options.minDate.isAfter(startDecade, 'y'))) {
					decadesViewHeader.eq(0).addClass('disabled');
				}

				decadesViewHeader.eq(1).text(startDecade.year() + '-' + endDecade.year());

				if (startDecade.isSame(moment({ y: 2000 })) || (options.maxDate && options.maxDate.isBefore(endDecade, 'y'))) {
					decadesViewHeader.eq(2).addClass('disabled');
				}

				while (!startDecade.isAfter(endDecade, 'y')) {
					endDecadeYear = startDecade.year() + 12;
					minDateDecade = options.minDate && options.minDate.isAfter(startDecade, 'y') && options.minDate.year() <= endDecadeYear;
					maxDateDecade = options.maxDate && options.maxDate.isAfter(startDecade, 'y') && options.maxDate.year() <= endDecadeYear;
					html += '<span data-action="selectDecade" class="decade' + (date.isAfter(startDecade) && date.year() <= endDecadeYear ? ' active' : '') +
						(!isValid(startDecade, 'y') && !minDateDecade && !maxDateDecade ? ' disabled' : '') + '" data-selection="' + (startDecade.year() + 6) + '">' + (startDecade.year() + 1) + ' - ' + (startDecade.year() + 12) + '</span>';
					startDecade.add(12, 'y');
				}
				html += '<span></span><span></span><span></span>'; //push the dangling block over, at least this way it's even

				decadesView.find('td').html(html);
				decadesViewHeader.eq(1).text((startedAt.year() + 1) + '-' + (startDecade.year()));
			},

			fillDate = function () {
				var daysView = widget.find('.datepicker-days'),
					daysViewHeader = daysView.find('th'),
					currentDate,
					html = [],
					row,
					clsNames = [],
					i;

				if (!hasDate()) {
					return;
				}

				daysViewHeader.eq(0).find('span').attr('title', options.tooltips.prevMonth);
				daysViewHeader.eq(1).attr('title', options.tooltips.selectMonth);
				daysViewHeader.eq(2).find('span').attr('title', options.tooltips.nextMonth);

				daysView.find('.disabled').removeClass('disabled');
				daysViewHeader.eq(1).text(viewDate.format(options.dayViewHeaderFormat));

				if (!isValid(viewDate.clone().subtract(1, 'M'), 'M')) {
					daysViewHeader.eq(0).addClass('disabled');
				}
				if (!isValid(viewDate.clone().add(1, 'M'), 'M')) {
					daysViewHeader.eq(2).addClass('disabled');
				}

				currentDate = viewDate.clone().startOf('M').startOf('w').startOf('d');

				for (i = 0; i < 42; i++) { //always display 42 days (should show 6 weeks)
					if (currentDate.weekday() === 0) {
						row = $('<tr>');
						if (options.calendarWeeks) {
							row.append('<td class="cw">' + currentDate.week() + '</td>');
						}
						html.push(row);
					}
					clsNames = ['day'];
					if (currentDate.isBefore(viewDate, 'M')) {
						clsNames.push('old');
					}
					if (currentDate.isAfter(viewDate, 'M')) {
						clsNames.push('new');
					}
					if (currentDate.isSame(date, 'd') && !unset) {
						clsNames.push('active');
					}
					if (!isValid(currentDate, 'd')) {
						clsNames.push('disabled');
					}
					if (currentDate.isSame(getMoment(), 'd')) {
						clsNames.push('today');
					}
					if (currentDate.day() === 0 || currentDate.day() === 6) {
						clsNames.push('weekend');
					}
					notifyEvent({
						type: 'dp.classify',
						date: currentDate,
						classNames: clsNames
					});
					row.append('<td data-action="selectDay" data-day="' + currentDate.format('L') + '" class="' + clsNames.join(' ') + '">' + currentDate.date() + '</td>');
					currentDate.add(1, 'd');
				}

				daysView.find('tbody').empty().append(html);

				updateMonths();

				updateYears();

				updateDecades();
			},

			fillHours = function () {
				var table = widget.find('.timepicker-hours table'),
					currentHour = viewDate.clone().startOf('d'),
					html = [],
					row = $('<tr>');

				if (viewDate.hour() > 11 && !use24Hours) {
					currentHour.hour(12);
				}
				while (currentHour.isSame(viewDate, 'd') && (use24Hours || (viewDate.hour() < 12 && currentHour.hour() < 12) || viewDate.hour() > 11)) {
					if (currentHour.hour() % 4 === 0) {
						row = $('<tr>');
						html.push(row);
					}
					row.append('<td data-action="selectHour" class="hour' + (!isValid(currentHour, 'h') ? ' disabled' : '') + '">' + currentHour.format(use24Hours ? 'HH' : 'hh') + '</td>');
					currentHour.add(1, 'h');
				}
				table.empty().append(html);
			},

			fillMinutes = function () {
				var table = widget.find('.timepicker-minutes table'),
					currentMinute = viewDate.clone().startOf('h'),
					html = [],
					row = $('<tr>'),
					step = options.stepping === 1 ? 5 : options.stepping;

				while (viewDate.isSame(currentMinute, 'h')) {
					if (currentMinute.minute() % (step * 4) === 0) {
						row = $('<tr>');
						html.push(row);
					}
					row.append('<td data-action="selectMinute" class="minute' + (!isValid(currentMinute, 'm') ? ' disabled' : '') + '">' + currentMinute.format('mm') + '</td>');
					currentMinute.add(step, 'm');
				}
				table.empty().append(html);
			},

			fillSeconds = function () {
				var table = widget.find('.timepicker-seconds table'),
					currentSecond = viewDate.clone().startOf('m'),
					html = [],
					row = $('<tr>');

				while (viewDate.isSame(currentSecond, 'm')) {
					if (currentSecond.second() % 20 === 0) {
						row = $('<tr>');
						html.push(row);
					}
					row.append('<td data-action="selectSecond" class="second' + (!isValid(currentSecond, 's') ? ' disabled' : '') + '">' + currentSecond.format('ss') + '</td>');
					currentSecond.add(5, 's');
				}

				table.empty().append(html);
			},

			fillTime = function () {
				var toggle, newDate, timeComponents = widget.find('.timepicker span[data-time-component]');

				if (!use24Hours) {
					toggle = widget.find('.timepicker [data-action=togglePeriod]');
					newDate = date.clone().add((date.hours() >= 12) ? -12 : 12, 'h');

					toggle.text(date.format('A'));

					if (isValid(newDate, 'h')) {
						toggle.removeClass('disabled');
					} else {
						toggle.addClass('disabled');
					}
				}
				timeComponents.filter('[data-time-component=hours]').text(date.format(use24Hours ? 'HH' : 'hh'));
				timeComponents.filter('[data-time-component=minutes]').text(date.format('mm'));
				timeComponents.filter('[data-time-component=seconds]').text(date.format('ss'));

				fillHours();
				fillMinutes();
				fillSeconds();
			},

			update = function () {
				if (!widget) {
					return;
				}
				fillDate();
				fillTime();
			},

			setValue = function (targetMoment) {
				var oldDate = unset ? null : date;

				// case of calling setValue(null or false)
				if (!targetMoment) {
					unset = true;
					input.val('');
					element.data('date', '');
					notifyEvent({
						type: 'dp.change',
						date: false,
						oldDate: oldDate
					});
					update();
					return;
				}

				targetMoment = targetMoment.clone().locale(options.locale);

				if (hasTimeZone()) {
					targetMoment.tz(options.timeZone);
				}

				if (options.stepping !== 1) {
					targetMoment.minutes((Math.round(targetMoment.minutes() / options.stepping) * options.stepping)).seconds(0);

					while (options.minDate && targetMoment.isBefore(options.minDate)) {
						targetMoment.add(options.stepping, 'minutes');
					}
				}

				if (isValid(targetMoment)) {
					date = targetMoment;
					viewDate = date.clone();
					input.val(date.format(actualFormat));
					element.data('date', date.format(actualFormat));
					unset = false;
					update();
					notifyEvent({
						type: 'dp.change',
						date: date.clone(),
						oldDate: oldDate
					});
				} else {
					if (!options.keepInvalid) {
						input.val(unset ? '' : date.format(actualFormat));
					} else {
						notifyEvent({
							type: 'dp.change',
							date: targetMoment,
							oldDate: oldDate
						});
					}
					notifyEvent({
						type: 'dp.error',
						date: targetMoment,
						oldDate: oldDate
					});
				}
			},

			/**
			 * Hides the widget. Possibly will emit dp.hide
			 */
			hide = function () {
				var transitioning = false;
				if (!widget) {
					return picker;
				}
				// Ignore event if in the middle of a picker transition
				widget.find('.collapse').each(function () {
					var collapseData = $(this).data('collapse');
					if (collapseData && collapseData.transitioning) {
						transitioning = true;
						return false;
					}
					return true;
				});
				if (transitioning) {
					return picker;
				}
				if (component && component.hasClass('btn')) {
					component.toggleClass('active');
				}
				widget.hide();

				$(window).off('resize', place);
				widget.off('click', '[data-action]');
				widget.off('mousedown', false);

				widget.remove();
				widget = false;

				notifyEvent({
					type: 'dp.hide',
					date: date.clone()
				});

				input.blur();

				viewDate = date.clone();

				return picker;
			},

			clear = function () {
				setValue(null);
			},

			parseInputDate = function (inputDate) {
				if (options.parseInputDate === undefined) {
					if (!moment.isMoment(inputDate) || inputDate instanceof Date) {
						inputDate = getMoment(inputDate);
					}
				} else {
					inputDate = options.parseInputDate(inputDate);
				}
				//inputDate.locale(options.locale);
				return inputDate;
			},

			/********************************************************************************
			 *
			 * Widget UI interaction functions
			 *
			 ********************************************************************************/
			actions = {
				next: function () {
					var navFnc = datePickerModes[currentViewMode].navFnc;
					viewDate.add(datePickerModes[currentViewMode].navStep, navFnc);
					fillDate();
					viewUpdate(navFnc);
				},

				previous: function () {
					var navFnc = datePickerModes[currentViewMode].navFnc;
					viewDate.subtract(datePickerModes[currentViewMode].navStep, navFnc);
					fillDate();
					viewUpdate(navFnc);
				},

				pickerSwitch: function () {
					showMode(1);
				},

				selectMonth: function (e) {
					var month = $(e.target).closest('tbody').find('span').index($(e.target));
					viewDate.month(month);
					if (currentViewMode === minViewModeNumber) {
						setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
						if (!options.inline) {
							hide();
						}
					} else {
						showMode(-1);
						fillDate();
					}
					viewUpdate('M');
				},

				selectYear: function (e) {
					var year = parseInt($(e.target).text(), 10) || 0;
					viewDate.year(year);
					if (currentViewMode === minViewModeNumber) {
						setValue(date.clone().year(viewDate.year()));
						if (!options.inline) {
							hide();
						}
					} else {
						showMode(-1);
						fillDate();
					}
					viewUpdate('YYYY');
				},

				selectDecade: function (e) {
					var year = parseInt($(e.target).data('selection'), 10) || 0;
					viewDate.year(year);
					if (currentViewMode === minViewModeNumber) {
						setValue(date.clone().year(viewDate.year()));
						if (!options.inline) {
							hide();
						}
					} else {
						showMode(-1);
						fillDate();
					}
					viewUpdate('YYYY');
				},

				selectDay: function (e) {
					var day = viewDate.clone();
					if ($(e.target).is('.old')) {
						day.subtract(1, 'M');
					}
					if ($(e.target).is('.new')) {
						day.add(1, 'M');
					}
					setValue(day.date(parseInt($(e.target).text(), 10)));
					if (!hasTime() && !options.keepOpen && !options.inline) {
						hide();
					}
				},

				incrementHours: function () {
					var newDate = date.clone().add(1, 'h');
					if (isValid(newDate, 'h')) {
						setValue(newDate);
					}
				},

				incrementMinutes: function () {
					var newDate = date.clone().add(options.stepping, 'm');
					if (isValid(newDate, 'm')) {
						setValue(newDate);
					}
				},

				incrementSeconds: function () {
					var newDate = date.clone().add(1, 's');
					if (isValid(newDate, 's')) {
						setValue(newDate);
					}
				},

				decrementHours: function () {
					var newDate = date.clone().subtract(1, 'h');
					if (isValid(newDate, 'h')) {
						setValue(newDate);
					}
				},

				decrementMinutes: function () {
					var newDate = date.clone().subtract(options.stepping, 'm');
					if (isValid(newDate, 'm')) {
						setValue(newDate);
					}
				},

				decrementSeconds: function () {
					var newDate = date.clone().subtract(1, 's');
					if (isValid(newDate, 's')) {
						setValue(newDate);
					}
				},

				togglePeriod: function () {
					setValue(date.clone().add((date.hours() >= 12) ? -12 : 12, 'h'));
				},

				togglePicker: function (e) {
					var $this = $(e.target),
						$parent = $this.closest('ul'),
						expanded = $parent.find('.show'),               // smap bootstrap v4
						closed = $parent.find('.collapse:not(.show)'),  // smap bootstrap v4
						collapseData;

					if (expanded && expanded.length) {
						collapseData = expanded.data('collapse');
						if (collapseData && collapseData.transitioning) {
							return;
						}
						if (expanded.collapse) { // if collapse plugin is available through bootstrap.js then use it
							expanded.collapse('hide');
							closed.collapse('show');
						} else { // otherwise just toggle in class on the two views
							expanded.removeClass('show');   // smap bootstrap v4
							closed.addClass('show');        // smap bootstrap v4
						}
						if ($this.is('span')) {
							$this.toggleClass(options.icons.time + ' ' + options.icons.date);
						} else {
							$this.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
						}

						// NOTE: uncomment if toggled state will be restored in show()
						//if (component) {
						//    component.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
						//}
					}
				},

				showPicker: function () {
					widget.find('.timepicker > div:not(.timepicker-picker)').hide();
					widget.find('.timepicker .timepicker-picker').show();
				},

				showHours: function () {
					widget.find('.timepicker .timepicker-picker').hide();
					widget.find('.timepicker .timepicker-hours').show();
				},

				showMinutes: function () {
					widget.find('.timepicker .timepicker-picker').hide();
					widget.find('.timepicker .timepicker-minutes').show();
				},

				showSeconds: function () {
					widget.find('.timepicker .timepicker-picker').hide();
					widget.find('.timepicker .timepicker-seconds').show();
				},

				selectHour: function (e) {
					var hour = parseInt($(e.target).text(), 10);

					if (!use24Hours) {
						if (date.hours() >= 12) {
							if (hour !== 12) {
								hour += 12;
							}
						} else {
							if (hour === 12) {
								hour = 0;
							}
						}
					}
					setValue(date.clone().hours(hour));
					actions.showPicker.call(picker);
				},

				selectMinute: function (e) {
					setValue(date.clone().minutes(parseInt($(e.target).text(), 10)));
					actions.showPicker.call(picker);
				},

				selectSecond: function (e) {
					setValue(date.clone().seconds(parseInt($(e.target).text(), 10)));
					actions.showPicker.call(picker);
				},

				clear: clear,

				today: function () {
					var todaysDate = getMoment();
					if (isValid(todaysDate, 'd')) {
						setValue(todaysDate);
					}
				},

				close: hide
			},

			doAction = function (e) {
				if ($(e.currentTarget).is('.disabled')) {
					return false;
				}
				actions[$(e.currentTarget).data('action')].apply(picker, arguments);
				return false;
			},

			/**
			 * Shows the widget. Possibly will emit dp.show and dp.change
			 */
			show = function () {
				var currentMoment,
					useCurrentGranularity = {
						'year': function (m) {
							return m.month(0).date(1).hours(0).seconds(0).minutes(0);
						},
						'month': function (m) {
							return m.date(1).hours(0).seconds(0).minutes(0);
						},
						'day': function (m) {
							return m.hours(0).seconds(0).minutes(0);
						},
						'hour': function (m) {
							return m.seconds(0).minutes(0);
						},
						'minute': function (m) {
							return m.seconds(0);
						}
					};

				if (input.prop('disabled') || (!options.ignoreReadonly && input.prop('readonly')) || widget) {
					return picker;
				}
				if (input.val() !== undefined && input.val().trim().length !== 0) {
					setValue(parseInputDate(input.val().trim()));
				} else if (unset && options.useCurrent && (options.inline || (input.is('input') && input.val().trim().length === 0))) {
					currentMoment = getMoment();
					if (typeof options.useCurrent === 'string') {
						currentMoment = useCurrentGranularity[options.useCurrent](currentMoment);
					}
					setValue(currentMoment);
				}
				widget = getTemplate();

				fillDow();
				fillMonths();

				widget.find('.timepicker-hours').hide();
				widget.find('.timepicker-minutes').hide();
				widget.find('.timepicker-seconds').hide();

				update();
				showMode();

				$(window).on('resize', place);
				widget.on('click', '[data-action]', doAction); // this handles clicks on the widget
				widget.on('mousedown', false);

				if (component && component.hasClass('btn')) {
					component.toggleClass('active');
				}
				place();
				widget.show();
				if (options.focusOnShow && !input.is(':focus')) {
					input.focus();
				}

				notifyEvent({
					type: 'dp.show'
				});
				return picker;
			},

			/**
			 * Shows or hides the widget
			 */
			toggle = function () {
				return (widget ? hide() : show());
			},

			keydown = function (e) {
				var handler = null,
					index,
					index2,
					pressedKeys = [],
					pressedModifiers = {},
					currentKey = e.which,
					keyBindKeys,
					allModifiersPressed,
					pressed = 'p';

				keyState[currentKey] = pressed;

				for (index in keyState) {
					if (keyState.hasOwnProperty(index) && keyState[index] === pressed) {
						pressedKeys.push(index);
						if (parseInt(index, 10) !== currentKey) {
							pressedModifiers[index] = true;
						}
					}
				}

				for (index in options.keyBinds) {
					if (options.keyBinds.hasOwnProperty(index) && typeof (options.keyBinds[index]) === 'function') {
						keyBindKeys = index.split(' ');
						if (keyBindKeys.length === pressedKeys.length && keyMap[currentKey] === keyBindKeys[keyBindKeys.length - 1]) {
							allModifiersPressed = true;
							for (index2 = keyBindKeys.length - 2; index2 >= 0; index2--) {
								if (!(keyMap[keyBindKeys[index2]] in pressedModifiers)) {
									allModifiersPressed = false;
									break;
								}
							}
							if (allModifiersPressed) {
								handler = options.keyBinds[index];
								break;
							}
						}
					}
				}

				if (handler) {
					handler.call(picker, widget);
					e.stopPropagation();
					e.preventDefault();
				}
			},

			keyup = function (e) {
				keyState[e.which] = 'r';
				e.stopPropagation();
				e.preventDefault();
			},

			change = function (e) {
				var val = $(e.target).val().trim(),
					parsedDate = val ? parseInputDate(val) : null;
				setValue(parsedDate);
				e.stopImmediatePropagation();
				return false;
			},

			attachDatePickerElementEvents = function () {
				input.on({
					'change': change,
					'blur': options.debug ? '' : hide,
					'keydown': keydown,
					'keyup': keyup,
					'focus': options.allowInputToggle ? show : ''
				});

				if (element.is('input')) {
					input.on({
						'focus': show
					});
				} else if (component) {
					component.on('click', toggle);
					component.on('mousedown', false);
				}
			},

			detachDatePickerElementEvents = function () {
				input.off({
					'change': change,
					'blur': blur,
					'keydown': keydown,
					'keyup': keyup,
					'focus': options.allowInputToggle ? hide : ''
				});

				if (element.is('input')) {
					input.off({
						'focus': show
					});
				} else if (component) {
					component.off('click', toggle);
					component.off('mousedown', false);
				}
			},

			indexGivenDates = function (givenDatesArray) {
				// Store given enabledDates and disabledDates as keys.
				// This way we can check their existence in O(1) time instead of looping through whole array.
				// (for example: options.enabledDates['2014-02-27'] === true)
				var givenDatesIndexed = {};
				$.each(givenDatesArray, function () {
					var dDate = parseInputDate(this);
					if (dDate.isValid()) {
						givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
					}
				});
				return (Object.keys(givenDatesIndexed).length) ? givenDatesIndexed : false;
			},

			indexGivenHours = function (givenHoursArray) {
				// Store given enabledHours and disabledHours as keys.
				// This way we can check their existence in O(1) time instead of looping through whole array.
				// (for example: options.enabledHours['2014-02-27'] === true)
				var givenHoursIndexed = {};
				$.each(givenHoursArray, function () {
					givenHoursIndexed[this] = true;
				});
				return (Object.keys(givenHoursIndexed).length) ? givenHoursIndexed : false;
			},

			initFormatting = function () {
				var format = options.format || 'L LT';

				actualFormat = format.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (formatInput) {
					var newinput = date.localeData().longDateFormat(formatInput) || formatInput;
					return newinput.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (formatInput2) { //temp fix for #740
						return date.localeData().longDateFormat(formatInput2) || formatInput2;
					});
				});


				parseFormats = options.extraFormats ? options.extraFormats.slice() : [];
				if (parseFormats.indexOf(format) < 0 && parseFormats.indexOf(actualFormat) < 0) {
					parseFormats.push(actualFormat);
				}

				use24Hours = (actualFormat.toLowerCase().indexOf('a') < 1 && actualFormat.replace(/\[.*?\]/g, '').indexOf('h') < 1);

				if (isEnabled('y')) {
					minViewModeNumber = 2;
				}
				if (isEnabled('M')) {
					minViewModeNumber = 1;
				}
				if (isEnabled('d')) {
					minViewModeNumber = 0;
				}

				currentViewMode = Math.max(minViewModeNumber, currentViewMode);

				if (!unset) {
					setValue(date);
				}
			};

		/********************************************************************************
		 *
		 * Public API functions
		 * =====================
		 *
		 * Important: Do not expose direct references to private objects or the options
		 * object to the outer world. Always return a clone when returning values or make
		 * a clone when setting a private variable.
		 *
		 ********************************************************************************/
		picker.destroy = function () {
			///<summary>Destroys the widget and removes all attached event listeners</summary>
			hide();
			detachDatePickerElementEvents();
			element.removeData('DateTimePicker');
			element.removeData('date');
		};

		picker.toggle = toggle;

		picker.show = show;

		picker.hide = hide;

		picker.disable = function () {
			///<summary>Disables the input element, the component is attached to, by adding a disabled="true" attribute to it.
			///If the widget was visible before that call it is hidden. Possibly emits dp.hide</summary>
			hide();
			if (component && component.hasClass('btn')) {
				component.addClass('disabled');
			}
			input.prop('disabled', true);
			return picker;
		};

		picker.enable = function () {
			///<summary>Enables the input element, the component is attached to, by removing disabled attribute from it.</summary>
			if (component && component.hasClass('btn')) {
				component.removeClass('disabled');
			}
			input.prop('disabled', false);
			return picker;
		};

		picker.ignoreReadonly = function (ignoreReadonly) {
			if (arguments.length === 0) {
				return options.ignoreReadonly;
			}
			if (typeof ignoreReadonly !== 'boolean') {
				throw new TypeError('ignoreReadonly () expects a boolean parameter');
			}
			options.ignoreReadonly = ignoreReadonly;
			return picker;
		};

		picker.options = function (newOptions) {
			if (arguments.length === 0) {
				return $.extend(true, {}, options);
			}

			if (!(newOptions instanceof Object)) {
				throw new TypeError('options() options parameter should be an object');
			}
			$.extend(true, options, newOptions);
			$.each(options, function (key, value) {
				if (picker[key] !== undefined) {
					picker[key](value);
				} else {
					throw new TypeError('option ' + key + ' is not recognized!');
				}
			});
			return picker;
		};

		picker.date = function (newDate) {
			///<signature helpKeyword="$.fn.datetimepicker.date">
			///<summary>Returns the component's model current date, a moment object or null if not set.</summary>
			///<returns type="Moment">date.clone()</returns>
			///</signature>
			///<signature>
			///<summary>Sets the components model current moment to it. Passing a null value unsets the components model current moment. Parsing of the newDate parameter is made using moment library with the options.format and options.useStrict components configuration.</summary>
			///<param name="newDate" locid="$.fn.datetimepicker.date_p:newDate">Takes string, Date, moment, null parameter.</param>
			///</signature>
			if (arguments.length === 0) {
				if (unset) {
					return null;
				}
				return date.clone();
			}

			if (newDate !== null && typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
				throw new TypeError('date() parameter must be one of [null, string, moment or Date]');
			}

			setValue(newDate === null ? null : parseInputDate(newDate));
			return picker;
		};

		picker.format = function (newFormat) {
			///<summary>test su</summary>
			///<param name="newFormat">info about para</param>
			///<returns type="string|boolean">returns foo</returns>
			if (arguments.length === 0) {
				return options.format;
			}

			if ((typeof newFormat !== 'string') && ((typeof newFormat !== 'boolean') || (newFormat !== false))) {
				throw new TypeError('format() expects a string or boolean:false parameter ' + newFormat);
			}

			options.format = newFormat;
			if (actualFormat) {
				initFormatting(); // reinit formatting
			}
			return picker;
		};

		picker.timeZone = function (newZone) {
			if (arguments.length === 0) {
				return options.timeZone;
			}

			if (typeof newZone !== 'string') {
				throw new TypeError('newZone() expects a string parameter');
			}

			options.timeZone = newZone;

			return picker;
		};

		picker.dayViewHeaderFormat = function (newFormat) {
			if (arguments.length === 0) {
				return options.dayViewHeaderFormat;
			}

			if (typeof newFormat !== 'string') {
				throw new TypeError('dayViewHeaderFormat() expects a string parameter');
			}

			options.dayViewHeaderFormat = newFormat;
			return picker;
		};

		picker.extraFormats = function (formats) {
			if (arguments.length === 0) {
				return options.extraFormats;
			}

			if (formats !== false && !(formats instanceof Array)) {
				throw new TypeError('extraFormats() expects an array or false parameter');
			}

			options.extraFormats = formats;
			if (parseFormats) {
				initFormatting(); // reinit formatting
			}
			return picker;
		};

		picker.disabledDates = function (dates) {
			///<signature helpKeyword="$.fn.datetimepicker.disabledDates">
			///<summary>Returns an array with the currently set disabled dates on the component.</summary>
			///<returns type="array">options.disabledDates</returns>
			///</signature>
			///<signature>
			///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
			///options.enabledDates if such exist.</summary>
			///<param name="dates" locid="$.fn.datetimepicker.disabledDates_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
			///</signature>
			if (arguments.length === 0) {
				return (options.disabledDates ? $.extend({}, options.disabledDates) : options.disabledDates);
			}

			if (!dates) {
				options.disabledDates = false;
				update();
				return picker;
			}
			if (!(dates instanceof Array)) {
				throw new TypeError('disabledDates() expects an array parameter');
			}
			options.disabledDates = indexGivenDates(dates);
			options.enabledDates = false;
			update();
			return picker;
		};

		picker.enabledDates = function (dates) {
			///<signature helpKeyword="$.fn.datetimepicker.enabledDates">
			///<summary>Returns an array with the currently set enabled dates on the component.</summary>
			///<returns type="array">options.enabledDates</returns>
			///</signature>
			///<signature>
			///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of options.disabledDates if such exist.</summary>
			///<param name="dates" locid="$.fn.datetimepicker.enabledDates_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
			///</signature>
			if (arguments.length === 0) {
				return (options.enabledDates ? $.extend({}, options.enabledDates) : options.enabledDates);
			}

			if (!dates) {
				options.enabledDates = false;
				update();
				return picker;
			}
			if (!(dates instanceof Array)) {
				throw new TypeError('enabledDates() expects an array parameter');
			}
			options.enabledDates = indexGivenDates(dates);
			options.disabledDates = false;
			update();
			return picker;
		};

		picker.daysOfWeekDisabled = function (daysOfWeekDisabled) {
			if (arguments.length === 0) {
				return options.daysOfWeekDisabled.splice(0);
			}

			if ((typeof daysOfWeekDisabled === 'boolean') && !daysOfWeekDisabled) {
				options.daysOfWeekDisabled = false;
				update();
				return picker;
			}

			if (!(daysOfWeekDisabled instanceof Array)) {
				throw new TypeError('daysOfWeekDisabled() expects an array parameter');
			}
			options.daysOfWeekDisabled = daysOfWeekDisabled.reduce(function (previousValue, currentValue) {
				currentValue = parseInt(currentValue, 10);
				if (currentValue > 6 || currentValue < 0 || isNaN(currentValue)) {
					return previousValue;
				}
				if (previousValue.indexOf(currentValue) === -1) {
					previousValue.push(currentValue);
				}
				return previousValue;
			}, []).sort();
			if (options.useCurrent && !options.keepInvalid) {
				var tries = 0;
				while (!isValid(date, 'd')) {
					date.add(1, 'd');
					if (tries === 31) {
						throw 'Tried 31 times to find a valid date';
					}
					tries++;
				}
				setValue(date);
			}
			update();
			return picker;
		};

		picker.maxDate = function (maxDate) {
			if (arguments.length === 0) {
				return options.maxDate ? options.maxDate.clone() : options.maxDate;
			}

			if ((typeof maxDate === 'boolean') && maxDate === false) {
				options.maxDate = false;
				update();
				return picker;
			}

			if (typeof maxDate === 'string') {
				if (maxDate === 'now' || maxDate === 'moment') {
					maxDate = getMoment();
				}
			}

			var parsedDate = parseInputDate(maxDate);

			if (!parsedDate.isValid()) {
				throw new TypeError('maxDate() Could not parse date parameter: ' + maxDate);
			}
			if (options.minDate && parsedDate.isBefore(options.minDate)) {
				throw new TypeError('maxDate() date parameter is before options.minDate: ' + parsedDate.format(actualFormat));
			}
			options.maxDate = parsedDate;
			if (options.useCurrent && !options.keepInvalid && date.isAfter(maxDate)) {
				setValue(options.maxDate);
			}
			if (viewDate.isAfter(parsedDate)) {
				viewDate = parsedDate.clone().subtract(options.stepping, 'm');
			}
			update();
			return picker;
		};

		picker.minDate = function (minDate) {
			if (arguments.length === 0) {
				return options.minDate ? options.minDate.clone() : options.minDate;
			}

			if ((typeof minDate === 'boolean') && minDate === false) {
				options.minDate = false;
				update();
				return picker;
			}

			if (typeof minDate === 'string') {
				if (minDate === 'now' || minDate === 'moment') {
					minDate = getMoment();
				}
			}

			var parsedDate = parseInputDate(minDate);

			if (!parsedDate.isValid()) {
				throw new TypeError('minDate() Could not parse date parameter: ' + minDate);
			}
			if (options.maxDate && parsedDate.isAfter(options.maxDate)) {
				throw new TypeError('minDate() date parameter is after options.maxDate: ' + parsedDate.format(actualFormat));
			}
			options.minDate = parsedDate;
			if (options.useCurrent && !options.keepInvalid && date.isBefore(minDate)) {
				setValue(options.minDate);
			}
			if (viewDate.isBefore(parsedDate)) {
				viewDate = parsedDate.clone().add(options.stepping, 'm');
			}
			update();
			return picker;
		};

		picker.defaultDate = function (defaultDate) {
			///<signature helpKeyword="$.fn.datetimepicker.defaultDate">
			///<summary>Returns a moment with the options.defaultDate option configuration or false if not set</summary>
			///<returns type="Moment">date.clone()</returns>
			///</signature>
			///<signature>
			///<summary>Will set the picker's inital date. If a boolean:false value is passed the options.defaultDate parameter is cleared.</summary>
			///<param name="defaultDate" locid="$.fn.datetimepicker.defaultDate_p:defaultDate">Takes a string, Date, moment, boolean:false</param>
			///</signature>
			if (arguments.length === 0) {
				return options.defaultDate ? options.defaultDate.clone() : options.defaultDate;
			}
			if (!defaultDate) {
				options.defaultDate = false;
				return picker;
			}

			if (typeof defaultDate === 'string') {
				if (defaultDate === 'now' || defaultDate === 'moment') {
					defaultDate = getMoment();
				} else {
					defaultDate = getMoment(defaultDate);
				}
			}

			var parsedDate = parseInputDate(defaultDate);
			if (!parsedDate.isValid()) {
				throw new TypeError('defaultDate() Could not parse date parameter: ' + defaultDate);
			}
			if (!isValid(parsedDate)) {
				throw new TypeError('defaultDate() date passed is invalid according to component setup validations');
			}

			options.defaultDate = parsedDate;

			if ((options.defaultDate && options.inline) || input.val().trim() === '') {
				setValue(options.defaultDate);
			}
			return picker;
		};

		picker.locale = function (locale) {
			if (arguments.length === 0) {
				return options.locale;
			}

			if (!moment.localeData(locale)) {
				throw new TypeError('locale() locale ' + locale + ' is not loaded from moment locales!');
			}

			options.locale = locale;
			date.locale(options.locale);
			viewDate.locale(options.locale);

			if (actualFormat) {
				initFormatting(); // reinit formatting
			}
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.stepping = function (stepping) {
			if (arguments.length === 0) {
				return options.stepping;
			}

			stepping = parseInt(stepping, 10);
			if (isNaN(stepping) || stepping < 1) {
				stepping = 1;
			}
			options.stepping = stepping;
			return picker;
		};

		picker.useCurrent = function (useCurrent) {
			var useCurrentOptions = ['year', 'month', 'day', 'hour', 'minute'];
			if (arguments.length === 0) {
				return options.useCurrent;
			}

			if ((typeof useCurrent !== 'boolean') && (typeof useCurrent !== 'string')) {
				throw new TypeError('useCurrent() expects a boolean or string parameter');
			}
			if (typeof useCurrent === 'string' && useCurrentOptions.indexOf(useCurrent.toLowerCase()) === -1) {
				throw new TypeError('useCurrent() expects a string parameter of ' + useCurrentOptions.join(', '));
			}
			options.useCurrent = useCurrent;
			return picker;
		};

		picker.collapse = function (collapse) {
			if (arguments.length === 0) {
				return options.collapse;
			}

			if (typeof collapse !== 'boolean') {
				throw new TypeError('collapse() expects a boolean parameter');
			}
			if (options.collapse === collapse) {
				return picker;
			}
			options.collapse = collapse;
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.icons = function (icons) {
			if (arguments.length === 0) {
				return $.extend({}, options.icons);
			}

			if (!(icons instanceof Object)) {
				throw new TypeError('icons() expects parameter to be an Object');
			}
			$.extend(options.icons, icons);
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.tooltips = function (tooltips) {
			if (arguments.length === 0) {
				return $.extend({}, options.tooltips);
			}

			if (!(tooltips instanceof Object)) {
				throw new TypeError('tooltips() expects parameter to be an Object');
			}
			$.extend(options.tooltips, tooltips);
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.useStrict = function (useStrict) {
			if (arguments.length === 0) {
				return options.useStrict;
			}

			if (typeof useStrict !== 'boolean') {
				throw new TypeError('useStrict() expects a boolean parameter');
			}
			options.useStrict = useStrict;
			return picker;
		};

		picker.sideBySide = function (sideBySide) {
			if (arguments.length === 0) {
				return options.sideBySide;
			}

			if (typeof sideBySide !== 'boolean') {
				throw new TypeError('sideBySide() expects a boolean parameter');
			}
			options.sideBySide = sideBySide;
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.viewMode = function (viewMode) {
			if (arguments.length === 0) {
				return options.viewMode;
			}

			if (typeof viewMode !== 'string') {
				throw new TypeError('viewMode() expects a string parameter');
			}

			if (viewModes.indexOf(viewMode) === -1) {
				throw new TypeError('viewMode() parameter must be one of (' + viewModes.join(', ') + ') value');
			}

			options.viewMode = viewMode;
			currentViewMode = Math.max(viewModes.indexOf(viewMode), minViewModeNumber);

			showMode();
			return picker;
		};

		picker.toolbarPlacement = function (toolbarPlacement) {
			if (arguments.length === 0) {
				return options.toolbarPlacement;
			}

			if (typeof toolbarPlacement !== 'string') {
				throw new TypeError('toolbarPlacement() expects a string parameter');
			}
			if (toolbarPlacements.indexOf(toolbarPlacement) === -1) {
				throw new TypeError('toolbarPlacement() parameter must be one of (' + toolbarPlacements.join(', ') + ') value');
			}
			options.toolbarPlacement = toolbarPlacement;

			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.widgetPositioning = function (widgetPositioning) {
			if (arguments.length === 0) {
				return $.extend({}, options.widgetPositioning);
			}

			if (({}).toString.call(widgetPositioning) !== '[object Object]') {
				throw new TypeError('widgetPositioning() expects an object variable');
			}
			if (widgetPositioning.horizontal) {
				if (typeof widgetPositioning.horizontal !== 'string') {
					throw new TypeError('widgetPositioning() horizontal variable must be a string');
				}
				widgetPositioning.horizontal = widgetPositioning.horizontal.toLowerCase();
				if (horizontalModes.indexOf(widgetPositioning.horizontal) === -1) {
					throw new TypeError('widgetPositioning() expects horizontal parameter to be one of (' + horizontalModes.join(', ') + ')');
				}
				options.widgetPositioning.horizontal = widgetPositioning.horizontal;
			}
			if (widgetPositioning.vertical) {
				if (typeof widgetPositioning.vertical !== 'string') {
					throw new TypeError('widgetPositioning() vertical variable must be a string');
				}
				widgetPositioning.vertical = widgetPositioning.vertical.toLowerCase();
				if (verticalModes.indexOf(widgetPositioning.vertical) === -1) {
					throw new TypeError('widgetPositioning() expects vertical parameter to be one of (' + verticalModes.join(', ') + ')');
				}
				options.widgetPositioning.vertical = widgetPositioning.vertical;
			}
			update();
			return picker;
		};

		picker.calendarWeeks = function (calendarWeeks) {
			if (arguments.length === 0) {
				return options.calendarWeeks;
			}

			if (typeof calendarWeeks !== 'boolean') {
				throw new TypeError('calendarWeeks() expects parameter to be a boolean value');
			}

			options.calendarWeeks = calendarWeeks;
			update();
			return picker;
		};

		picker.showTodayButton = function (showTodayButton) {
			if (arguments.length === 0) {
				return options.showTodayButton;
			}

			if (typeof showTodayButton !== 'boolean') {
				throw new TypeError('showTodayButton() expects a boolean parameter');
			}

			options.showTodayButton = showTodayButton;
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.showClear = function (showClear) {
			if (arguments.length === 0) {
				return options.showClear;
			}

			if (typeof showClear !== 'boolean') {
				throw new TypeError('showClear() expects a boolean parameter');
			}

			options.showClear = showClear;
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.widgetParent = function (widgetParent) {
			if (arguments.length === 0) {
				return options.widgetParent;
			}

			if (typeof widgetParent === 'string') {
				widgetParent = $(widgetParent);
			}

			if (widgetParent !== null && (typeof widgetParent !== 'string' && !(widgetParent instanceof $))) {
				throw new TypeError('widgetParent() expects a string or a jQuery object parameter');
			}

			options.widgetParent = widgetParent;
			if (widget) {
				hide();
				show();
			}
			return picker;
		};

		picker.keepOpen = function (keepOpen) {
			if (arguments.length === 0) {
				return options.keepOpen;
			}

			if (typeof keepOpen !== 'boolean') {
				throw new TypeError('keepOpen() expects a boolean parameter');
			}

			options.keepOpen = keepOpen;
			return picker;
		};

		picker.focusOnShow = function (focusOnShow) {
			if (arguments.length === 0) {
				return options.focusOnShow;
			}

			if (typeof focusOnShow !== 'boolean') {
				throw new TypeError('focusOnShow() expects a boolean parameter');
			}

			options.focusOnShow = focusOnShow;
			return picker;
		};

		picker.inline = function (inline) {
			if (arguments.length === 0) {
				return options.inline;
			}

			if (typeof inline !== 'boolean') {
				throw new TypeError('inline() expects a boolean parameter');
			}

			options.inline = inline;
			return picker;
		};

		picker.clear = function () {
			clear();
			return picker;
		};

		picker.keyBinds = function (keyBinds) {
			if (arguments.length === 0) {
				return options.keyBinds;
			}

			options.keyBinds = keyBinds;
			return picker;
		};

		picker.getMoment = function (d) {
			return getMoment(d);
		};

		picker.debug = function (debug) {
			if (typeof debug !== 'boolean') {
				throw new TypeError('debug() expects a boolean parameter');
			}

			options.debug = debug;
			return picker;
		};

		picker.allowInputToggle = function (allowInputToggle) {
			if (arguments.length === 0) {
				return options.allowInputToggle;
			}

			if (typeof allowInputToggle !== 'boolean') {
				throw new TypeError('allowInputToggle() expects a boolean parameter');
			}

			options.allowInputToggle = allowInputToggle;
			return picker;
		};

		picker.showClose = function (showClose) {
			if (arguments.length === 0) {
				return options.showClose;
			}

			if (typeof showClose !== 'boolean') {
				throw new TypeError('showClose() expects a boolean parameter');
			}

			options.showClose = showClose;
			return picker;
		};

		picker.keepInvalid = function (keepInvalid) {
			if (arguments.length === 0) {
				return options.keepInvalid;
			}

			if (typeof keepInvalid !== 'boolean') {
				throw new TypeError('keepInvalid() expects a boolean parameter');
			}
			options.keepInvalid = keepInvalid;
			return picker;
		};

		picker.datepickerInput = function (datepickerInput) {
			if (arguments.length === 0) {
				return options.datepickerInput;
			}

			if (typeof datepickerInput !== 'string') {
				throw new TypeError('datepickerInput() expects a string parameter');
			}

			options.datepickerInput = datepickerInput;
			return picker;
		};

		picker.parseInputDate = function (parseInputDate) {
			if (arguments.length === 0) {
				return options.parseInputDate;
			}

			if (typeof parseInputDate !== 'function') {
				throw new TypeError('parseInputDate() sholud be as function');
			}

			options.parseInputDate = parseInputDate;

			return picker;
		};

		picker.disabledTimeIntervals = function (disabledTimeIntervals) {
			///<signature helpKeyword="$.fn.datetimepicker.disabledTimeIntervals">
			///<summary>Returns an array with the currently set disabled dates on the component.</summary>
			///<returns type="array">options.disabledTimeIntervals</returns>
			///</signature>
			///<signature>
			///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
			///options.enabledDates if such exist.</summary>
			///<param name="dates" locid="$.fn.datetimepicker.disabledTimeIntervals_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
			///</signature>
			if (arguments.length === 0) {
				return (options.disabledTimeIntervals ? $.extend({}, options.disabledTimeIntervals) : options.disabledTimeIntervals);
			}

			if (!disabledTimeIntervals) {
				options.disabledTimeIntervals = false;
				update();
				return picker;
			}
			if (!(disabledTimeIntervals instanceof Array)) {
				throw new TypeError('disabledTimeIntervals() expects an array parameter');
			}
			options.disabledTimeIntervals = disabledTimeIntervals;
			update();
			return picker;
		};

		picker.disabledHours = function (hours) {
			///<signature helpKeyword="$.fn.datetimepicker.disabledHours">
			///<summary>Returns an array with the currently set disabled hours on the component.</summary>
			///<returns type="array">options.disabledHours</returns>
			///</signature>
			///<signature>
			///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
			///options.enabledHours if such exist.</summary>
			///<param name="hours" locid="$.fn.datetimepicker.disabledHours_p:hours">Takes an [ int ] of values and disallows the user to select only from those hours.</param>
			///</signature>
			if (arguments.length === 0) {
				return (options.disabledHours ? $.extend({}, options.disabledHours) : options.disabledHours);
			}

			if (!hours) {
				options.disabledHours = false;
				update();
				return picker;
			}
			if (!(hours instanceof Array)) {
				throw new TypeError('disabledHours() expects an array parameter');
			}
			options.disabledHours = indexGivenHours(hours);
			options.enabledHours = false;
			if (options.useCurrent && !options.keepInvalid) {
				var tries = 0;
				while (!isValid(date, 'h')) {
					date.add(1, 'h');
					if (tries === 24) {
						throw 'Tried 24 times to find a valid date';
					}
					tries++;
				}
				setValue(date);
			}
			update();
			return picker;
		};

		picker.enabledHours = function (hours) {
			///<signature helpKeyword="$.fn.datetimepicker.enabledHours">
			///<summary>Returns an array with the currently set enabled hours on the component.</summary>
			///<returns type="array">options.enabledHours</returns>
			///</signature>
			///<signature>
			///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of options.disabledHours if such exist.</summary>
			///<param name="hours" locid="$.fn.datetimepicker.enabledHours_p:hours">Takes an [ int ] of values and allows the user to select only from those hours.</param>
			///</signature>
			if (arguments.length === 0) {
				return (options.enabledHours ? $.extend({}, options.enabledHours) : options.enabledHours);
			}

			if (!hours) {
				options.enabledHours = false;
				update();
				return picker;
			}
			if (!(hours instanceof Array)) {
				throw new TypeError('enabledHours() expects an array parameter');
			}
			options.enabledHours = indexGivenHours(hours);
			options.disabledHours = false;
			if (options.useCurrent && !options.keepInvalid) {
				var tries = 0;
				while (!isValid(date, 'h')) {
					date.add(1, 'h');
					if (tries === 24) {
						throw 'Tried 24 times to find a valid date';
					}
					tries++;
				}
				setValue(date);
			}
			update();
			return picker;
		};
		/**
		 * Returns the component's model current viewDate, a moment object or null if not set. Passing a null value unsets the components model current moment. Parsing of the newDate parameter is made using moment library with the options.format and options.useStrict components configuration.
		 * @param {Takes string, viewDate, moment, null parameter.} newDate
		 * @returns {viewDate.clone()}
		 */
		picker.viewDate = function (newDate) {
			if (arguments.length === 0) {
				return viewDate.clone();
			}

			if (!newDate) {
				viewDate = date.clone();
				return picker;
			}

			if (typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
				throw new TypeError('viewDate() parameter must be one of [string, moment or Date]');
			}

			viewDate = parseInputDate(newDate);
			viewUpdate();
			return picker;
		};

		// initializing element and component attributes
		if (element.is('input')) {
			input = element;
		} else {
			input = element.find(options.datepickerInput);
			if (input.length === 0) {
				input = element.find('input');
			} else if (!input.is('input')) {
				throw new Error('CSS class "' + options.datepickerInput + '" cannot be applied to non input element');
			}
		}

		if (element.hasClass('input-group')) {
			// in case there is more then one 'input-group-addon' Issue #48
			if (element.find('.datepickerbutton').length === 0) {
				component = element.find('.input-group-addon');
			} else {
				component = element.find('.datepickerbutton');
			}
		}

		if (!options.inline && !input.is('input')) {
			throw new Error('Could not initialize DateTimePicker without an input element');
		}

		// Set defaults for date here now instead of in var declaration
		date = getMoment();
		viewDate = date.clone();

		$.extend(true, options, dataToOptions());

		picker.options(options);

		initFormatting();

		attachDatePickerElementEvents();

		if (input.prop('disabled')) {
			picker.disable();
		}
		if (input.is('input') && input.val().trim().length !== 0) {
			setValue(parseInputDate(input.val().trim()));
		}
		else if (options.defaultDate && input.attr('placeholder') === undefined) {
			setValue(options.defaultDate);
		}
		if (options.inline) {
			show();
		}
		return picker;
	};

	/********************************************************************************
	 *
	 * jQuery plugin constructor and defaults object
	 *
	 ********************************************************************************/

	/**
	 * See (http://jquery.com/).
	 * @name jQuery
	 * @class
	 * See the jQuery Library  (http://jquery.com/) for full details.  This just
	 * documents the function and classes that are added to jQuery by this plug-in.
	 */
	/**
	 * See (http://jquery.com/)
	 * @name fn
	 * @class
	 * See the jQuery Library  (http://jquery.com/) for full details.  This just
	 * documents the function and classes that are added to jQuery by this plug-in.
	 * @memberOf jQuery
	 */
	/**
	 * Show comments
	 * @class datetimepicker
	 * @memberOf jQuery.fn
	 */
	$.fn.datetimepicker = function (options) {
		options = options || {};

		var args = Array.prototype.slice.call(arguments, 1),
			isInstance = true,
			thisMethods = ['destroy', 'hide', 'show', 'toggle'],
			returnValue;

		if (typeof options === 'object') {
			return this.each(function () {
				var $this = $(this),
					_options;
				if (!$this.data('DateTimePicker')) {
					// create a private copy of the defaults object
					_options = $.extend(true, {}, $.fn.datetimepicker.defaults, options);
					$this.data('DateTimePicker', dateTimePicker($this, _options));
				}
			});
		} else if (typeof options === 'string') {
			this.each(function () {
				var $this = $(this),
					instance = $this.data('DateTimePicker');
				if (!instance) {
					throw new Error('bootstrap-datetimepicker("' + options + '") method was called on an element that is not using DateTimePicker');
				}

				returnValue = instance[options].apply(instance, args);
				isInstance = returnValue === instance;
			});

			if (isInstance || $.inArray(options, thisMethods) > -1) {
				return this;
			}

			return returnValue;
		}

		throw new TypeError('Invalid arguments for DateTimePicker: ' + options);
	};

	$.fn.datetimepicker.defaults = {
		timeZone: '',
		format: false,
		dayViewHeaderFormat: 'MMMM YYYY',
		extraFormats: false,
		stepping: 1,
		minDate: false,
		maxDate: false,
		useCurrent: true,
		collapse: true,
		locale: moment.locale(),
		defaultDate: false,
		disabledDates: false,
		enabledDates: false,
		icons: {
			time: 'glyphicon glyphicon-time',
			date: 'glyphicon glyphicon-calendar',
			up: 'glyphicon glyphicon-chevron-up',
			down: 'glyphicon glyphicon-chevron-down',
			previous: 'glyphicon glyphicon-chevron-left',
			next: 'glyphicon glyphicon-chevron-right',
			today: 'glyphicon glyphicon-screenshot',
			clear: 'glyphicon glyphicon-trash',
			close: 'glyphicon glyphicon-remove'
		},
		tooltips: {
			today: 'Go to today',
			clear: 'Clear selection',
			close: 'Close the picker',
			selectMonth: 'Select Month',
			prevMonth: 'Previous Month',
			nextMonth: 'Next Month',
			selectYear: 'Select Year',
			prevYear: 'Previous Year',
			nextYear: 'Next Year',
			selectDecade: 'Select Decade',
			prevDecade: 'Previous Decade',
			nextDecade: 'Next Decade',
			prevCentury: 'Previous Century',
			nextCentury: 'Next Century',
			pickHour: 'Pick Hour',
			incrementHour: 'Increment Hour',
			decrementHour: 'Decrement Hour',
			pickMinute: 'Pick Minute',
			incrementMinute: 'Increment Minute',
			decrementMinute: 'Decrement Minute',
			pickSecond: 'Pick Second',
			incrementSecond: 'Increment Second',
			decrementSecond: 'Decrement Second',
			togglePeriod: 'Toggle Period',
			selectTime: 'Select Time'
		},
		useStrict: false,
		sideBySide: false,
		daysOfWeekDisabled: false,
		calendarWeeks: false,
		viewMode: 'days',
		toolbarPlacement: 'default',
		showTodayButton: false,
		showClear: false,
		showClose: false,
		widgetPositioning: {
			horizontal: 'auto',
			vertical: 'auto'
		},
		widgetParent: null,
		ignoreReadonly: false,
		keepOpen: false,
		focusOnShow: true,
		inline: false,
		keepInvalid: false,
		datepickerInput: '.datepickerinput',
		keyBinds: {
			up: function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().subtract(7, 'd'));
				} else {
					this.date(d.clone().add(this.stepping(), 'm'));
				}
			},
			down: function (widget) {
				if (!widget) {
					this.show();
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().add(7, 'd'));
				} else {
					this.date(d.clone().subtract(this.stepping(), 'm'));
				}
			},
			'control up': function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().subtract(1, 'y'));
				} else {
					this.date(d.clone().add(1, 'h'));
				}
			},
			'control down': function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().add(1, 'y'));
				} else {
					this.date(d.clone().subtract(1, 'h'));
				}
			},
			left: function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().subtract(1, 'd'));
				}
			},
			right: function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().add(1, 'd'));
				}
			},
			pageUp: function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().subtract(1, 'M'));
				}
			},
			pageDown: function (widget) {
				if (!widget) {
					return;
				}
				var d = this.date() || this.getMoment();
				if (widget.find('.datepicker').is(':visible')) {
					this.date(d.clone().add(1, 'M'));
				}
			},
			enter: function () {
				this.hide();
			},
			escape: function () {
				this.hide();
			},
			//tab: function (widget) { //this break the flow of the form. disabling for now
			//    var toggle = widget.find('.picker-switch a[data-action="togglePicker"]');
			//    if(toggle.length > 0) toggle.click();
			//},
			'control space': function (widget) {
				if (!widget) {
					return;
				}
				if (widget.find('.timepicker').is(':visible')) {
					widget.find('.btn[data-action="togglePeriod"]').click();
				}
			},
			t: function () {
				this.date(this.getMoment());
			},
			'delete': function () {
				this.clear();
			}
		},
		debug: false,
		allowInputToggle: false,
		disabledTimeIntervals: false,
		disabledHours: false,
		enabledHours: false,
		viewDate: false
	};

	return $.fn.datetimepicker;
}));
/*
This file is part of SMAP.

SMAP is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

SMAP is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

*/


/*
 * The description should always be encoded / not used as html therefore do not encode
 */
function getDisplayDescription(fn, reportType, survey, question, group, option, qtype, 
		date_question, start, end, interval, units, filter) {
	
	var txt = [],
		idx = -1,
		msg;

	if(typeof question === "undefined" || question === "None") {
		txt[++idx] = localise.set["a_dd_sl"];
	} else {
		if(reportType === "map") {
			if(fn === "ocha") {
				msg = localise.set["a_dd_ocha_map"];
			} else if(fn === "percent") {
				msg = localise.set["a_dd_percent_map"];
			} else if(fn === "average") {
				msg = localise.set["a_dd_average_map"];
			} else if(fn === "count") {
				msg = localise.set["a_dd_count_map"];
			} else if(fn === "total") {
				msg = localise.set["a_dd_total_map"];
			} else if(fn === "none") {
				msg = localise.set["a_dd_none_map"];
			}
			msg = msg.replace('%s1', option);
		} else {
			if(fn === "ocha") {
				msg = localise.set["a_dd_ocha_table"];
			} else if(fn === "percent") {
				msg = localise.set["a_dd_percent_table"];
			} else if(fn === "average") {
				msg = localise.set["a_dd_average_table"];
			} else if(fn === "count") {
				msg = localise.set["a_dd_count_table"];
			} else if(fn === "total") {
				msg = localise.set["a_dd_total_table"];
			} else if(fn === "none") {
				msg = localise.set["a_dd_none_table"];
			}

		}
		msg = msg.replace('%s2', question);
		msg = msg.replace('%s3', survey);
		txt[++idx] = msg;
	}

	
	if(units) {
		msg = localise.set["a_dd_units"];
		msg = msg.replace("%s1", units);
		txt[++idx] = ' ';
		txt[++idx] = msg;
	}

	if(typeof group !== "undefined") {
		if(typeof interval !== "undefined") {
			msg = localise.set["a_dd_group_interval"];
			msg = msg.replace("%s2", interval);
		} else {
			msg = localise.set["a_dd_group"];
		}
		msg = msg.replace("%s1", group);
		txt[++idx] = ' ';
		txt[++idx] = msg;
	} else if(typeof interval !== "undefined"){
		msg = localise.set["a_dd_interval"];
		msg = msg.replace("%s1", interval);
		txt[++idx] = ' ';
		txt[++idx] = msg;
	}
	
	if(typeof end === "undefined") {
		end = ""
	}
	if(typeof date_question !== "undefined" && typeof start !== "undefined") {
		txt[++idx] = " (";
		txt[++idx] = date_question;
		txt[++idx] = ": ";
		txt[++idx] = start;
		txt[++idx] = " - ";
		txt[++idx] = end;
		txt[++idx] = ")";
	}

	// Add filter
	if(filter) {
		var filterObj = JSON.parse(filter);
		msg = localise.set["a_dd_where"];
		msg.replace("%s1", filterObj.qName);
		msg.replace("%s2", filterObj.value);
		txt[++idx] = ' ';
		txt[++idx] = msg;

	}
	
	return txt.join('');
}

/*
 * Add html references to media files
 * Return all properties as an Array
 * Deprecate this approach and progressively replace with processMedia()
 */
function addAnchors (property, minsize) {
	var output = [],
		media,
		i,
		style = '';

	if(property && typeof property.type !== "undefined") {
		// Geospatial
		return [ property.coordinates ];

	}

	if( Object.prototype.toString.call(property) !== '[object Array]' ) {
		property = [ property ];
	}
	
	for(i = 0; i < property.length; i++) {
	    media = getMedia(property[i]);
	    
	    if(typeof media !== "undefined") {  // Add links to media files
			if(media.supported) {
                if (media.type === "audio") {
                    if (minsize) {
                        style = ' style="width:75px;"';
                    }
                    output[i] = '<audio controls' + style + '><source src="' + media.url
                        + '" type="' + media.source_type + '"/>'
                        + 'Your browser does not support this audio type'
                        + '</audio>';
                } else if (media.type === "video") {
                    if (minsize) {
                        style = ' style="width:100px;"';
                    }
                    output[i] = '<video controls' + style +
                        (minsize ? 'width="75px" height="100px"' : '')
                        + '><source src="' + media.url
                        + '" type="' + media.source_type + '">'
                        + 'Your browser does not support this video type'
                        + '</video>';
                } else {
                    style = (media.thumbNail == '/fieldAnalysis/img/link.png') ? "width:32px;" : "width:100%;";
                    output[i] = '<a href="' + media.url
                        + '" target="_blank"><img style="' + style + '" src="'
                        + (minsize ? media.thumbNail : media.url)
						+ '" alt="Picture"></a>';
                }
            } else {
                output[i] = '<a href="' + media.url
                    + '" download style="color:#0000FF;">' + localise.set["c_download"] + '</a>';
			}
	
		} else {
		    if (typeof property[i] === "object") {      // From: https://stackoverflow.com/questions/11182924/how-to-check-if-javascript-object-is-json
				output[i] = JSON.stringify(property[i]);
				if(output[i] === "{}") {
					output[i] = "";
				}
		    } else {
			    output[i] = property[i];
		    }

		}
	} 
	
	return output;
	
}

/*
 * Get an object with the media details for the property
 */
function getMedia(property) {
	
	var idx, name, ext, urlBase, thumbNail, type,
		media;
	
	if(typeof property === "string" && (property.indexOf("//") === 0 || property.indexOf("http") === 0)) {  // Add links to media files
		
		if(property.indexOf("//") === 0) {
			property = "https:" + property;
		}
		// Get name, type, urlBase and thumbName from the input url

		idx = property.lastIndexOf("/");
		name = property.substring(idx+1);
		urlBase = property.substring(0, idx+1);
		idx = name.lastIndexOf(".");
		ext = name.substring(idx+1).toLowerCase();
		thumbNail = urlBase + "thumbs/" + name + ".jpg";
		
		// Create a media object
		media = {};
		media.name = name;
		media.supported = true;
		if(ext === "jpg" || ext === "png" || ext === "gif" || ext === "jpeg" || ext === "ico") {
			media.type = "image";
			media.url = property; 
			media.thumbNail = thumbNail;
		} else if(ext === "mp4" || ext === "3gp" || ext === "flv" || ext === "m4p" || ext === "mov") {
            if(ext == "mp4") {
                media.source_type = "video/mp4";
            } else  if(ext == "3gp") {
                media.supported = false;
                media.source_type = "video/3gp";
            } else  if(ext == "flv") {
                media.supported = false;
                media.source_type = "video/x-flv";
            } else  if(ext == "mov") {
                media.supported = false;
                media.source_type = "video/quicktime";
            }
			media.type = "video";
			media.url = property;
			media.thumbNail = thumbNail;
		} else if(ext === "mp3" || ext === "amr" || ext === "3ga" || ext === "m4a" || ext === "ogg" || ext === "wav") {
			if(ext == "m4a") {
				media.source_type = "audio/mp4";
			} else if(ext == "mp3") {
                media.source_type = "audio/mp3";
            } else if(ext == "amr") {
				media.supported = false;
                media.source_type = "audio/amr";
            } else if(ext == "ogg") {
                media.source_type = "audio/ogg";
            } else if(ext == "wav") {
                media.source_type = "audio/wav";
            }
			media.type = "audio";
			media.url = property;		// Don't convert audio files
			media.thumbNail = "/app/fieldAnalysis/img/audio-icon.png"
		} else {
			media.type = "unknown";
			media.url = property; 
			media.thumbNail = "/app/fieldAnalysis/img/link.png"
		}


	}
	
	return media;
		
};
define("crf", function(){});

/*! jquery-qrcode v0.14.0 - https://larsjung.de/jquery-qrcode/ */
!function(r){"use strict";function t(t,e,n,o){function a(r,t){return r-=o,t-=o,0>r||r>=c||0>t||t>=c?!1:f.isDark(r,t)}function i(r,t,e,n){var o=u.isDark,a=1/l;u.isDark=function(i,u){var f=u*a,c=i*a,l=f+a,g=c+a;return o(i,u)&&(r>l||f>e||t>g||c>n)}}var u={},f=r(n,e);f.addData(t),f.make(),o=o||0;var c=f.getModuleCount(),l=f.getModuleCount()+2*o;return u.text=t,u.level=e,u.version=n,u.moduleCount=l,u.isDark=a,u.addBlank=i,u}function e(r,e,n,o,a){n=Math.max(1,n||1),o=Math.min(40,o||40);for(var i=n;o>=i;i+=1)try{return t(r,e,i,a)}catch(u){}}function n(r,t,e){var n=e.size,o="bold "+e.mSize*n+"px "+e.fontname,a=w("<canvas/>")[0].getContext("2d");a.font=o;var i=a.measureText(e.label).width,u=e.mSize,f=i/n,c=(1-f)*e.mPosX,l=(1-u)*e.mPosY,g=c+f,s=l+u,v=.01;1===e.mode?r.addBlank(0,l-v,n,s+v):r.addBlank(c-v,l-v,g+v,s+v),t.fillStyle=e.fontcolor,t.font=o,t.fillText(e.label,c*n,l*n+.75*e.mSize*n)}function o(r,t,e){var n=e.size,o=e.image.naturalWidth||1,a=e.image.naturalHeight||1,i=e.mSize,u=i*o/a,f=(1-u)*e.mPosX,c=(1-i)*e.mPosY,l=f+u,g=c+i,s=.01;3===e.mode?r.addBlank(0,c-s,n,g+s):r.addBlank(f-s,c-s,l+s,g+s),t.drawImage(e.image,f*n,c*n,u*n,i*n)}function a(r,t,e){w(e.background).is("img")?t.drawImage(e.background,0,0,e.size,e.size):e.background&&(t.fillStyle=e.background,t.fillRect(e.left,e.top,e.size,e.size));var a=e.mode;1===a||2===a?n(r,t,e):(3===a||4===a)&&o(r,t,e)}function i(r,t,e,n,o,a,i,u){r.isDark(i,u)&&t.rect(n,o,a,a)}function u(r,t,e,n,o,a,i,u,f,c){i?r.moveTo(t+a,e):r.moveTo(t,e),u?(r.lineTo(n-a,e),r.arcTo(n,e,n,o,a)):r.lineTo(n,e),f?(r.lineTo(n,o-a),r.arcTo(n,o,t,o,a)):r.lineTo(n,o),c?(r.lineTo(t+a,o),r.arcTo(t,o,t,e,a)):r.lineTo(t,o),i?(r.lineTo(t,e+a),r.arcTo(t,e,n,e,a)):r.lineTo(t,e)}function f(r,t,e,n,o,a,i,u,f,c){i&&(r.moveTo(t+a,e),r.lineTo(t,e),r.lineTo(t,e+a),r.arcTo(t,e,t+a,e,a)),u&&(r.moveTo(n-a,e),r.lineTo(n,e),r.lineTo(n,e+a),r.arcTo(n,e,n-a,e,a)),f&&(r.moveTo(n-a,o),r.lineTo(n,o),r.lineTo(n,o-a),r.arcTo(n,o,n-a,o,a)),c&&(r.moveTo(t+a,o),r.lineTo(t,o),r.lineTo(t,o-a),r.arcTo(t,o,t+a,o,a))}function c(r,t,e,n,o,a,i,c){var l=r.isDark,g=n+a,s=o+a,v=e.radius*a,h=i-1,d=i+1,w=c-1,m=c+1,y=l(i,c),T=l(h,w),p=l(h,c),B=l(h,m),A=l(i,m),E=l(d,m),k=l(d,c),M=l(d,w),C=l(i,w);y?u(t,n,o,g,s,v,!p&&!C,!p&&!A,!k&&!A,!k&&!C):f(t,n,o,g,s,v,p&&C&&T,p&&A&&B,k&&A&&E,k&&C&&M)}function l(r,t,e){var n,o,a=r.moduleCount,u=e.size/a,f=i;for(e.radius>0&&e.radius<=.5&&(f=c),t.beginPath(),n=0;a>n;n+=1)for(o=0;a>o;o+=1){var l=e.left+o*u,g=e.top+n*u,s=u;f(r,t,e,l,g,s,n,o)}if(w(e.fill).is("img")){t.strokeStyle="rgba(0,0,0,0.5)",t.lineWidth=2,t.stroke();var v=t.globalCompositeOperation;t.globalCompositeOperation="destination-out",t.fill(),t.globalCompositeOperation=v,t.clip(),t.drawImage(e.fill,0,0,e.size,e.size),t.restore()}else t.fillStyle=e.fill,t.fill()}function g(r,t){var n=e(t.text,t.ecLevel,t.minVersion,t.maxVersion,t.quiet);if(!n)return null;var o=w(r).data("qrcode",n),i=o[0].getContext("2d");return a(n,i,t),l(n,i,t),o}function s(r){var t=w("<canvas/>").attr("width",r.size).attr("height",r.size);return g(t,r)}function v(r){return w("<img/>").attr("src",s(r)[0].toDataURL("image/png"))}function h(r){var t=e(r.text,r.ecLevel,r.minVersion,r.maxVersion,r.quiet);if(!t)return null;var n,o,a=r.size,i=r.background,u=Math.floor,f=t.moduleCount,c=u(a/f),l=u(.5*(a-c*f)),g={position:"relative",left:0,top:0,padding:0,margin:0,width:a,height:a},s={position:"absolute",padding:0,margin:0,width:c,height:c,"background-color":r.fill},v=w("<div/>").data("qrcode",t).css(g);for(i&&v.css("background-color",i),n=0;f>n;n+=1)for(o=0;f>o;o+=1)t.isDark(n,o)&&w("<div/>").css(s).css({left:l+o*c,top:l+n*c}).appendTo(v);return v}function d(r){return m&&"canvas"===r.render?s(r):m&&"image"===r.render?v(r):h(r)}var w=window.jQuery,m=function(){var r=document.createElement("canvas");return!(!r.getContext||!r.getContext("2d"))}(),y={render:"canvas",minVersion:1,maxVersion:40,ecLevel:"L",left:0,top:0,size:200,fill:"#000",background:null,text:"no text",radius:0,quiet:0,mode:0,mSize:.1,mPosX:.5,mPosY:.5,label:"no label",fontname:"sans",fontcolor:"#000",image:null};w.fn.qrcode=function(r){var t=w.extend({},y,r);return this.each(function(r,e){"canvas"===e.nodeName.toLowerCase()?g(e,t):w(e).append(d(t))})}}(function(){var r=function(){function r(t,e){if("undefined"==typeof t.length)throw new Error(t.length+"/"+e);var n=function(){for(var r=0;r<t.length&&0==t[r];)r+=1;for(var n=new Array(t.length-r+e),o=0;o<t.length-r;o+=1)n[o]=t[o+r];return n}(),o={};return o.getAt=function(r){return n[r]},o.getLength=function(){return n.length},o.multiply=function(t){for(var e=new Array(o.getLength()+t.getLength()-1),n=0;n<o.getLength();n+=1)for(var a=0;a<t.getLength();a+=1)e[n+a]^=i.gexp(i.glog(o.getAt(n))+i.glog(t.getAt(a)));return r(e,0)},o.mod=function(t){if(o.getLength()-t.getLength()<0)return o;for(var e=i.glog(o.getAt(0))-i.glog(t.getAt(0)),n=new Array(o.getLength()),a=0;a<o.getLength();a+=1)n[a]=o.getAt(a);for(var a=0;a<t.getLength();a+=1)n[a]^=i.gexp(i.glog(t.getAt(a))+e);return r(n,0).mod(t)},o}var t=function(t,e){var o=236,i=17,l=t,g=n[e],s=null,v=0,d=null,w=new Array,m={},y=function(r,t){v=4*l+17,s=function(r){for(var t=new Array(r),e=0;r>e;e+=1){t[e]=new Array(r);for(var n=0;r>n;n+=1)t[e][n]=null}return t}(v),T(0,0),T(v-7,0),T(0,v-7),A(),B(),k(r,t),l>=7&&E(r),null==d&&(d=D(l,g,w)),M(d,t)},T=function(r,t){for(var e=-1;7>=e;e+=1)if(!(-1>=r+e||r+e>=v))for(var n=-1;7>=n;n+=1)-1>=t+n||t+n>=v||(e>=0&&6>=e&&(0==n||6==n)||n>=0&&6>=n&&(0==e||6==e)||e>=2&&4>=e&&n>=2&&4>=n?s[r+e][t+n]=!0:s[r+e][t+n]=!1)},p=function(){for(var r=0,t=0,e=0;8>e;e+=1){y(!0,e);var n=a.getLostPoint(m);(0==e||r>n)&&(r=n,t=e)}return t},B=function(){for(var r=8;v-8>r;r+=1)null==s[r][6]&&(s[r][6]=r%2==0);for(var t=8;v-8>t;t+=1)null==s[6][t]&&(s[6][t]=t%2==0)},A=function(){for(var r=a.getPatternPosition(l),t=0;t<r.length;t+=1)for(var e=0;e<r.length;e+=1){var n=r[t],o=r[e];if(null==s[n][o])for(var i=-2;2>=i;i+=1)for(var u=-2;2>=u;u+=1)-2==i||2==i||-2==u||2==u||0==i&&0==u?s[n+i][o+u]=!0:s[n+i][o+u]=!1}},E=function(r){for(var t=a.getBCHTypeNumber(l),e=0;18>e;e+=1){var n=!r&&1==(t>>e&1);s[Math.floor(e/3)][e%3+v-8-3]=n}for(var e=0;18>e;e+=1){var n=!r&&1==(t>>e&1);s[e%3+v-8-3][Math.floor(e/3)]=n}},k=function(r,t){for(var e=g<<3|t,n=a.getBCHTypeInfo(e),o=0;15>o;o+=1){var i=!r&&1==(n>>o&1);6>o?s[o][8]=i:8>o?s[o+1][8]=i:s[v-15+o][8]=i}for(var o=0;15>o;o+=1){var i=!r&&1==(n>>o&1);8>o?s[8][v-o-1]=i:9>o?s[8][15-o-1+1]=i:s[8][15-o-1]=i}s[v-8][8]=!r},M=function(r,t){for(var e=-1,n=v-1,o=7,i=0,u=a.getMaskFunction(t),f=v-1;f>0;f-=2)for(6==f&&(f-=1);;){for(var c=0;2>c;c+=1)if(null==s[n][f-c]){var l=!1;i<r.length&&(l=1==(r[i]>>>o&1));var g=u(n,f-c);g&&(l=!l),s[n][f-c]=l,o-=1,-1==o&&(i+=1,o=7)}if(n+=e,0>n||n>=v){n-=e,e=-e;break}}},C=function(t,e){for(var n=0,o=0,i=0,u=new Array(e.length),f=new Array(e.length),c=0;c<e.length;c+=1){var l=e[c].dataCount,g=e[c].totalCount-l;o=Math.max(o,l),i=Math.max(i,g),u[c]=new Array(l);for(var s=0;s<u[c].length;s+=1)u[c][s]=255&t.getBuffer()[s+n];n+=l;var v=a.getErrorCorrectPolynomial(g),h=r(u[c],v.getLength()-1),d=h.mod(v);f[c]=new Array(v.getLength()-1);for(var s=0;s<f[c].length;s+=1){var w=s+d.getLength()-f[c].length;f[c][s]=w>=0?d.getAt(w):0}}for(var m=0,s=0;s<e.length;s+=1)m+=e[s].totalCount;for(var y=new Array(m),T=0,s=0;o>s;s+=1)for(var c=0;c<e.length;c+=1)s<u[c].length&&(y[T]=u[c][s],T+=1);for(var s=0;i>s;s+=1)for(var c=0;c<e.length;c+=1)s<f[c].length&&(y[T]=f[c][s],T+=1);return y},D=function(r,t,e){for(var n=u.getRSBlocks(r,t),c=f(),l=0;l<e.length;l+=1){var g=e[l];c.put(g.getMode(),4),c.put(g.getLength(),a.getLengthInBits(g.getMode(),r)),g.write(c)}for(var s=0,l=0;l<n.length;l+=1)s+=n[l].dataCount;if(c.getLengthInBits()>8*s)throw new Error("code length overflow. ("+c.getLengthInBits()+">"+8*s+")");for(c.getLengthInBits()+4<=8*s&&c.put(0,4);c.getLengthInBits()%8!=0;)c.putBit(!1);for(;;){if(c.getLengthInBits()>=8*s)break;if(c.put(o,8),c.getLengthInBits()>=8*s)break;c.put(i,8)}return C(c,n)};return m.addData=function(r){var t=c(r);w.push(t),d=null},m.isDark=function(r,t){if(0>r||r>=v||0>t||t>=v)throw new Error(r+","+t);return s[r][t]},m.getModuleCount=function(){return v},m.make=function(){y(!1,p())},m.createTableTag=function(r,t){r=r||2,t="undefined"==typeof t?4*r:t;var e="";e+='<table style="',e+=" border-width: 0px; border-style: none;",e+=" border-collapse: collapse;",e+=" padding: 0px; margin: "+t+"px;",e+='">',e+="<tbody>";for(var n=0;n<m.getModuleCount();n+=1){e+="<tr>";for(var o=0;o<m.getModuleCount();o+=1)e+='<td style="',e+=" border-width: 0px; border-style: none;",e+=" border-collapse: collapse;",e+=" padding: 0px; margin: 0px;",e+=" width: "+r+"px;",e+=" height: "+r+"px;",e+=" background-color: ",e+=m.isDark(n,o)?"#000000":"#ffffff",e+=";",e+='"/>';e+="</tr>"}return e+="</tbody>",e+="</table>"},m.createImgTag=function(r,t){r=r||2,t="undefined"==typeof t?4*r:t;var e=m.getModuleCount()*r+2*t,n=t,o=e-t;return h(e,e,function(t,e){if(t>=n&&o>t&&e>=n&&o>e){var a=Math.floor((t-n)/r),i=Math.floor((e-n)/r);return m.isDark(i,a)?0:1}return 1})},m};t.stringToBytes=function(r){for(var t=new Array,e=0;e<r.length;e+=1){var n=r.charCodeAt(e);t.push(255&n)}return t},t.createStringToBytes=function(r,t){var e=function(){for(var e=s(r),n=function(){var r=e.read();if(-1==r)throw new Error;return r},o=0,a={};;){var i=e.read();if(-1==i)break;var u=n(),f=n(),c=n(),l=String.fromCharCode(i<<8|u),g=f<<8|c;a[l]=g,o+=1}if(o!=t)throw new Error(o+" != "+t);return a}(),n="?".charCodeAt(0);return function(r){for(var t=new Array,o=0;o<r.length;o+=1){var a=r.charCodeAt(o);if(128>a)t.push(a);else{var i=e[r.charAt(o)];"number"==typeof i?(255&i)==i?t.push(i):(t.push(i>>>8),t.push(255&i)):t.push(n)}}return t}};var e={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},n={L:1,M:0,Q:3,H:2},o={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},a=function(){var t=[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],n=1335,a=7973,u=21522,f={},c=function(r){for(var t=0;0!=r;)t+=1,r>>>=1;return t};return f.getBCHTypeInfo=function(r){for(var t=r<<10;c(t)-c(n)>=0;)t^=n<<c(t)-c(n);return(r<<10|t)^u},f.getBCHTypeNumber=function(r){for(var t=r<<12;c(t)-c(a)>=0;)t^=a<<c(t)-c(a);return r<<12|t},f.getPatternPosition=function(r){return t[r-1]},f.getMaskFunction=function(r){switch(r){case o.PATTERN000:return function(r,t){return(r+t)%2==0};case o.PATTERN001:return function(r,t){return r%2==0};case o.PATTERN010:return function(r,t){return t%3==0};case o.PATTERN011:return function(r,t){return(r+t)%3==0};case o.PATTERN100:return function(r,t){return(Math.floor(r/2)+Math.floor(t/3))%2==0};case o.PATTERN101:return function(r,t){return r*t%2+r*t%3==0};case o.PATTERN110:return function(r,t){return(r*t%2+r*t%3)%2==0};case o.PATTERN111:return function(r,t){return(r*t%3+(r+t)%2)%2==0};default:throw new Error("bad maskPattern:"+r)}},f.getErrorCorrectPolynomial=function(t){for(var e=r([1],0),n=0;t>n;n+=1)e=e.multiply(r([1,i.gexp(n)],0));return e},f.getLengthInBits=function(r,t){if(t>=1&&10>t)switch(r){case e.MODE_NUMBER:return 10;case e.MODE_ALPHA_NUM:return 9;case e.MODE_8BIT_BYTE:return 8;case e.MODE_KANJI:return 8;default:throw new Error("mode:"+r)}else if(27>t)switch(r){case e.MODE_NUMBER:return 12;case e.MODE_ALPHA_NUM:return 11;case e.MODE_8BIT_BYTE:return 16;case e.MODE_KANJI:return 10;default:throw new Error("mode:"+r)}else{if(!(41>t))throw new Error("type:"+t);switch(r){case e.MODE_NUMBER:return 14;case e.MODE_ALPHA_NUM:return 13;case e.MODE_8BIT_BYTE:return 16;case e.MODE_KANJI:return 12;default:throw new Error("mode:"+r)}}},f.getLostPoint=function(r){for(var t=r.getModuleCount(),e=0,n=0;t>n;n+=1)for(var o=0;t>o;o+=1){for(var a=0,i=r.isDark(n,o),u=-1;1>=u;u+=1)if(!(0>n+u||n+u>=t))for(var f=-1;1>=f;f+=1)0>o+f||o+f>=t||(0!=u||0!=f)&&i==r.isDark(n+u,o+f)&&(a+=1);a>5&&(e+=3+a-5)}for(var n=0;t-1>n;n+=1)for(var o=0;t-1>o;o+=1){var c=0;r.isDark(n,o)&&(c+=1),r.isDark(n+1,o)&&(c+=1),r.isDark(n,o+1)&&(c+=1),r.isDark(n+1,o+1)&&(c+=1),(0==c||4==c)&&(e+=3)}for(var n=0;t>n;n+=1)for(var o=0;t-6>o;o+=1)r.isDark(n,o)&&!r.isDark(n,o+1)&&r.isDark(n,o+2)&&r.isDark(n,o+3)&&r.isDark(n,o+4)&&!r.isDark(n,o+5)&&r.isDark(n,o+6)&&(e+=40);for(var o=0;t>o;o+=1)for(var n=0;t-6>n;n+=1)r.isDark(n,o)&&!r.isDark(n+1,o)&&r.isDark(n+2,o)&&r.isDark(n+3,o)&&r.isDark(n+4,o)&&!r.isDark(n+5,o)&&r.isDark(n+6,o)&&(e+=40);for(var l=0,o=0;t>o;o+=1)for(var n=0;t>n;n+=1)r.isDark(n,o)&&(l+=1);var g=Math.abs(100*l/t/t-50)/5;return e+=10*g},f}(),i=function(){for(var r=new Array(256),t=new Array(256),e=0;8>e;e+=1)r[e]=1<<e;for(var e=8;256>e;e+=1)r[e]=r[e-4]^r[e-5]^r[e-6]^r[e-8];for(var e=0;255>e;e+=1)t[r[e]]=e;var n={};return n.glog=function(r){if(1>r)throw new Error("glog("+r+")");return t[r]},n.gexp=function(t){for(;0>t;)t+=255;for(;t>=256;)t-=255;return r[t]},n}(),u=function(){var r=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],t=function(r,t){var e={};return e.totalCount=r,e.dataCount=t,e},e={},o=function(t,e){switch(e){case n.L:return r[4*(t-1)+0];case n.M:return r[4*(t-1)+1];case n.Q:return r[4*(t-1)+2];case n.H:return r[4*(t-1)+3];default:return}};return e.getRSBlocks=function(r,e){var n=o(r,e);if("undefined"==typeof n)throw new Error("bad rs block @ typeNumber:"+r+"/errorCorrectLevel:"+e);for(var a=n.length/3,i=new Array,u=0;a>u;u+=1)for(var f=n[3*u+0],c=n[3*u+1],l=n[3*u+2],g=0;f>g;g+=1)i.push(t(c,l));return i},e}(),f=function(){var r=new Array,t=0,e={};return e.getBuffer=function(){return r},e.getAt=function(t){var e=Math.floor(t/8);return 1==(r[e]>>>7-t%8&1)},e.put=function(r,t){for(var n=0;t>n;n+=1)e.putBit(1==(r>>>t-n-1&1))},e.getLengthInBits=function(){return t},e.putBit=function(e){var n=Math.floor(t/8);r.length<=n&&r.push(0),e&&(r[n]|=128>>>t%8),t+=1},e},c=function(r){var n=e.MODE_8BIT_BYTE,o=t.stringToBytes(r),a={};return a.getMode=function(){return n},a.getLength=function(r){return o.length},a.write=function(r){for(var t=0;t<o.length;t+=1)r.put(o[t],8)},a},l=function(){var r=new Array,t={};return t.writeByte=function(t){r.push(255&t)},t.writeShort=function(r){t.writeByte(r),t.writeByte(r>>>8)},t.writeBytes=function(r,e,n){e=e||0,n=n||r.length;for(var o=0;n>o;o+=1)t.writeByte(r[o+e])},t.writeString=function(r){for(var e=0;e<r.length;e+=1)t.writeByte(r.charCodeAt(e))},t.toByteArray=function(){return r},t.toString=function(){var t="";t+="[";for(var e=0;e<r.length;e+=1)e>0&&(t+=","),t+=r[e];return t+="]"},t},g=function(){var r=0,t=0,e=0,n="",o={},a=function(r){n+=String.fromCharCode(i(63&r))},i=function(r){if(0>r);else{if(26>r)return 65+r;if(52>r)return 97+(r-26);if(62>r)return 48+(r-52);if(62==r)return 43;if(63==r)return 47}throw new Error("n:"+r)};return o.writeByte=function(n){for(r=r<<8|255&n,t+=8,e+=1;t>=6;)a(r>>>t-6),t-=6},o.flush=function(){if(t>0&&(a(r<<6-t),r=0,t=0),e%3!=0)for(var o=3-e%3,i=0;o>i;i+=1)n+="="},o.toString=function(){return n},o},s=function(r){var t=r,e=0,n=0,o=0,a={};a.read=function(){for(;8>o;){if(e>=t.length){if(0==o)return-1;throw new Error("unexpected end of file./"+o)}var r=t.charAt(e);if(e+=1,"="==r)return o=0,-1;r.match(/^\s$/)||(n=n<<6|i(r.charCodeAt(0)),o+=6)}var a=n>>>o-8&255;return o-=8,a};var i=function(r){if(r>=65&&90>=r)return r-65;if(r>=97&&122>=r)return r-97+26;if(r>=48&&57>=r)return r-48+52;if(43==r)return 62;if(47==r)return 63;throw new Error("c:"+r)};return a},v=function(r,t){var e=r,n=t,o=new Array(r*t),a={};a.setPixel=function(r,t,n){o[t*e+r]=n},a.write=function(r){r.writeString("GIF87a"),r.writeShort(e),r.writeShort(n),r.writeByte(128),r.writeByte(0),r.writeByte(0),r.writeByte(0),r.writeByte(0),r.writeByte(0),r.writeByte(255),r.writeByte(255),r.writeByte(255),r.writeString(","),r.writeShort(0),r.writeShort(0),r.writeShort(e),r.writeShort(n),r.writeByte(0);var t=2,o=u(t);r.writeByte(t);for(var a=0;o.length-a>255;)r.writeByte(255),r.writeBytes(o,a,255),a+=255;r.writeByte(o.length-a),r.writeBytes(o,a,o.length-a),r.writeByte(0),r.writeString(";")};var i=function(r){var t=r,e=0,n=0,o={};return o.write=function(r,o){if(r>>>o!=0)throw new Error("length over");for(;e+o>=8;)t.writeByte(255&(r<<e|n)),o-=8-e,r>>>=8-e,n=0,e=0;n=r<<e|n,e+=o},o.flush=function(){e>0&&t.writeByte(n)},o},u=function(r){for(var t=1<<r,e=(1<<r)+1,n=r+1,a=f(),u=0;t>u;u+=1)a.add(String.fromCharCode(u));a.add(String.fromCharCode(t)),a.add(String.fromCharCode(e));var c=l(),g=i(c);g.write(t,n);var s=0,v=String.fromCharCode(o[s]);for(s+=1;s<o.length;){var h=String.fromCharCode(o[s]);s+=1,a.contains(v+h)?v+=h:(g.write(a.indexOf(v),n),a.size()<4095&&(a.size()==1<<n&&(n+=1),a.add(v+h)),v=h)}return g.write(a.indexOf(v),n),g.write(e,n),g.flush(),c.toByteArray()},f=function(){var r={},t=0,e={};return e.add=function(n){if(e.contains(n))throw new Error("dup key:"+n);r[n]=t,t+=1},e.size=function(){return t},e.indexOf=function(t){return r[t]},e.contains=function(t){return"undefined"!=typeof r[t]},e};return a},h=function(r,t,e,n){for(var o=v(r,t),a=0;t>a;a+=1)for(var i=0;r>i;i+=1)o.setPixel(i,a,e(i,a));var u=l();o.write(u);for(var f=g(),c=u.toByteArray(),s=0;s<c.length;s+=1)f.writeByte(c[s]);f.flush();var h="";return h+="<img",h+=' src="',h+="data:image/gif;base64,",h+=f,h+='"',h+=' width="',h+=r,h+='"',h+=' height="',h+=t,h+='"',n&&(h+=' alt="',h+=n,h+='"'),h+="/>"};return t}();return function(r){"function"==typeof define&&define.amd?define('qrcode',[],r):"object"==typeof exports&&(module.exports=r())}(function(){return r}),!function(r){r.stringToBytes=function(r){function t(r){for(var t=[],e=0;e<r.length;e++){var n=r.charCodeAt(e);128>n?t.push(n):2048>n?t.push(192|n>>6,128|63&n):55296>n||n>=57344?t.push(224|n>>12,128|n>>6&63,128|63&n):(e++,n=65536+((1023&n)<<10|1023&r.charCodeAt(e)),t.push(240|n>>18,128|n>>12&63,128|n>>6&63,128|63&n))}return t}return t(r)}}(r),r}());
/*! ========================================================================
 * Bootstrap Toggle: bootstrap-toggle.js v2.2.0
 * http://www.bootstraptoggle.com
 * ========================================================================
 * Copyright 2014 Min Hur, The New York Times Company
 * Licensed under MIT
 * ======================================================================== */
+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.toggle"),f="object"==typeof b&&b;e||d.data("bs.toggle",e=new c(this,f)),"string"==typeof b&&e[b]&&e[b]()})}var c=function(b,c){this.$element=a(b),this.options=a.extend({},this.defaults(),c),this.render()};c.VERSION="2.2.0",c.DEFAULTS={on:"On",off:"Off",onstyle:"primary",offstyle:"default",size:"normal",style:"",width:null,height:null},c.prototype.defaults=function(){return{on:this.$element.attr("data-on")||c.DEFAULTS.on,off:this.$element.attr("data-off")||c.DEFAULTS.off,onstyle:this.$element.attr("data-onstyle")||c.DEFAULTS.onstyle,offstyle:this.$element.attr("data-offstyle")||c.DEFAULTS.offstyle,size:this.$element.attr("data-size")||c.DEFAULTS.size,style:this.$element.attr("data-style")||c.DEFAULTS.style,width:this.$element.attr("data-width")||c.DEFAULTS.width,height:this.$element.attr("data-height")||c.DEFAULTS.height}},c.prototype.render=function(){this._onstyle="btn-"+this.options.onstyle,this._offstyle="btn-"+this.options.offstyle;var b="large"===this.options.size?"btn-lg":"small"===this.options.size?"btn-sm":"mini"===this.options.size?"btn-xs":"",c=a('<label class="btn">').html(this.options.on).addClass(this._onstyle+" "+b),d=a('<label class="btn">').html(this.options.off).addClass(this._offstyle+" "+b+" active"),e=a('<span class="toggle-handle btn btn-default">').addClass(b),f=a('<div class="toggle-group">').append(c,d,e),g=a('<div class="toggle btn" data-toggle="toggle">').addClass(this.$element.prop("checked")?this._onstyle:this._offstyle+" off").addClass(b).addClass(this.options.style);this.$element.wrap(g),a.extend(this,{$toggle:this.$element.parent(),$toggleOn:c,$toggleOff:d,$toggleGroup:f}),this.$toggle.append(f);var h=this.options.width||Math.max(c.outerWidth(),d.outerWidth())+e.outerWidth()/2,i=this.options.height||Math.max(c.outerHeight(),d.outerHeight());c.addClass("toggle-on"),d.addClass("toggle-off"),this.$toggle.css({width:h,height:i}),this.options.height&&(c.css("line-height",c.height()+"px"),d.css("line-height",d.height()+"px")),this.update(!0),this.trigger(!0)},c.prototype.toggle=function(){this.$element.prop("checked")?this.off():this.on()},c.prototype.on=function(a){return this.$element.prop("disabled")?!1:(this.$toggle.removeClass(this._offstyle+" off").addClass(this._onstyle),this.$element.prop("checked",!0),void(a||this.trigger()))},c.prototype.off=function(a){return this.$element.prop("disabled")?!1:(this.$toggle.removeClass(this._onstyle).addClass(this._offstyle+" off"),this.$element.prop("checked",!1),void(a||this.trigger()))},c.prototype.enable=function(){this.$toggle.removeAttr("disabled"),this.$element.prop("disabled",!1)},c.prototype.disable=function(){this.$toggle.attr("disabled","disabled"),this.$element.prop("disabled",!0)},c.prototype.update=function(a){this.$element.prop("disabled")?this.disable():this.enable(),this.$element.prop("checked")?this.on(a):this.off(a)},c.prototype.trigger=function(b){this.$element.off("change.bs.toggle"),b||this.$element.change(),this.$element.on("change.bs.toggle",a.proxy(function(){this.update()},this))},c.prototype.destroy=function(){this.$element.off("change.bs.toggle"),this.$toggleGroup.remove(),this.$element.removeData("bs.toggle"),this.$element.unwrap()};var d=a.fn.bootstrapToggle;a.fn.bootstrapToggle=b,a.fn.bootstrapToggle.Constructor=c,a.fn.toggle.noConflict=function(){return a.fn.bootstrapToggle=d,this},a(function(){a("input[type=checkbox][data-toggle^=toggle]").bootstrapToggle()}),a(document).on("click.bs.toggle","div[data-toggle^=toggle]",function(b){var c=a(this).find("input[type=checkbox]");c.bootstrapToggle("toggle"),b.preventDefault()})}(jQuery);
//# sourceMappingURL=bootstrap-toggle.min.js.map;
define("toggle", function(){});

/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version: 1.3.6
 *
 */
(function(e){e.fn.extend({slimScroll:function(g){var a=e.extend({width:"auto",height:"250px",size:"7px",color:"#000",position:"right",distance:"1px",start:"top",opacity:.4,alwaysVisible:!1,disableFadeOut:!1,railVisible:!1,railColor:"#333",railOpacity:.2,railDraggable:!0,railClass:"slimScrollRail",barClass:"slimScrollBar",wrapperClass:"slimScrollDiv",allowPageScroll:!1,wheelStep:20,touchScrollStep:200,borderRadius:"7px",railBorderRadius:"7px"},g);this.each(function(){function v(d){if(r){d=d||window.event;
    var c=0;d.wheelDelta&&(c=-d.wheelDelta/120);d.detail&&(c=d.detail/3);e(d.target||d.srcTarget||d.srcElement).closest("."+a.wrapperClass).is(b.parent())&&m(c,!0);d.preventDefault&&!k&&d.preventDefault();k||(d.returnValue=!1)}}function m(d,e,g){k=!1;var f=d,h=b.outerHeight()-c.outerHeight();e&&(f=parseInt(c.css("top"))+d*parseInt(a.wheelStep)/100*c.outerHeight(),f=Math.min(Math.max(f,0),h),f=0<d?Math.ceil(f):Math.floor(f),c.css({top:f+"px"}));l=parseInt(c.css("top"))/(b.outerHeight()-c.outerHeight());
    f=l*(b[0].scrollHeight-b.outerHeight());g&&(f=d,d=f/b[0].scrollHeight*b.outerHeight(),d=Math.min(Math.max(d,0),h),c.css({top:d+"px"}));b.scrollTop(f);b.trigger("slimscrolling",~~f);w();p()}function x(){u=Math.max(b.outerHeight()/b[0].scrollHeight*b.outerHeight(),30);c.css({height:u+"px"});var a=u==b.outerHeight()?"none":"block";c.css({display:a})}function w(){x();clearTimeout(B);l==~~l?(k=a.allowPageScroll,C!=l&&b.trigger("slimscroll",0==~~l?"top":"bottom")):k=!1;C=l;u>=b.outerHeight()?k=!0:(c.stop(!0,
    !0).fadeIn("fast"),a.railVisible&&h.stop(!0,!0).fadeIn("fast"))}function p(){a.alwaysVisible||(B=setTimeout(function(){a.disableFadeOut&&r||y||z||(c.fadeOut("slow"),h.fadeOut("slow"))},1E3))}var r,y,z,B,A,u,l,C,k=!1,b=e(this);if(b.parent().hasClass(a.wrapperClass)){var n=b.scrollTop(),c=b.closest("."+a.barClass),h=b.closest("."+a.railClass);x();if(e.isPlainObject(g)){if("height"in g&&"auto"==g.height){b.parent().css("height","auto");b.css("height","auto");var q=b.parent().parent().height();b.parent().css("height",
    q);b.css("height",q)}if("scrollTo"in g)n=parseInt(a.scrollTo);else if("scrollBy"in g)n+=parseInt(a.scrollBy);else if("destroy"in g){c.remove();h.remove();b.unwrap();return}m(n,!1,!0)}}else if(!(e.isPlainObject(g)&&"destroy"in g)){a.height="auto"==a.height?b.parent().height():a.height;n=e("<div></div>").addClass(a.wrapperClass).css({position:"relative",overflow:"hidden",width:a.width,height:a.height});b.css({overflow:"hidden",width:a.width,height:a.height});var h=e("<div></div>").addClass(a.railClass).css({width:a.size,
    height:"100%",position:"absolute",top:0,display:a.alwaysVisible&&a.railVisible?"block":"none","border-radius":a.railBorderRadius,background:a.railColor,opacity:a.railOpacity,zIndex:90}),c=e("<div></div>").addClass(a.barClass).css({background:a.color,width:a.size,position:"absolute",top:0,opacity:a.opacity,display:a.alwaysVisible?"block":"none","border-radius":a.borderRadius,BorderRadius:a.borderRadius,MozBorderRadius:a.borderRadius,WebkitBorderRadius:a.borderRadius,zIndex:99}),q="right"==a.position?
{right:a.distance}:{left:a.distance};h.css(q);c.css(q);b.wrap(n);b.parent().append(c);b.parent().append(h);a.railDraggable&&c.bind("mousedown",function(a){var b=e(document);z=!0;t=parseFloat(c.css("top"));pageY=a.pageY;b.bind("mousemove.slimscroll",function(a){currTop=t+a.pageY-pageY;c.css("top",currTop);m(0,c.position().top,!1)});b.bind("mouseup.slimscroll",function(a){z=!1;p();b.unbind(".slimscroll")});return!1}).bind("selectstart.slimscroll",function(a){a.stopPropagation();a.preventDefault();return!1});
    h.hover(function(){w()},function(){p()});c.hover(function(){y=!0},function(){y=!1});b.hover(function(){r=!0;w();p()},function(){r=!1;p()});b.bind("touchstart",function(a,b){a.originalEvent.touches.length&&(A=a.originalEvent.touches[0].pageY)});b.bind("touchmove",function(b){k||b.originalEvent.preventDefault();b.originalEvent.touches.length&&(m((A-b.originalEvent.touches[0].pageY)/a.touchScrollStep,!0),A=b.originalEvent.touches[0].pageY)});x();"bottom"===a.start?(c.css({top:b.outerHeight()-c.outerHeight()}),
        m(0,!0)):"top"!==a.start&&(m(e(a.start).position().top,null,!0),a.alwaysVisible||c.hide());window.addEventListener?(this.addEventListener("DOMMouseScroll",v,!1),this.addEventListener("mousewheel",v,!1)):document.attachEvent("onmousewheel",v)}});return this}});e.fn.extend({slimscroll:e.fn.slimScroll})})(jQuery);
define("slimscroll", function(){});

/*
 This file is part of SMAP.

 SMAP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 SMAP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with SMAP.  If not, see <http://www.gnu.org/licenses/>.

 */

/*
 * Purpose: Manage the panels that display graphs, maps etc of results data
 */

var gUserLocale = navigator.language;
if (Modernizr.localstorage) {
    gUserLocale = localStorage.getItem('user_locale') || navigator.language;
}


requirejs.config({
    baseUrl: 'js/libs',
    locale: gUserLocale,
    waitSeconds: 60,
    paths: {
        app: '../app',
        i18n: '../../../../js/libs/i18n',
        async: '../../../../js/libs/async',
        localise: '../../../../js/app/localise',
        modernizr: '../../../../js/libs/modernizr',
        common: '../../../../js/app/common',
        globals: '../../../../js/app/globals',
        crf: '../../../../js/libs/commonReportFunctions',
        toggle: 'bootstrap-toggle.min',
        lang_location: '../../../../js',
        file_input: '../../../../js/libs/bootstrap.file-input',
        datetimepicker: '../../../../js/libs/bootstrap-datetimepicker.min',
        svgsave: '../../../../js/libs/saveSvgAsPng',
        pace: '../../../../js/libs/wb/plugins/pace/pace.min',
        qrcode: '../../../../js/libs/jquery-qrcode-0.14.0.min',
        multiselect: '../../../../js/libs/bootstrap-multiselect',
        knockout: '../../../../js/libs/knockout',
	    slimscroll: '../../../../js/libs/wb/plugins/slimscroll/jquery.slimscroll.min'

    },
    shim: {

        'common': ['jquery'],
        'datetimepicker': ['moment'],
        'app/plugins': ['jquery'],
        'crf': ['jquery'],
        'file_input': ['jquery'],
        'app/summary_report': ['jquery'],
        'qrcode': ['jquery'],
	    'slimscroll': ['jquery'],
        'toggle': ['bootstrap.min'],
        'multiselect': ['jquery', 'knockout']
    }
});

require([
    'jquery',
    'common',
    'localise',
    'globals',
    'moment',
    'app/summary_report',
    'app/chart',
    'app/mapOL3',
    'svgsave',
    'app/actioncommon',
    'datetimepicker',
    'crf',
    'qrcode',
    'toggle',
	'slimscroll',
    'multiselect'

], function ($,
             common,
             localise,
             globals,
             moment,
             summary_report,
             chart,
             map,
             svgsave,
             actioncommon) {

    /*
     * Report definition
     * Default Settings
     *    Create a chart for data table columns that are enabled and do not have column specific setting
     * Column specific settings
     *    Override settings where names match
     */

    var gMapView = false;           // Set true when the map tab is shown
    var gChartView = false;         // Set true when the chart view is shown
    var gTimingView = false;        // Set true when the timing view is shown
    var gRefreshingData = false;    // Prevent double click on  refresh button
    var gAssignedCol = 0;           // Column that contains the assignment status
    var gGetSettings = false;       // Use the settings from the database rather than the client
    var gDeleteColumn = -1;         // The index of the column that indicates if the record is deleted
    var gDeleteReasonColumn = -1;   // The index of the column that has the reason for a delete
    var gBad;                       // A boolean indicating the direction of toggle of a deleted state
    var gLocalDefaults = {};

    var gDrillDownNext;                 // Next drill down state if drill down is selected
    var gDrillDownStack = [];

    var gOverallMapConfig = {       // overall map
        id: 'map',
        map: undefined,
        task: false
    };

    var gTags;                      // Task Map
    var gModalMapInitialised;
    var gTaskMapConfig = {
        id: 'mapModal',
        map: undefined,
        task: true
    };

    var gCurrentGroup,
        gCurrentLocation = '-1';

    window.gTasks = {
        cache: {
            surveyConfig: {},
            managedData: {},
            surveyList: {},
            surveyRoles: {},
            recordChanges: {},
            groupSurveys: {},
            currentData: undefined,
            data: {},
        },
        charts: [
            {
                subject: "status",
                chart_type: 'bar',
                label: localise.set["c_status"],
                color: 'rgb(255, 99, 132)'
            },
            {
                subject: "assigned",
                chart_type: 'bar',
                label: localise.set["t_assigned"],
                color: 'rgb(0, 0, 255)'
            },
            {
                subject: "alert",
                chart_type: 'bar',
                label: localise.set["c_alert"],
                color: 'rgb(0, 255, 0)'
            },
            {
                subject: "criticality",
                chart_type: 'bar',
                label: localise.set["c_crit"],
                color: 'rgb(255, 255, 0)'
            }

        ],
        gSelectedRecord: undefined,
        gBulkInstances: [],
        gSelectedSurveyIndex: undefined,
        gUpdate: [],
        gPriKey: undefined,
        gSort: undefined,
        gDirn: undefined
    };
    window.gCurrentTaskFeature; // Currently edited task feature, hack to support shared functions with console
    window.gUpdateFwdPassword = undefined;
    window.gSaveType = '';
    window.gNotifications = undefined;
    window.gChanges = [];
    window.gSelectedChart = -1;


    $(document).ready(function () {

        window.summary_report = summary_report;
        window.moment = moment;
        setCustomManage();
        setTheme();
	    setupUserProfile(true);
        localise.setlang();		// Localise HTML
        registerForServiceWorkerMessages();
        userDefaults();

        // Set page defaults
        var def = getFromLocalStorage("console");
        if(def) {
            try {
                gLocalDefaults = JSON.parse(def);

                if(gLocalDefaults) {
                    $('#my_records').prop('checked', gLocalDefaults.myRecords);
                    $('#unassigned_records').prop('checked', gLocalDefaults.unassignedRecords);
                    $('#other_records').prop('checked', gLocalDefaults.otherRecords);
                } else {
                    gLocalDefaults = {};
                }

            } catch (err) {
                gLocalDefaults = {};
            }
        }

        $('.editRecordSection, .bulkEditSection, .selectOnly, .singleSelectOnly, .multiSelectOnly, .dd_only').hide();

        // Get the parameters and start editing a survey if one was passed as a parameter
        var params = location.search.substr(location.search.indexOf("?") + 1);
        var pArray = params.split("&");
        var dont_get_current_survey = false;
        $('.srview').hide();
        for (i = 0; i < pArray.length; i++) {
            var param = pArray[i].split("=");
            if ( param[0] === "id" ) {
                dont_get_current_survey = true;		// Use the passed in survey id
                globals.gCurrentSurvey = param[1];
                saveCurrentProject(-1, globals.gCurrentSurvey, undefined);	// Save the current survey id
            } else if ( param[0] === "instanceid" ) {
                globals.gCurrentInstance = param[1];
                $('.mrview').hide();
                $('.srview').show();
            }
        }

        // Set custom menus
        var customMenuClass = getCustomMenuClass();
        if(customMenuClass) {
            $(customMenuClass).show();
        }

        // Get the user details
        globals.gIsAdministrator = false;
        getLoggedInUser(refreshData, false, true, undefined, false, dont_get_current_survey);

        // Set change function on projects
        $('#project_name').change(function () {
            projectChanged();
        });

        // Get locations
        getLocations(processLocationList);

        // Get Notification Types for this server
        getNotificationTypes();

        // Set response to clearing single record view
        $('#clear_srview').click(function() {
            globals.gCurrentInstance = undefined;
            $('.srview').hide();
            $('.mrview').show();
            refreshData();
        });

        // Set change function on survey
        $('#survey_name').change(function () {
            gTasks.gSelectedSurveyIndex = $(this).val();
            globals.gCurrentSurvey = gTasks.cache.surveyList[globals.gCurrentProject][gTasks.gSelectedSurveyIndex].id;
            gGetSettings = true;
	        clearDrillDown();
            mfSurveyChanged();
            populatePdfSelect(globals.gCurrentSurvey, $('#select_pdf'));
        });

        // Set change function on group survey
        $('#group_survey').change(function () {
            globals.gGroupSurveys[globals.gCurrentSurvey] = $(this).val();
            groupSurveyChanged();
        });

        // Set change function on sub form
        $('#sub_form').change(function () {
            globals.gSubForms[globals.gCurrentSurvey] = $(this).val();
            clearDrillDown();
            subFormChanged();
        });

        // Set change function on drill down
        $('#drill_down').click(function () {
          drillDown();
        });

        // Set change function on drill up
        $('#drill_up').click(function () {

            if(gDrillDownStack.length > 0) {
                gDrillDownNext = gDrillDownStack.pop();
            }
            subFormChanged();
        });

        // Set change function on controls
        $('#advanced_filter, #limit, #include_bad, #include_completed').change(function () {
            showManagedData(globals.gCurrentSurvey, showTable, true);
        });

        // Set change function on clearColumns
        $('#clearColumns').change(function() {
            $('.columnSelect').prop('checked', ($(this).prop('checked')));
        });

        /*
         * Setup dialog to change the current survey
         */
        $("#changeSurveys").click(function () {
            $("#surveySelect").modal("show");
        });

        $('.exitEditRecord').click(function(e) {
            e.preventDefault();
            showManagedData(globals.gCurrentSurvey, showTable, true);
            window.history.back();
        });

        $('.exitBulkEdit').click(function(e) {
            e.preventDefault();
            showManagedData(globals.gCurrentSurvey, showTable, true);
            window.history.back();
        });

        setupTaskDialog();
        setupNotificationDialog();

        // Enable the save notifications function
        $('#saveNotification').click(function(){sendImmediateNotification();});

        /*
         * Update the properties of a task
         */
        $('#taskPropertiesSave').off().click(function () {
            var instance;
            if(typeof gTasks !== "undefined" && gTasks.gSelectedRecord) {
                instance = gTasks.gSelectedRecord.instanceid;
            }
            saveTask(true, gCurrentTaskFeature, gSaveType, instance, doneTaskSave, 0);
        });

        window.addEventListener("popstate", function(e) {
            console.log("location: " + document.location + ", state: " + JSON.stringify(event.state));
            if(document.location.href.indexOf("#edit") == -1 && document.location.href.indexOf("#bulk") == -1) {
                exitEdit();
            }
            return false;
        });

        $('#er_form_data').change(function(){
            if($(this).prop('checked')) {
                $('.showFormData').show();
                $('.showMgmtData').addClass('col-sm-6').removeClass('col-sm-12');
            } else {
                $('.showFormData').hide();
                $('.showMgmtData').addClass('col-sm-12').removeClass('col-sm-6');
            }
        });

        /*
         * Edit a record
         */
        $('#m_edit').click(function(e) {
            e.preventDefault();
            showRecord(true);
        });

        $('#m_bulk_edit').click(function(e) {
            e.preventDefault();
            showBulkEdit();
        });

        /*
	     * View a record
	     */
        $('#m_view').click(function(e) {
            e.preventDefault();
            showRecord(false);
        });

        /*
         * Open the dialog to assign a user to a record
         */
        $('#m_assign_to').click(function(e) {
            e.preventDefault();
            if(gTasks.gSelectedRecord._assigned) {
                $('#user_to_assign').val(gTasks.gSelectedRecord._assigned);
            } else {
                $('#user_to_assign').val("_none");
            }
            $('#userAssign').modal("show");
        });

        /*
         * add a chart
         */
        $('#m_add_chart').click(function(e) {
            e.preventDefault();

            $('#addChartForm')[0].reset();
            gSelectedChart = -1;
            setChartPopupControls();
            $('#chart_settings_popup').modal("show");
        });

        $('#cs_subject').change(function() {
            setChartPopupControls();
        });


        /*
         * Delete a record
         */
        $('#m_delete').click(function(e) {
            e.preventDefault();
            toggleRecord(localise.set["c_del"], true);
        });

        /*
         * UnDelete a record
         */
        $('#m_undelete').click(function(e) {
            e.preventDefault();
            toggleRecord(localise.set["c_undel"], false);
        });

        $('#toggleRecordSave').click(function(e){
            e.preventDefault(e);
            var url = "/surveyKPI/items/" + globals.gCurrentSurvey + "/survey/bad/" + gTasks.gSelectedRecord.instanceid;
            var reason = $('#toggle_reason').val();
            addHourglass();

            $.ajax({
                type: "POST",
                dataType: 'text',
                contentType: "application/json",
                cache: false,
                url: url,
                data: {
                    value: gBad,
                    reason: reason
                },
                success: function (data, status) {
                    removeHourglass();
                    refreshData();
                }, error: function (data, status) {
                    removeHourglass();
                    alert(data.responseText);
                }
            });
        });

        /*
         * Lock a record for editing by this user
         */
        $('#m_lock').click(function(e) {
            e.preventDefault();
            var url = "/surveyKPI/managed/lock/" + globals.gCurrentSurvey;
            addHourglass();
            $.ajax({
                type: "POST",
                dataType: 'text',
                contentType: "application/json",
                cache: false,
                url: url,
                data: {
                    record: gTasks.gSelectedRecord.instanceid
                },
                success: function (data, status) {
                    removeHourglass();
                    showManagedData(globals.gCurrentSurvey, showTable, true);
                }, error: function (data, status) {
                    removeHourglass();
                    alert(data.responseText);
                }
            });
        });

        /*
	     * Assign a user
	     */
        $('#assignUserSave').click(function(e) {
            e.preventDefault();
            var url = "/surveyKPI/managed/assign/" + globals.gCurrentSurvey + "/" + $('#user_to_assign').val();

            addHourglass();
            $.ajax({
                type: "POST",
                dataType: 'text',
                contentType: "application/json",
                cache: false,
                url: url,
                data: {record: gTasks.gSelectedRecord.instanceid},
                success: function (data, status) {
                    removeHourglass();
                    showManagedData(globals.gCurrentSurvey, showTable, true);
                }, error: function (data, status) {
                    removeHourglass();
                    alert(data.responseText);
                }
            });

        });

        /*
         * Release a record
         */
        $('#m_release').click(function(e) {
            e.preventDefault();
            var url = "/surveyKPI/managed/release/" + globals.gCurrentSurvey;
            addHourglass();
            $.ajax({
                type: "POST",
                dataType: 'text',
                contentType: "application/json",
                cache: false,
                url: url,
                data: {record: gTasks.gSelectedRecord.instanceid},
                success: function (data, status) {
                    removeHourglass();
                    showManagedData(globals.gCurrentSurvey, showTable, true);
                }, error: function (data, status) {
                    removeHourglass();
                    alert(data.responseText);
                }
            });
        });

        /*
         * Save a record of data in managed forms
         */
        $('.saverecord').click(function (e) {
            e.preventDefault();
            var saveString = JSON.stringify(gTasks.gUpdate);
            var biString;
            if(gTasks.gBulkInstances && gTasks.gBulkInstances.length > 1) {
                biString =  JSON.stringify(gTasks.gBulkInstances)
            }
            addHourglass();
            $.ajax({
                type: "POST",
                dataType: 'text',
                contentType: "application/json",
                cache: false,
                url: "/surveyKPI/managed/update_gs/" + globals.gCurrentSurvey + "/" + globals.gGroupSurveys[globals.gCurrentSurvey],
                data: {
                    updates: saveString,
                    instanceid: gTasks.gSelectedRecord.instanceid,
                    prikey: gTasks.gSelectedRecord.prikey,
                    bulkInstances: biString,
                    groupForm: globals.gSubForms[globals.gCurrentSurvey]
                },
                success: function (data, status) {
                    removeHourglass();

                    // Update the current values
                    var i,
                        record = gTasks.gSelectedRecord,
                        columns = gTasks.cache.currentData.schema.columns;
                    for(i = 0; i < gTasks.gUpdate.length; i++) {
                        record[columns[gTasks.gUpdate[i].itemIndex].column_name]  = gTasks.gUpdate[i].value;
                    }

                    gTasks.gUpdate = [];
                    $('.saverecord').prop("disabled", true);

                    getRecordChanges(gTasks.gSelectedRecord);
                    $('.re_alert').show().removeClass('alert-danger').addClass('alert-success').html(localise.set["msg_upd"]);
                }, error: function (data, status) {
                    removeHourglass();
                    $('.re_alert').show().removeClass('alert-success').addClass('alert-danger').html(localise.set["msg_err_upd"] + data.responseText);
                }
            });
        });


        $('.genrecordpdf').click(function (e)  {
            e.preventDefault();
            $('#genPdfPopup').modal("show");
        });

        $('#genPdf').click(function(e) {
            e.preventDefault();

            var language = $('#pdf_language option:selected').val();
            var pdfTemplate = $('#select_pdf option:selected').val();
            var orientation = $("#pdf_orientation").val();
            var include_references = $("#pdf_include_references").prop('checked');
            var launched_only = $("#pdf_launched_only").prop('checked');
            var sIdent = gTasks.cache.surveyList[globals.gCurrentProject][gTasks.gSelectedSurveyIndex].ident;
            var instanceId = gTasks.gSelectedRecord.instanceid;

            downloadPdf(language, orientation, include_references, launched_only, sIdent, instanceId, pdfTemplate);
        });

        /*
         * show the settings dialog
         */
        $('#show_settings').click(function(e) {
            e.preventDefault();
            $('#settingsPopup').modal("show");
        });

        /*
         * Save changes to the table columns that are shown
         */
        $('#saveSettings').click(function () {

            var
                config = gTasks.cache.currentData.schema,
                $this;

            $('input.columnSelect', '#tab-columns-content').each(function (index) {
                $this = $(this);
                config.columns[index].hide = !$this.is(':checked');
            });

            $('input.barcodeSelect', '#tab-columns-content').each(function (index) {
                $this = $(this);
                config.columns[index].barcode = $this.is(':checked');

            });

            $('input.includeText', '#tab-columns-content').each(function (index) {
                $this = $(this);
                config.columns[index].includeText = $this.is(':checked');

            });

            updateVisibleColumns(config.columns);
            saveColumns();

        });

        // Refresh menu
        $('#m_refresh').click(function (e) {
            e.preventDefault();
            if(window.location.hash === "#edit") {
                getRecordChanges(gTasks.gSelectedRecord);
            } else {
                refreshData();
            }
        });

        // Add a new map layer
        $('#m_add_layer').click(function (e) {
            e.preventDefault();
            $('#layerInfo').hide();
            $('#ml_title').val("");
            $('#layerEdit').modal("show");
        });

        // Respond to save on a layer edit dialog
        $('#addLayerSave').click(function (e) {
            e.preventDefault();
            map.saveLayer(gOverallMapConfig.map);
        });

        // Respond to a new task location being clicked
        $('#taskPropertiesForm').on("smap_task::geopoint", function (event, config) {
            gCurrentTaskFeature.geometry = config.value;
            console.log("New task geopoint");
        });

        /*
         * Take action on tab change to initialiseColumns tab contents
         * Refer: http://stackoverflow.com/questions/20705905/bootstrap-3-jquery-event-for-active-tab-change
         */
        $('a[data-toggle="tab"]', '#mainTabs').on('shown.bs.tab', function (e) {
            var target = $(e.target).attr("href") // activated tab
            var trigger;

            $('.targetSpecific').hide();
            gMapView = false;
            gChartView = false;
            gTimingView = false;

            if (target === '#tablePanel') {
                $('.tableOnly').removeClass('d-none').show();
                trigger = '#table-view';
            } else if (target === '#mapPanel') {
                $('.mapOnly').removeClass('d-none').show();
                gMapView = true;
                try {       // will fail if there is no data
                    map.initDynamicMap(gOverallMapConfig, false, featureSelected, true);
                } catch(err) {

                }
                trigger = '#map-view';

            } else if(target === '#chartPanel') {
                chart.refresh();
                $('.chartOnly').removeClass('d-none').show();
                gChartView = true;
                trigger = '#chart-view';
            } else if(target === '#timingPanel') {
                //chart.init(false, true);
                $('#m_add_chart').removeClass('d-none').show();
                gTimingView = true;
                trigger = '#timing-view';
            }
            setInLocalStorage("currentTab" + page, trigger);
        });

        $('a[data-toggle="tab"]', '#editTabs').on('shown.bs.tab', function (e) {
            var target = $(e.target).attr("href") // activated tab

            $('.historyView,.dataView').hide();

            if (target === '#data-view') {
                $('.dataView').removeClass('d-none').show();
            } else if(target === '#changes-view') {
                $('.historyView').removeClass('d-none').show();
            }

            $('.re_alert').hide();
        });

        /*
         * Respond to a location being selected
         */
        $('#location_select').change(function () {
            var idx = $(this).val();

            // Clear old values
            $('#nfc_uid').val("");
            $('#location_save_panel').hide();
            window.gSaveType = '';

            if(idx != -1) {
                $('#nfc_uid').val(gTags[idx].uid);
                var lat = gTags[idx].lat;
                var lon = gTags[idx].lon;
                if (lon || lat) {
                   map.setSelectedFeature(gTaskMapConfig, undefined, lon, lat, true);

                }
                gCurrentTaskFeature.geometry.coordinates[0] = lon;
                gCurrentTaskFeature.geometry.coordinates[1] = lat;
            }
        });

        /*
         * Callback when history filter changes
         */
        $('.changes_filter').change(function () {
            showHistory(window.gChanges);
        });

        /*
         * SHow and hide the controls
         */
        $('.filtersShown').show();
        $('.filtersHidden').hide();
        $('#hideFilters').click(function(e){
            e.preventDefault();
            $('.filtersShown').hide();
            $('.filtersHidden').show();
            return false;
        });

        $('#showFilters').click(function(e){
            e.preventDefault();
            $('.filtersShown').show();
            $('.filtersHidden').hide();
            return false;
        });

	    /*
         * Custom reports
         */
	    $('.server_specific').hide();
	    var ssd = getServerSubDomainName();
	    if(ssd !== '') {
            $('.' + ssd).removeClass('d-none').show();
        }
	    $('#m_tdh_individual').click(function() {
		    $('#tdh_individual_report_popup').modal("show");
	    });
	    $('#tdh_individual_report_save').click(function() {
		    var bc = $('#tdh_rep_bc').val();
		    var link = "/surveyKPI/tdh/individual/";
		    link += $('#tdh_rep_bc').val().trim();
		    link += '/individual_report';

		    if(!bc || bc.trim().length == 0) {
			    alert("Please enter a beneficiary code");
			    return;
		    }

		    downloadFile(link);
		    $('#tdh_individual_report_popup').modal("hide");
	    });

        $('#chart_settings_save').click(function() {
            if(gSelectedChart >= 0) {   // edit
                gTasks.cache.currentData.settings.charts[gSelectedChart].subject = $('#cs_subject').val();
                gTasks.cache.currentData.settings.charts[gSelectedChart].chart_type = $('#cs_chart_type').val();
                gTasks.cache.currentData.settings.charts[gSelectedChart].question = $('#cs_question').val();
                gTasks.cache.currentData.settings.charts[gSelectedChart].label = $('#cs_chart_label').val();
                chart.replace(gTasks.cache.currentData.settings.charts[gSelectedChart], gSelectedChart);
            } else {
                var item = {
                    subject: $('#cs_subject').val(),
                    chart_type: $('#cs_chart_type').val(),
                    question:  $('#cs_question').val(),
                    label:  $('#cs_chart_label').val(),
                    color: 'rgb(0, 0, 255)'
                }
                gTasks.cache.currentData.settings.charts.push(item);
                chart.add(item);
                setupChartEdit();
            }
            $('#chart_settings_popup').modal("hide");
            chart.refresh();
            saveCharts();
        });

        // Set page defaults
        var currentTab = getFromLocalStorage("currentTab" + page);
        if(currentTab) {
            $(currentTab).trigger('click');
        } else {
            $('#table-view').trigger('click');
        }

    });         // End of document ready

    // Generate a file based on current console data
    $('.genfile').click(function (e) {
        e.preventDefault();
        var format,
            $this = $(this);

        if(!$this.hasClass("disabled")) {
            $('.genfile').addClass("disabled");
            if ($this.hasClass("xls")) {
                format = "xlsx";
            } else if ($this.hasClass("pdf")) {
                format = "pdf";
            } else if ($this.hasClass("docx")) {
                format = "docx";
            } else {
                format = "image";
            }

            $('#dashboardInfo').show().removeClass('alert-danger').addClass('alert-success').html(localise.set["msg_ds_s"]);
            setTimeout(function () {
                $('#dashboardInfo').hide();
                $('.genfile').removeClass("disabled");
            }, 5000);
            setTimeout(function () {
                genFile(false, format);         // allow message to be displayd
            }, 0);
        }
    });

    // Generate an xls file of basic counts for all data
    $('.genxlsfileall').click(function (e) {
        e.preventDefault();
        var $groupBy = $('#srf_group');
        if(gTasks.cache.currentData.schema &&  $groupBy.html().length == 0) {
            var cols = gTasks.cache.currentData.schema.columns;
            var h = [];
            var idx = -1;
            var i;
            var currentSelectQuestion = "";
            var selectQuestion = "";

            h[++idx] = '<option value="-1">';
            h[++idx] = localise.set["none"];
            h[++idx] = '</option>';

            for(i = 0; i < cols.length; i++) {

                // Don't use some types to group
                if(cols[i].type === "image" || cols[i].type === "video" || cols[i].type === "audio"
                    || cols[i].type === "prikey" || cols[i].type === "geopoint" || cols[i].type === "geoshape" || cols[i].type === "geotrace"
                    || cols[i].type === "geocompound") {

                    continue;

                }

                if(cols[i].type === "select") {
                    var n = cols[i].displayName.split(" - ");         // Handle legacy select multiple
                    if (n.length > 1) {
                        selectQuestion = n[0];
                        if(selectQuestion === currentSelectQuestion) {
                            continue;
                        } else {
                            currentSelectQuestion = selectQuestion;
                        }
                    } else {
                        selectQuestion = n;     // A compressed select multiple
                    }
                }
                h[++idx] = '<option value="';
                h[++idx] = i;
                h[++idx] = '">';
                h[++idx] = cols[i].type === "select" ? selectQuestion : cols[i].displayName;
                h[++idx] = '</option>';
            }
            $groupBy.empty().append(h.join(''));
        }
        $('#overviewReport').modal("show");
    });

    $('#overviewReportSave').click(function(e) {
        e.preventDefault();
        genFile(true, "xlsx");
        $('#overviewReport').modal("hide");
    });

    /*
     * Load the chart definitions from the server
    */
    function updateCharts(charts) {
        var i;
        chart.clear();
        for(i = 0; i < charts.length; i++) {
            chart.add(charts[i]);
        }
        setupChartEdit();

    }

    function setupChartEdit() {
        $('.fa-cog','#chartcontent').click(function(){
            gSelectedChart = $(this).data("idx");
            $('#addChartForm')[0].reset();
            $('#cs_subject').val(gTasks.cache.currentData.settings.charts[gSelectedChart].subject);
            $('#cs_chart_type').val(gTasks.cache.currentData.settings.charts[gSelectedChart].chart_type);
            $('#cs_question').val(gTasks.cache.currentData.settings.charts[gSelectedChart].question);
            $('#cs_chart_label').val(gTasks.cache.currentData.settings.charts[gSelectedChart].label);

            setChartPopupControls();
            $('#chart_settings_popup').modal("show");
        });

        $('.fa-trash','#chartcontent').click(function(){
            chart.remove($(this).data("idx"));
            gTasks.cache.currentData.settings.charts.splice($(this).data("idx"), 1);
            saveCharts();
            updateCharts(gTasks.cache.currentData.settings.charts);
            chart.refresh();
        });
    }

    /*
     * Generate a file of data
     */
    function genFile(alldata, format) {
        var url = "/surveyKPI/tables/generate",
            filename,
            mime,
            data,
            settings = [],
            groupSurvey,
            subForm,
            title = $('#survey_name option:selected').text(),
            project = $('#project_name option:selected').text(),
            charts = [],
            chartData,
            settingsObj,
            fromVal,
            toVal,
            colCount = 0,
            colName,
            colValue,
            i;

        /*
         * Get the settings
         */
        settingsObj = globals.gMainTable.settings();
        settings.push({
            k: localise.set["br_s"],
            v: settingsObj.search()
        });
        settings.push({
            k: localise.set["c_dateq"],
            v: $('#date_question :selected').text()
        });
        settings.push({
            k: localise.set["a_from_date"],
            v: $('#filter_from').val()
        });
        settings.push({
            k: localise.set["a_to_date"],
            v: $('#filter_to').val()
        });
        settings.push({
            k: localise.set["c_deleted"],
            v: $('#include_bad').prop('checked') ? localise.set["c_yes"] : localise.set["c_no"]
        });
        settings.push({
            k: localise.set["mf_cc"],
            v: $('#include_completed').prop('checked') ? localise.set["c_yes"] : localise.set["c_no"]
        });
        if(format === "xlsx" && alldata) {
            settings.push({
                k: localise.set["br_tf"],
                v: $('#srf_text_fn').val()
            });
            settings.push({
                k: localise.set["br_nf"],
                v: $('#srf_num_fn').val()
            });

            var groupIdx = $('#srf_group').val();
            if(groupIdx != -1) {
                settings.push({
                    k: "Group By",
                    v: gTasks.cache.currentData.schema.columns[groupIdx].displayName
                });
            }
        }
        colCount = globals.gMainTable.columns()[0].length;
        for (i = 0; i < colCount; i++) {
            colValue = globals.gMainTable.column(i).search();
            if (colValue && colValue.trim().length > 2) {

                settings.push({
                    k: $(globals.gMainTable.column(i).header()).find('span').text(),
                    v: colValue.substring(1, colValue.length - 1)	// Remove regexp
                });
            }

        }

        var tz = globals.gTimezone;
        var sId = globals.gCurrentSurvey;

        data = getTableData(globals.gMainTable, gTasks.cache.currentData.schema.columns, format);

        if (format === "xlsx") {
            filename = title + ".xlsx";
            mime = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        } else if (format === "pdf") {
            filename = title + ".pdf";
            mime = "application/pdf";
        } else if (format === "docx") {
            filename = title + ".docx";
            mime = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        } else {
            // image
            filename = title + ".zip"
            mime = "application/zip";
        }

        if(globals.gGroupSurveys[globals.gCurrentSurvey] && globals.gGroupSurveys[globals.gCurrentSurvey] != "") {
            groupSurvey = globals.gGroupSurveys[globals.gCurrentSurvey];
        }
        if(globals.gSubForms[globals.gCurrentSurvey] && globals.gSubForms[globals.gCurrentSurvey] != "") {
            subForm = globals.gSubForms[globals.gCurrentSurvey];
            if(subForm === '_none') {
                subForm = undefined;
            }
        }
        if(!subForm) {
            // Check that we have not drilled down
            var drillDownState;

            if(gDrillDownStack.length > 0) {
                drillDownState = gDrillDownStack[gDrillDownStack.length  - 1];
            }

            if(drillDownState) {
                sId = drillDownState.survey;

                // Set subform
                if(drillDownState.type === "sub_form") {
                    subForm = drillDownState.form;
                }
            }
        }

        if (format === "xlsx") {
            chartData = summary_report.getXLSData(alldata);
        }

        generateFile(url, filename, format, mime, data, sId, groupSurvey, title, project, charts, chartData,
            settings,
            tz,
            subForm);      // formName
    }

    /*
     * Alerts
     */
    $('#show_alerts').click(function (e) {
        e.preventDefault();
        if (!globals.gAlertSeen) {
            globals.gAlertSeen = true;
            $('.alert_icon').removeClass("text-danger");
            saveLastAlert(globals.gLastAlertTime, true);
        }
    });

    // Respond to duplicate gReports menu
    if (isDuplicates) {
        $('#duplicateSearch').click(function () {
            showDuplicateData(globals.gCurrentSurvey);
        });
    }


    /*
     * Add filtering by date et al to datatable
     */
    if (!isDuplicates) {
        $.fn.dataTableExt.afnFiltering.push(
            function (oSettings, aData, iDataIndex) {

                if(filterOutAssignments(aData)) {
                    return false;
                }
                //if(filterOutDate(aData)) {
                //    return false;
                //}
                return true;

            }
        );
    }

    /*
     * Test if this record should be filtered out based on its assignement
     */
    function filterOutAssignments(aData) {
        var myRecords = $('#my_records').prop('checked'),
            unassignedRecords = $('#unassigned_records').prop('checked'),
            otherRecords = $('#other_records').prop('checked');

        if(myRecords && unassignedRecords && otherRecords) {
            return false;
        }

        var assignment = aData[gAssignedCol];
        if(myRecords && assignment === globals.gLoggedInUser.ident) {
            return false;
        }
        if(unassignedRecords && assignment === '') {
            return false;
        }
        if(otherRecords && assignment !== '' && assignment !== globals.gLoggedInUser.ident) {
            return false;
        }
        return true;
    }

    /*
     * Function called when the current survey is changed
     */
    function mfSurveyChanged() {


        globals.gViewId = 0;        // TODO remember views set for each survey and restore

        getEligibleUsers();

        $('.editRecordSection, .bulkEditSection, .selectedOnly, .singleSelectOnly, .multiSelectOnly, .re_alert, .dd_only').hide();
        if (globals.gCurrentSurvey > 0 && typeof gTasks.gSelectedSurveyIndex !== "undefined") {

            getLanguageList(globals.gCurrentSurvey, undefined, false, '.language_sel', false, -1);
            saveCurrentProject(-1, globals.gCurrentSurvey);
            getGroupForms(globals.gCurrentSurvey);

        } else {
            // No surveys in this project
            $('#content').empty();
            gRefreshingData = false;
        }
    }

    /*
     * Function called when the current group survey is changed
     */
    function groupSurveyChanged() {

        if (globals.gCurrentSurvey > 0 && typeof gTasks.gSelectedSurveyIndex !== "undefined") {

            saveCurrentGroupSurvey(globals.gCurrentSurvey,
                globals.gGroupSurveys[globals.gCurrentSurvey],
                globals.gSubForms[globals.gCurrentSurvey]);

            showManagedData(globals.gCurrentSurvey, showTable, false);

        }
    }

    /*
     * Function called when the current sub form is changed
  */
    function subFormChanged() {

        if (globals.gCurrentSurvey > 0 && typeof gTasks.gSelectedSurveyIndex !== "undefined") {
            saveCurrentGroupSurvey(globals.gCurrentSurvey,
                globals.gGroupSurveys[globals.gCurrentSurvey],
                globals.gSubForms[globals.gCurrentSurvey]);
            showManagedData(globals.gCurrentSurvey, showTable, false);
        }
    }

    /*
     * Refresh the data used in this page
     */
    function refreshData() {

        if(!gRefreshingData) {
            gRefreshingData = true;
            //gTasks.cache.surveyConfig = {};
            gTasks.cache.managedData = {};
            gTasks.cache.surveyList = {};
            gTasks.cache.surveyRoles = {};
            gTasks.cache.recordChanges = {};
            gTasks.cache.groupForms = {};
            gTasks.cache.currentData = undefined;
            gTasks.cache.data = {};

            gGetSettings = true;

            // Get the list of available surveys
            loadManagedSurveys(globals.gCurrentProject, mfSurveyChanged);
            populatePdfSelect(globals.gCurrentSurvey, $('#select_pdf'));
            getTaskUsers(globals.gCurrentProject);	// Get the users that have access to this project
        }

    }

    /*
     * Function called when the current project is changed
     */
    function projectChanged() {

        globals.gCurrentProject = $('#project_name option:selected').val();
        globals.gCurrentSurvey = -1;
        globals.gCurrentTaskGroup = undefined;

        saveCurrentProject(globals.gCurrentProject,
            globals.gCurrentSurvey,
            globals.gCurrentTaskGroup);

        refreshData();

    }

    /*
     * Show the survey data along with the management columns
     */
    function showManagedData(sId, callback, clearCache) {

        var groupSurvey,
            subForm,
	        drillDownState;

        if(gDrillDownStack.length > 0) {
        	drillDownState = gDrillDownStack[gDrillDownStack.length  - 1];
        }

        if(drillDownState) {
            sId = drillDownState.survey;
        }

        // Set subform
        if(drillDownState && drillDownState.type === "sub_form") {
            subForm = drillDownState.form;
        } else {
            if (globals.gSubForms[sId] && globals.gSubForms[sId] != "") {
                subForm = globals.gSubForms[sId];
                if (subForm === '_none') {
                    subForm = undefined;
                }
            }
        }


        // Set Group survey
	    if (globals.gGroupSurveys[sId] && globals.gGroupSurveys[sId] != "") {
		    groupSurvey = globals.gGroupSurveys[sId];
	    }

        getData(sId, groupSurvey, subForm, callback, clearCache);
    }

    /*
     * Show the table
     */
    function showTable(dataSet) {

        var x = 1,
            columns,
            parameters,
            shownColumns = [],
            hiddenColumns = [],
            visibleColumns = [],
            h = [],
            idx = -1,
            hfoot = [],
            foot_idx = -1,
            i, j,
            $table = $("#trackingTable"),
            doneFirst = false,
            headItem,
            hColSort = [],
            hDups = [],
            hSelect = [],
            hColSortIdx = -1,
            hDupsIdx = -1,
            hSelectIdx = -1;


        if ( $.fn.dataTable.isDataTable( $table) && globals.gMainTable) {
            globals.gMainTable.destroy();
        }

        if(dataSet.schema) {
            columns = dataSet.schema.columns;
        } else {
            columns = [];
        }

        // Add table
        //h[++idx] = '<table id="trackingTable" style="width:100%">';

        // Add head
        h[++idx] = '<thead>';
        h[++idx] = '<tr>';

        for (i = 0; i < columns.length; i++) {
            headItem = columns[i];

            hColSort[++hColSortIdx] = addToColumnSort(headItem);
            hSelect[++hSelectIdx] = addToColumnSelect(headItem);
            if(isDuplicates) {
                hDups[++hDupsIdx] = addToDuplicateReportSelect(headItem);
            }

            shownColumns.push({
                "data": headItem.column_name
            });
            h[++idx] = '<th>';
            h[++idx] = '<span class="ch">';
            h[++idx] = htmlEncode(headItem.displayName);
            h[++idx] = '</span>';
            h[++idx] = '</th>';
            hfoot[++foot_idx] = '<th></th>';

            if (headItem.hide) {
                hiddenColumns.push(i);
            } else {
                visibleColumns.push(i);
            }
        }
        h[++idx] = '</tr>';


        h[++idx] = '</thead>';
        h[++idx] = '<tfoot>';
        h[++idx] = '<tr>';
        h[++idx] = hfoot.join('');
        h[++idx] = '</tr>';
        h[++idx] = '</tfoot>';

        // close table
       // h[++idx] = '</table>';

        $table.empty().html(h.join(''));

        /*
         * Apply data tables
         */
        $.fn.dataTable.ext.errMode = 'none';

        // Create data table
        globals.gMainTable = $table.DataTable({
            processing: true,
            scrollY: '70vh',
            scrollX: true,
            scrollCollapse: true,
            select: {
                selector: 'td:not(:first-child)'
            },
            rowId: 'instanceid',
            data: dataSet.data,
            columns: shownColumns,
            order: [0],
            initComplete: function (settings, json) {

                if(parameters && parameters.form_data === 'off') {
                    $('.manageFormData').hide();
                    $('.showFormData').hide();
                    $('.showMgmtData').addClass('col-sm-12').removeClass('col-sm-6');
                }

                this.api().columns().every(function (colIdx) {
                    if (columns[colIdx].filter || columns[colIdx].type === "select1") {
                        var column = this;
                        var select = $('<select class="form-control"/>')
                            .appendTo( $(column.footer()).empty())
                            .on('change', function () {
                                var val = $.fn.dataTable.util.escapeRegex(
                                    $(this).val()
                                );

                                column
                                    .search( val ? '^'+val+'$' : '', true, false )
                                    .draw();

                                saveFilter(colIdx, val);
                            });

                        select.append( '<option value=""></option>' );
                        column.data().unique().sort().each( function ( d, j ) {
                            select.append( '<option value="'+d+'">'+d+'</option>' )
                        } );

                        // Set current value
                        if (columns[colIdx].filterValue) {
                            select.val(columns[colIdx].filterValue).trigger('change');
                        }
                    }

                });
            },

            columnDefs: [
                {
                    targets: "_all",
                    render: function (data, type, full, meta) {
                        return addAnchors(data, true).join(',');
                    }
                },
                {
                    visible: false,
                    "targets": hiddenColumns
                },
                {
                    visible: true,
                    "targets": visibleColumns
                }
            ],
            language: {
                url: localise.dt()
            }
        });

        // Respond to an error
        globals.gMainTable.on('error.dt', function (e, settings, techNote, message) {
            alert(localise.set["c_error"] + ": " + message);
            gRefreshingData = false;
        });

        // Respond to selection of a row
        globals.gMainTable.off('select').on('select', function (e, dt, type, indexes) {
            recordSelected(globals.gMainTable.rows('.selected').data());
        });
        globals.gMainTable.off('deselect').on('deselect', function (e, dt, type, indexes) {
            recordSelected(globals.gMainTable.rows('.selected').data());
        });

        // Highlight data conditionally, set barcodes
        tableOnDraw();
        globals.gMainTable.off('draw').on('draw', function () {
            tableOnDraw();
        });

        // Respond to filter changes that require the server to be queried
        $('.table_filter').focusout(function () {
            showManagedData(globals.gCurrentSurvey, showTable, true);
        });

        // Respond to changes that filter data on assignment
        $('.assign_filter').change(function () {
            globals.gMainTable.draw();

            gLocalDefaults.myRecords = $('#my_records').prop('checked');
            gLocalDefaults.unassignedRecords = $('#unassigned_records').prop('checked');
            gLocalDefaults.otherRecords = $('#other_records').prop('checked');
            setInLocalStorage("console", JSON.stringify(gLocalDefaults));
        });

        // Respond to change of search
        $('#trackingTable_filter input').focusout(function () {
            globals.gMainTable.draw();
        });

        /*
         * Settings
         */
        $('#tab-columns-content').html(hColSort.join(''));
        $('#cs_question').html(hSelect.join(''));

        /*
         * Duplicates modal
         */
        if(isDuplicates) {
            $('#duplicateSelect').html(hDups.join(''));
        }

    }

    /*
     * Set context specific controls in chart dialog
     */
    function setChartPopupControls() {
        var subject = $('#cs_subject').val();

        $('.qonly').hide();

        if(subject === 'question') {
            $('.qonly').show();
        }
    }

    /*
     * Show duplicates data
     */
    function showDuplicateData(sId) {

        var searchCriteria = getSearchCriteria();
        var url = '/api/v1/data/similar/' + sId + '/' + searchCriteria + "?format=dt";
        url += "&tz=" + encodeURIComponent(globals.gTimezone);

        if(searchCriteria && searchCriteria.length > 0) {
            globals.gMainTable.ajax.url(url).load();
        }

    }

    /*
     * Get the search criteria for a duplicate search
     */
    function getSearchCriteria() {
        var criteria = "";

        $('input', '#duplicateSelect').each(function (index) {
            var $this = $(this),
                fn;

            if ($this.is(':checked')) {
                if (criteria.length > 0) {
                    criteria += ',';
                }
                fn = $this.closest('.row').find('select').val();
                criteria += $this.val() + '::' + fn;
            }

        });

        return criteria;
    }

    /*
     * Add the column to the settings
     */
    function addToColumnSort(item) {
        var h = [],
            idx = -1;

        if (item.include || item.column_name === "prikey") {
            h[++idx] = '<div class="row">';
            h[++idx] = '<div class="col-sm-6">';
            h[++idx] = htmlEncode(item.displayName);
            h[++idx] = '</div>';

            h[++idx] = '<div class="col-sm-2">';
            h[++idx] = '<div class="switch">';
            h[++idx] = '<input type="checkbox" name="columnSelect"';
            h[++idx] = ' class="columnSelect" value="';
            h[++idx] = item.displayName;
            h[++idx] = '"';
            if(!item.hide) {
            	h[++idx] = ' checked';
            }
            h[++idx] = '>';
            h[++idx] = '</div>';
            h[++idx] = '</div>';

            h[++idx] = '<div class="col-sm-2">';
            h[++idx] = '<div class="switch">';
            h[++idx] = '<input type="checkbox" name="barcodeSelect"';
            h[++idx] = ' class="barcodeSelect" value="';
            h[++idx] = item.displayName;
            h[++idx] = '"';
            if(item.barcode) {
                h[++idx] = ' checked';
            }
            h[++idx] = '>';
            h[++idx] = '</div>';
            h[++idx] = '</div>';

            h[++idx] = '<div class="col-sm-2">';
            h[++idx] = '<div class="switch">';
            h[++idx] = '<input type="checkbox" name="includeText"';
            h[++idx] = ' class="includeText" value="';
            h[++idx] = item.displayName;
            h[++idx] = '"';
            if(item.includeText) {
                h[++idx] = ' checked';
            }
            h[++idx] = '>';
            h[++idx] = '</div>';
            h[++idx] = '</div>';

            h[++idx] = '</div>';
        }
        return h.join('');
    }

    /*
     * Add the column to column select
    */
    function addToColumnSelect(item) {
        var h = [],
            idx = -1;

        if (item.include) {
            h[++idx] = '<option value="';
            h[++idx] = item.displayName;
            h[++idx] = '">';
            h[++idx] = htmlEncode(item.displayName);
            h[++idx] = '</option>';
        }
        return h.join('');
    }

    /*
     * Add the column to the select list for duplicate searches
     */
    function addToDuplicateReportSelect(item) {
        var h = [],
            idx = -1;

        if (item.include && !item.mgmt) {
            h[++idx] = '<div class="row">';
            //h[++idx] = '<div class="setings-item">';

            h[++idx] = '<div class="col-sm-1">';
            h[++idx] = '<input type="checkbox" name="columnSelect"';
            h[++idx] = ' class="columnSelect" value="';
            h[++idx] = item.displayName;
            h[++idx] = '"';
            h[++idx] = '>';
            h[++idx] = '</div>';

            h[++idx] = '<div class="col-sm-4">';
            h[++idx] = '<span>';
            h[++idx] = item.displayName;
            h[++idx] = '</span>';
            h[++idx] = '</div>';


            h[++idx] = '<div class= "col-sm-4">';
            h[++idx] = '<select>';
            h[++idx] = '<option value="exact">';
            h[++idx] = localise.set["br_exact"];
            h[++idx] = '</option>';
            h[++idx] = '<option value="lower">';
            h[++idx] = localise.set["br_ci"];
            h[++idx] = '</option>';
            h[++idx] = '<option value="soundex">';
            h[++idx] = localise.set["br_sdx"];
            h[++idx] = '</option>';
            h[++idx] = '</select>';
            h[++idx] = '</div>';

            h[++idx] = '</div>';		// Row

        }
        return h.join('');
    }

    /*
     * Get surveys and update the survey lists on this page
     *  This is a different function from the common loadSurveys function as processing differs depending on whether
     *    there is a managed form
     *   applied to the survey
     */
    function loadManagedSurveys(projectId, callback) {

        var url = "/surveyKPI/surveys?projectId=" + projectId + "&blocked=true",
            $elemSurveys = $('#survey_name');


        if (typeof projectId !== "undefined" && projectId != -1 && projectId != 0) {

            addHourglass();
            $.ajax({
                url: url,
                dataType: 'json',
                cache: false,
                success: function (data) {

                    var i,
                        item,
                        h = [],
                        idx = -1,
                        firstSurvey = true,
                        firstSurveyId = undefined,
                        firstSurveyIndex = undefined;

                    removeHourglass();

                    gTasks.cache.surveyList[globals.gCurrentProject] = data;
                    gTasks.gSelectedSurveyIndex = undefined;

                    for (i = 0; i < data.length; i++) {
                        item = data[i];

                        if(item.dataSurvey) {
                            h[++idx] = '<option value="';
                            h[++idx] = i;
                            h[++idx] = '">';
                            h[++idx] = htmlEncode(item.displayName);
                            h[++idx] = '</option>';

                            if (firstSurvey) {
                                firstSurveyId = item.id;
                                firstSurveyIndex = i;
                                firstSurvey = false;
                            }

                            if (item.id == globals.gCurrentSurvey) {
                                gTasks.gSelectedSurveyIndex = i;
                            }
                        }
                    }

                    $elemSurveys.empty().html(h.join(''));

                    if (!gTasks.gSelectedSurveyIndex && firstSurveyId) {
                        globals.gCurrentSurvey = firstSurveyId;
                        gTasks.gSelectedSurveyIndex = firstSurveyIndex;
                    } else if (gTasks.gSelectedSurveyIndex && firstSurveyId) {
                        $elemSurveys.val(gTasks.gSelectedSurveyIndex);
                    }

                    if (typeof callback == "function") {
                        callback();
                    } else {
                        gRefreshingData = false;
                    }
                },
                error: function (xhr, textStatus, err) {

                    removeHourglass();
                    gRefreshingData = false;
                    if (xhr.readyState == 0 || xhr.status == 0) {
                        return;  // Not an error
                    } else {
                        console.log(localise.set["c_error"] + ": " + err);
                    }
                }
            });
        } else {
            gRefreshingData = false;
        }
    }

    /*
     * Get Forms in the current surveys group
     */
    function getGroupForms(surveyId) {

        groupSurveyChanged();       // Can finally retrieve the data

        if (typeof surveyId !== "undefined" && surveyId > 0) {

            if(gTasks.cache.groupSurveys[surveyId]) {
                groupsRetrieved(gTasks.cache.groupSurveys[surveyId]);
            } else {

                var url = "/surveyKPI/surveyResults/" + surveyId + "/groups",
                    survey = surveyId;

                addHourglass();
                $.ajax({
                    url: url,
                    dataType: 'json',
                    cache: false,
                    success: function (data) {
                        removeHourglass();
                        gTasks.cache.groupSurveys[survey] = data;
                        groupsRetrieved(data);
                    },
                    error: function (xhr, textStatus, err) {
                        removeHourglass();
                        if (xhr.readyState == 0 || xhr.status == 0) {
                            return;  // Not an error
                        } else {
                            console.log(localise.set["c_error"] + ": " + err);
                        }
                    }
                });
            }
        }
    }

    /*
     * Update the group selector
     */
    function groupsRetrieved(data) {

        setOversightSelector(data);
        setGroupSelector(data);

    }

    /*
     * Update a selector that is used for oversight forms and does not include current form
     */
    function setOversightSelector(data) {
        var $elemGroups = $('#group_survey');

        var i,
            item,
            h = [],
            idx = -1;

        h[++idx] = '<option value="';
        h[++idx] = '">';
        h[++idx] = localise.set["c_none"];
        h[++idx] = '</option>';

        for (i = 0; i < data.length; i++) {
            item = data[i];

            if (item.sId !== globals.gCurrentSurvey && item.oversightSurvey) {       // Don't include current survey

                h[++idx] = '<option value="';
                h[++idx] = item.surveyIdent;
                h[++idx] = '">';
                h[++idx] = htmlEncode(item.surveyName);
                h[++idx] = '</option>';

            }
        }

        $elemGroups.empty().html(h.join(''));

        /*
		 * Set the value
		 */
        if(globals.gCurrentSurvey > 0 && globals.gGroupSurveys
            && globals.gGroupSurveys[globals.gCurrentSurvey]
            && globals.gGroupSurveys[globals.gCurrentSurvey] != "") {

            var val = globals.gGroupSurveys[globals.gCurrentSurvey];
            var exists = false;
            for(i = 0; i < data.length; i++) {
                if (data[i].surveyIdent === val) {
                    exists = true;
                    break;
                }
            }
            if(exists) {
                $elemGroups.val(val);
            } else {
                $elemGroups.val("");
                globals.gGroupSurveys[globals.gCurrentSurvey] = undefined;
                groupSurveyChanged();
            }
        } else {
            $elemGroups.val("");        // None
        }
    }

    /*
     * Update a selector that is used for any data survey in a group
     */
    function setGroupSelector(data) {
        var $elemGroups = $('#tp_form_name, #survey');


        var i,
            item,
            h = [],
            idx = -1;

        for (i = 0; i < data.length; i++) {
            item = data[i];

            if (item.dataSurvey) {
                h[++idx] = '<option value="';
                h[++idx] = item.surveyIdent;
                h[++idx] = '">';
                h[++idx] = item.surveyName;
                h[++idx] = '</option>';
            }

        }

        $elemGroups.empty().html(h.join(''));

    }

    /*
     * Update the pick list of forms
     */
    function updateFormList(data) {
        var $elem = $('#sub_form');

        var i,
            h = [],
            idx = -1;

        h[++idx] = '<option value="_none">';
        h[++idx] = localise.set["c_none"];
        h[++idx] = '</option>';

        if(data && data.length) {
            for (i = 0; i < data.length; i++) {

                if(data[i].type === 'sub_form') {
                    h[++idx] = '<option value="';
                    h[++idx] = data[i].name;
                    h[++idx] = '">';
                    h[++idx] = data[i].name;
                    h[++idx] = '</option>';
                }
            }
        }

        $elem.empty().html(h.join(''));
        if(globals.gSubForms[globals.gCurrentSurvey]) {
            $elem.val(globals.gSubForms[globals.gCurrentSurvey]);
        }

    }

    /*
     * Update the drill down list of forms
     */
    function updateDrillDownFormList() {
        var $drillDown = $('#drill_down_list'),
            data = gTasks.cache.currentData.forms;

        var i,
            h = [],
            idx = -1,
            setDefault = false,
	        parentForm,
	        drillDownState;

        if(gDrillDownStack.length > 0) {
        	drillDownState = gDrillDownStack[gDrillDownStack.length - 1];
        }

        if(drillDownState) {
            if(drillDownState.type === 'sub_form') {
                parentForm = drillDownState.form;
            } else {
                parentForm = "main";
            }
        } else {
		    parentForm = $('#sub_form').val();
		    if(parentForm === "_none") {
			    parentForm = "main";
		    }
	    }

	    $('#dd_form').html("");
	    gDrillDownNext = undefined;

        if(data && data.length) {

            for (i = 0; i < data.length; i++) {
                // Add to drill down
                if (parentForm && data[i].parentName == parentForm) {
                    h[++idx] = '<a class="dropdown-item dd_form" href="#" data-form="';
                    h[++idx] = data[i].name;
                    h[++idx] = '"';
                    h[++idx] = ' data-type="';
                    h[++idx] = data[i].type;
	                h[++idx] = '"';

                    if(data[i].surveyId) {
	                    h[++idx] = ' data-survey="';
	                    h[++idx] = data[i].surveyId;
	                    h[++idx] = '"';
                    }

	                if(data[i].keyQuestion) {
		                h[++idx] = ' data-key="';
		                h[++idx] = data[i].keyQuestion;
		                h[++idx] = '"';
	                }

                    h[++idx] = '>';
                    h[++idx] = data[i].name;
                    h[++idx] = '</a>';

                    if(!setDefault) {
                        $('#dd_form').html(data[i].name);

                        gDrillDownNext = {
	                        form: data[i].name,
	                        type: data[i].type,
	                        survey: data[i].surveyId,
	                        key: data[i].keyQuestion
                        }
                        setDefault = true;
                    }
                }
            }

        }

        $drillDown.empty().html(h.join(''));

        // Respond to selection of a form to drill down to:
        $('.dd_form', $drillDown).click(function(){
            var $this = $(this);
            $('#dd_form').html($this.data("form"));
            gDrillDownNext = {
	            form: $this.data("form"),
	            type: $this.data("type"),
	            survey: $this.data("survey"),
	            key: $this.data("key")
            }
            drillDown();
        });

    }

    function updateVisibleColumns(cols) {
        var i,
            hiddenColumns = [],
            visibleColumns = [];

        for (i = 0; i < cols.length; i++) {
            if (cols[i].hide) {
                hiddenColumns.push(i);
            } else {
                visibleColumns.push(i);
            }
        }

        globals.gMainTable.columns(hiddenColumns).visible(false, false);
        globals.gMainTable.columns(visibleColumns).visible(true, false);
        $('#trackingTable').width('auto');
        globals.gMainTable.columns.adjust().draw(); // adjust column sizing and redraw
    }

    /*
     * Save a filter setting
     */
    function saveFilter(column, value) {

        var
            config = gTasks.cache.currentData.schema,
            i;

        if (value == '') {
            value = undefined;
        }

        for (i = 0; i < config.columns.length; i++) {
            if (config.columns[i].colIdx == column) {
                config.columns[i].filterValue = value;
                break;
            }
        }

        saveConfig(config);
    }

    /*
     * Save the current charts configuration
     */
    function saveCharts() {

        var saveView = JSON.stringify(gTasks.cache.currentData.settings.charts);

        var url = "/surveyKPI/charts/save/" + globals.gCurrentSurvey;

        addHourglass();
        $.ajax({
            type: "POST",
            cache: false,
            contentType: "application/json",
            url: url,
            data: {chartArray: saveView},
            success: function (data, status) {
                removeHourglass();
            }, error: function (data, status) {
                removeHourglass();
                alert(data.responseText);
            }
        });
    }

    /*
     * Update the saved configuration
     */
    function saveColumns() {
        var configColumns = {},
            columns = gTasks.cache.currentData.schema.columns,
            i;

        for (i = 0; i < columns.length; i++) {
            configColumns[columns[i].column_name] = {
                hide: columns[i].hide,
                barcode: columns[i].barcode,
                includeText: columns[i].includeText

            };
        }

        var saveView = JSON.stringify(configColumns);

        var url = "/surveyKPI/survey/" + globals.gCurrentSurvey + "/console_settings/columns";

        addHourglass();
        $.ajax({
            type: "POST",
            cache: false,
            contentType: "application/json",
            url: url,
            data: {columns: saveView},
            success: function (data, status) {
                removeHourglass();
	            showManagedData(globals.gCurrentSurvey, showTable, false); // redraw
                $('#right-sidebar').removeClass("sidebar-open");
            }, error: function (data, status) {
                removeHourglass();
                alert(data.responseText);
            }
        });
    }

    /*
     * Perform initialisation after the data has been loaded
     */
    function initialiseColumns() {


        var columns = gTasks.cache.currentData.schema.columns,
            i,
            h = [],
            idx = -1,
            select_questions = {};

        /*
         * Add an indicator to columns if they can be used as a chart question in summary reports
         * Merge choices in select multiples
         */

        for(i = 0; i < columns.length; i++) {
            var d = columns[i];

            if(
                d.displayName !== "prikey" &&
                d.displayName !== "_upload_time" &&
                d.displayName !== "_start" &&
                d.displayName !== "_end" &&
                d.type !== "geopoint" &&
                d.type !== "dateTime" &&
                d.type !== "time" &&
                d.type !== "date" &&
                d.type !== "image" && d.type !== "video" && d.type !== "audio") {
                d.chartQuestion = true;
            } else {
                d.chartQuestion = false;
            }

            if(d.type === "select") {
                var n = d.displayName.split(" - ");
                if (n.length > 1) {

                    if (!select_questions[n[0]]) {		// New choice

                        d.select_name = n[0];
                        d.choices = [];
                        d.choiceNames = [];
                        d.choices.push(d.displayName);
                        d.choiceNames.push(d.displayName);

                        select_questions[n[0]] = d;
                        d.chartQuestion = true;
                    } else {
                        var f = select_questions[n[0]];
                        f.choices.push(d.displayName);
                        f.choiceNames.push(d.displayName);
                        d.chartQuestion = false;
                    }
                }
            } else if(d.type === "dateTime" || d.type === "date") {

                    h[++idx] = '<option value="';
                    h[++idx] = columns[i].column_name;
                    h[++idx] = '">';
                    h[++idx] = htmlEncode(columns[i].displayName);
                    h[++idx] = '</option>';
            } else if (d.displayName === '_assigned') {
                gAssignedCol = i;
            }

        }
        
        $('#date_question').empty().html(h.join(''));
    }

    function exitEdit() {
        if(gTasks.gUpdate.length > 0) {
            if (!confirm(localise.set["c_unsav"])) {
                return;
            } else {
                gTasks.gUpdate = [];
            }
        }
        $('.overviewSection,.mrview').show();
        $('.editRecordSection,.bulkEditSection,.srview,.re_alert').hide();
    }

    /*
     * Respond to a map feature being selected
     */
    function featureSelected(properties) {
        var data = [];
        var indexes = [];
        if(properties && properties.length > 0) {
            for(i = 0; i < properties.length; i++) {
                indexes.push(properties[i].record);
            }
            data = globals.gMainTable.rows(indexes).data().toArray();

            showSelectedMapData(properties);

        } else {
            $('#features').hide().empty();
        }
        recordSelected(data);

    }

    /*
     * Show data from features selected on a map
     */
    function showSelectedMapData(properties) {

        var schema = gTasks.cache.currentData.schema,
            $element = $('#features'),
            columns = schema.columns,
            configItem,
            i, j,
            h = [],
            idx = -1,
            records = [];

        h[++idx] = '<img id="fDel" src="/app/fieldAnalysis/img/delete.png"/><br/>';
        h[++idx] = '<div id="feature_data">';
        if(properties.length > 0) {

            for(i = 0; i < properties.length; i++) {
                records.push(globals.gMainTable.rows(properties[i].record).data().toArray()[0]);
            }
            h[++idx] = '<div class="row">';
            h[++idx] = '<div class="col-md-12 col-xs-12 table-responsive billing_enabled">';
            h[++idx] = '<table class="table table-striped">';
            h[++idx] = '<tbody>';
            // Add data
            for (i = 0; i < columns.length; i++) {
                configItem = columns[i];
                if(configItem.type === 'geopoint' || configItem.type === 'geotrace' || configItem.type === 'geoshape'
                    || configItem.type === 'geocompound') {
                    continue;
                }
                h[++idx] = '<tr>';
                h[++idx] = addCell(translateKey(configItem.displayName));
                for(j = 0; j < properties.length; j++) {
                    h[++idx] = addCell(translateKeyValue(configItem.displayName, records[j][configItem.column_name]));
                }
                h[++idx] = '</tr>';
            }
            // End data
            h[++idx] = '</tbody>';
            h[++idx] = '</table>';
            h[++idx] = '</div>';
            h[++idx] = '</div>';
        }
        h[++idx] = '</div>';

        $element.html(h.join('')).show();
        $('#fDel', $element).off().click(function() {	// Closing the panel manually
            $("#features").hide().empty();
        });


    }

    /*
	 * Get the markup to show features
	 */
    function addCell(item) {

        var h = [],
            idx = -1;

        // Add form group and label
        h[++idx] = '<td>';
        h[++idx] = addAnchors(item, true);
        h[++idx] = '</td>';


        return h.join('');
    }

    /*
     * Respond to a record of data being selected
     */
    function recordSelected(records) {

        var assignedOther = false,
            i;

        $('.selectOnly, .multiSelectOnly, .singleSelectOnly').hide();
        $('.dd_only,.du_only').hide();

        gTasks.gSelectedRecord = undefined;
        gTasks.gBulkInstances = [];

        for(i = 0; i < records.length; i++) {
            gTasks.gBulkInstances.push(records[i].instanceid);
        }

        if(records.length === 0) {
            /*
			 * No records are selected
			 */
            gTasks.gSelectedRecord = undefined;
            $('.selectOnly, .dd_only').hide();

        } else if(records.length > 1) {
            /*
             * Multiple records are selected
             */

            // Set selected record to first record selected
            //gTasks.gSelectedRecord = globals.gMainTable.rows(gTasks.gSelectedIndexes).data().toArray()[0];
            gTasks.gSelectedRecord = records[0];

            // Store the record indexes that will need to be updated
            //var records = globals.gMainTable.rows(gTasks.gSelectedIndexes).data().toArray();
            //for(i = 0; i < gTasks.gSelectedIndexes.length; i++) {
            //    gTasks.gBulkInstances.push(records[i].instanceid);
            //}
            for(i = 0; i < records.length; i++) {
                gTasks.gBulkInstances.push(records[i].instanceid);
            }

            $('.multiSelectOnly').show();

        } else {
            /*
			 * Only a single record is selected
			 */
            //gTasks.gSelectedRecord = globals.gMainTable.rows(gTasks.gSelectedIndexes).data().toArray()[0];
            gTasks.gSelectedRecord = records[0];
            if (gTasks.gSelectedRecord._assigned && gTasks.gSelectedRecord._assigned === globals.gLoggedInUser.ident) {
                $('.assigned').show();
            } else if (gTasks.gSelectedRecord._assigned && gTasks.gSelectedRecord._assigned !== globals.gLoggedInUser.ident) {
                $('.assigned_other').show();
                assignedOther = true;
            } else {
                $('.not_assigned').show();
            }

            // Set up the drill down
            if(gDrillDownStack.length > 0) {
                $('.du_only').show();
            }

            updateDrillDownFormList();
            if(gDrillDownNext) {
                $('.dd_only').show();
            }

            var columns = gTasks.cache.currentData.schema.columns;
            if(!assignedOther) {
                if ((gDeleteColumn < 0 || gTasks.gSelectedRecord[columns[gDeleteColumn].question_name] === 'f')) {
                    $('.not_deleted').show();
                } else if (gDeleteColumn >= 0 && gTasks.gSelectedRecord[columns[gDeleteColumn].question_name] === 't') {
                    $('.deleted').show();
                }
            }

            if(globals.gIsAdministrator) {
                $('.assigned_admin').show();
            }

        }

    }

    /*
     * Set up the user defaults on the page
     * TODO restore these from local session storage
     */
    function userDefaults() {
        $('#my_records').prop('checked', true);
        $('#unassigned_records').prop('checked', true);
        $('#other_records').prop('checked', true);
    }

    /*
     * Get the list of changes to this record from the server
     */
    function getRecordChanges(record) {

        if(record && globals.gCurrentSurvey) {
            addHourglass();
            $.ajax({
                url: "/api/v1/data/changes/" + globals.gCurrentSurvey + "/" + record["instanceid"] +
                    '?tz=' + encodeURIComponent(globals.gTimezone),
                dataType: 'json',
                cache: false,
                success: function (data) {
                    removeHourglass();
                    window.gChanges = data;
                    globals.gRecordChangeMaps = [];     // Initialise the list of maps we are going to show

                    showHistory(data);

                },
                error: function (xhr, textStatus, err) {
                    removeHourglass();
                    if (xhr.readyState == 0 || xhr.status == 0) {
                        return;  // Not an error
                    } else {
                        alert(localise.set["error"] + ": " + err);
                    }
                }
            });
        }
    }

    function showHistory(data) {
        var h = [],
            idx = -1,
            $elem = $('#changes'),
            i,
            finish,
            statusClass;

        var includeTasks = $('#er_show_tasks').is(':checked');
        var includeNotifications = $('#er_show_notifications').is(':checked');
        var includeChanges = $('#er_show_changes').is(':checked');
        var includeAssignments = $('#er_show_assignments').is(':checked');

        // Add header
        h[++idx] = '<thead>';
        h[++idx] = '<tr>';
        h[++idx] = '<th></th>';     // icon
        h[++idx] = '<th class="mincol">';
        h[++idx] = localise.set["c_user"];
        h[++idx] = '</th>';
        h[++idx] = '<th class="mincol">';
        h[++idx] = localise.set["c_survey"];
        h[++idx] = '</th>';
        h[++idx] = '<th class="mincol">';
        h[++idx] = localise.set["c_date"];
        h[++idx] = '</th>';
        h[++idx] = '<th class="mincol">';
        h[++idx] = localise.set["c_event"];
        h[++idx] = '</th>';
        h[++idx] = '<th class="mincol">';
        h[++idx] = localise.set["c_status"];
        h[++idx] = '</th>';
        h[++idx] = '<th>';
        h[++idx] = localise.set["c_details"];
        h[++idx] = '</th>';
        h[++idx] = '<th class="mincol">';
        h[++idx] = localise.set["c_action"];
        h[++idx] = '</th>';
        h[++idx] = '</tr>';
        h[++idx] = '</thead>';

        h[++idx] = '<tbody>';
        if(data && data.length > 0) {
            for(i = 0; i < data.length; i++) {

                if((includeChanges && (data[i].event === 'changes' || data[i].event === 'created')) ||
                    (includeTasks && data[i].event === 'task') ||
                    (includeAssignments && data[i].event === 'assigned') ||
                    (includeNotifications && data[i].event === 'notification')) {
                    h[++idx] = '<tr>';

                    h[++idx] = '<td>';
                    if (data[i].event === 'task') {
                        h[++idx] = '<i class="fa fa-lg fa-tasks fa-2x"></i>';
                    } else if (data[i].event === 'created' || data[i].event === 'changes') {
                        h[++idx] = '<i style="line-height: 1.5em;" class="fa fa-lg fa-inbox fa-2x"></i>';
                    } else if (data[i].event === 'notification') {
                        if (data[i].notification && data[i].notification.target === 'sms') {
                            // From http://jsfiddle.net/4Bacg/
                            h[++idx] = '<span style="line-height: 1.5em; text-align: center; margin-top: -7px; margin-right: 0.3em;" class="fa-stack fa-lg pull-left">';
                            h[++idx] = '<i class="fa fa-flip-horizontal fa-comment-o fa-stack-2x"></i>';
                            h[++idx] = '<i style="font-size: 10px; line-height: 1em;">sms</i>';
                            h[++idx] = '</span>';
                        } else {
                            h[++idx] = '<i class="fa fa-lg fa-envelope-o fa-2x"></i>';
                        }
                    }

                    h[++idx] = '</td>';
                    h[++idx] = '<td class="mincol">';    // user
                    if(data[i].userName) {
                        h[++idx] = htmlEncode(data[i].userName);
                    }
                    h[++idx] = '</td>';

                    h[++idx] = '<td class="mincol">';    // Survey
                    if(data[i].surveyName) {
                        h[++idx] = htmlEncode(data[i].surveyName) + ' (' + data[i].surveyVersion + ')';
                    }
                    h[++idx] = '</td>';

                    h[++idx] = '<td class="mincol">';    // when
                    h[++idx] = htmlEncode(data[i].eventTime);
                    h[++idx] = '</td>';

                    h[++idx] = '<td class="mincol">';    // event
                    if(data[i].event === 'assigned') {
                        h[++idx] = htmlEncode(localise.set['t_assign']);
                    } else {
                        h[++idx] = htmlEncode(localise.set[data[i].event]);
                    }
                    h[++idx] = '</td>';

                    h[++idx] = '<td class="mincol ';    // status
                    finish = getFinish(data[i]);
                    statusClass = getStatusClass(data[i].status, data[i].assign_auto);
                    h[++idx] = statusClass;
                    h[++idx] = '">';
                    if(statusClass == 'bg-danger') {
                        h[++idx] = localise.set["c_late"];
                    } if(statusClass == 'bg-orange') {
                        h[++idx] = localise.set["t_auto2"];
                    } else {
                        h[++idx] = localise.set[data[i].status];
                    }

                    h[++idx] = '</td>';

                    h[++idx] = '<td>';    // Changes
                    if (data[i].event === 'changes' && data[i].changes) {
                        h[++idx] = getChangeCard(data[i].changes, i);
                    } else if (data[i].event === 'task' && data[i].task) {
                        h[++idx] = getTaskCard(data[i].task, i);
                    } else if (data[i].event === 'notification' && data[i].notification) {
                        h[++idx] = getNotificationInfo(data[i].notification, data[i].description);
                    } else {
                        h[++idx] = htmlEncode(data[i].description);
                    }
                    h[++idx] = '</td>';

                    h[++idx] = '<td class="mincol">';    // Action
                    if (data[i].event === 'notification' && data[i].notification) {
                        h[++idx] = '<button class="btn btn-secondary edit_notification" data-idx="';
                        h[++idx] = i;
                        h[++idx] = '">';
                        h[++idx] = localise.set["c_resend"];
                        h[++idx] = '</button>';
                    } else  if (data[i].event === 'task' && data[i].task && data[i].status !== 'cancelled') {
                        h[++idx] = '<button class="btn btn-secondary edit_task" data-idx="';
                        h[++idx] = i;
                        h[++idx] = '">';
                        h[++idx] = localise.set["t_edit_task"];
                        h[++idx] = '</button>';
                    }
                    h[++idx] = '</td>';

                    h[++idx] = '</tr>';    // row
                }

            }
        }
        h[++idx] = '</tbody>';
        $elem.empty().html(h.join(''));

        $('.change_card').on('shown.bs.collapse', function() {
            var $this = $(this);
            $('.card-body > .row > .small_map', $this).each(function(){
                console.log($(this).attr("id"));
                actioncommon.initialiseDynamicMaps(globals.gRecordChangeMaps, $(this).attr("id"));
            });
        });
        $('.change_card').on('show.bs.collapse', function() {
            $('.mincol').hide();
        });
        $('.change_card').on('hidden.bs.collapse', function() {
            $('.mincol').show();
        });

        $('.edit_notification').click(function(){
            var n = {
                notifyDetails: {

                }
            };
            var idx = $(this).data("idx");
            var nMessage = window.gChanges[idx].notification
            n.target = nMessage.target;
            n.s_id = nMessage.survey_ident;     // Confusing yes - for notifications this is still id, wheras for console this is the ident
            n.notifyDetails.subject = nMessage.subject;
            n.notifyDetails.content = nMessage.content;
            n.notifyDetails.attach = nMessage.attach;
            n.notifyDetails.emails = nMessage.emails;
            window.gNotifications = [];
            window.gNotifications.push(n);

            $('#saveNotification').html(localise.set["c_resend"]);
            edit_notification(true,0, true);
            $('#addNotificationPopup').modal("show");
        });

        $('.edit_task').click(function(){


            var idx = $(this).data("idx");
            var task = window.gChanges[idx].task;
            var url = "/api/v1/tasks/assignment/" + task.assignmentId + "?taskid=" + task.taskId;
            // Get the task details and then open the editor dialog

            $.ajax({
                url: url,
                dataType: 'json',
                cache: false,
                success: function (data) {
                    var task = data,
                        taskFeature = {
                            geometry: {
                                coordinates: [],
                                type: 'Point'
                            },
                            properties: {}
                        };
                    taskFeature.geometry.coordinates.push(task.lon);
                    taskFeature.geometry.coordinates.push(task.lat);
                    taskFeature.properties.form_id = task.survey_ident;
                    taskFeature.properties.assignee = task.assignee;
                    taskFeature.properties.emails = task.emails;
                    taskFeature.properties.repeat = task.repeat;
                    taskFeature.properties.id = task.id;
                    taskFeature.properties.a_id = task.a_id;

                    editTask(false, task, taskFeature);
                },
                error: function (xhr, textStatus, err) {
                    removeHourglass();
                    if (xhr.readyState == 0 || xhr.status == 0) {
                        return;  // Not an error
                    } else {
                        console.log(localise.set["c_error"] + ": " + err);
                    }
                }
            });
        });
    }

    /*
     * Get the current schdule to date from a task
     */
    function getFinish(data) {
        var events,
            i,
            finish;

        if(data.task) {
            events = data.task.taskEvents;
            // Get the last set finish time
            for(i = events.length - 1; i >= 0; i--) {
                if(events[i].schedule_finish) {
                    finish = events[i].schedule_finish;
                    break;
                }
            }
        }
        return finish;
    }

    /*
     * Get task info
     */
    function getTaskCard(task, index) {
        var h = [],
            idx = -1,
            i,
            events = task.taskEvents,
            addBreak,
            state = getTaskState(task),
            current,
            taskHistory,
            event;

        current = state.current;
        taskHistory = state.history;


        h[++idx] = '<div class="card bg-white">';

        h[++idx] = '<div class="card-header" id="task_heading_';
        h[++idx] = index;
        h[++idx] = '">';
        h[++idx] = '<h5 class="mb-0">';
        h[++idx] = '<button class="btn btn-link card-button" data-toggle="collapse" data-target="#task_collapse_';
        h[++idx] = index;
        h[++idx] = '" aria-expanded="false" aria-controls="task_collapse_';
        h[++idx] = index;
        h[++idx] = '">';

        h[++idx] = localise.set["c_id"];
        h[++idx] = ': ';
        h[++idx] = task.assignmentId;
        if(current.assigned) {
            h[++idx] = '<br/>';
            h[++idx] = localise.set["t_assigned"];
            h[++idx] = ': ';
            h[++idx] = current.assigned;
        }
        if(current.name) {
            h[++idx] = '<br/>';
            h[++idx] = localise.set["c_name"];
            h[++idx] = ': ';
            h[++idx] = current.name;
        }

        h[++idx] = '</button>';
        h[++idx] = '</h5>';
        h[++idx] = '</div>';    // Header

        h[++idx] = '<div id="task_collapse_';
        h[++idx] = index;
        h[++idx] = '" class="collapse change_card" aria-labelledby="task_heading_';
        h[++idx] = index;
        h[++idx] = '">';
        h[++idx] = '<div class="card-body">';

        //----------------- Start card body
        if(taskHistory && taskHistory.length > 0) {
            for(i = events.length - 1; i >= 0; i--) {
                event = taskHistory[i];
                addBreak = false;
                h[++idx] = event.when;
                h[++idx] = '<div class="ml-4">';
                if(event.status) {
                    addBreak = true;
                    h[++idx] = localise.set["c_status"];
                    h[++idx] = ': ';
                    h[++idx] = localise.set[event.status];
                }
                if(event.assigned) {
                    if(addBreak) {
                        h[++idx] = '<br/>';
                    }
                    addBreak = true;
                    h[++idx] = localise.set["t_assigned"];
                    h[++idx] = ': ';
                    h[++idx] = event.assigned;
                }
                if(event.schedule_at) {
                    if(addBreak) {
                        h[++idx] = '<br/>';
                    }
                    addBreak = true;
                    h[++idx] = localise.set["c_from"];
                    h[++idx] = ': ';
                    h[++idx] = event.schedule_at;
                }
                if(event.schedule_finish) {
                    if(addBreak) {
                        h[++idx] = '<br/>';
                    }
                    addBreak = true;
                    h[++idx] = localise.set["c_to"];
                    h[++idx] = ': ';
                    h[++idx] = event.schedule_finish;
                }
                if(event.name) {
                    if(addBreak) {
                        h[++idx] = '<br/>';
                    }
                    addBreak = true;
                    h[++idx] = localise.set["c_name"];
                    h[++idx] = ': ';
                    h[++idx] = event.name;
                }
                h[++idx] = '</div>';
            }
        }
        // ------------ End card body


        h[++idx] = '</div>';        // body
        h[++idx] = '</div>';        // collapse

        h[++idx] = '</div>';        // card


        return h.join('');
    }

    /*
     * Convert task events into a task state
     */
    function getTaskState(task) {

        var i,
            events = task.taskEvents,
            event,
            historyItem,
            state = {
                current: {},
                history: []
            };


        if(events && events.length > 0) {

            // Set current starting from the latest
            for(i = events.length - 1; i >= 0; i--) {
                event = events[i];

                if (i == events.length - 1) {
                    state.current = JSON.parse(JSON.stringify(event))
                } else {
                    if (!state.current.status) {
                        state.current.status = event.status;
                    }
                    if (!state.current.assigned) {
                        state.current.assigned = event.assigned;
                    }
                    if (!state.current.name) {
                        state.current.name = event.name;
                    }
                }
            }

            if (state.current.name && state.current.name.indexOf(':') > 0) {
                state.current.name = state.current.name.substring(0, state.current.name.indexOf(':'));
            }

            // Set history starting from the first and only recording changes
            for(i = 0; i < events.length; i++) {

                event = events[i];
                historyItem = {};

                historyItem.when = localTime(event.when);

                if(i == 0 || event.status !== events[i - 1].status) {
                    historyItem.status = event.status;
                }
                if(i == 0 || event.assigned !== events[i - 1].assigned) {
                    historyItem.assigned = event.assigned;
                }
                if(i == 0 || event.schedule_at !== events[i - 1].schedule_at) {
                    historyItem.schedule_at = localTime(event.schedule_at);
                }
                if(i == 0 || event.schedule_finish !== events[i - 1].schedule_finish) {
                    historyItem.schedule_finish = localTime(event.schedule_finish);
                }

                // We only need the name up to the first ":".  If the name has colons in it then it has probably been created
                // automatically from existing data using project name and survey name.  However for the per record view just the
                // Task group name is enough
                if(i == 0 || event.name !== events[i - 1].name) {
                    historyItem.name = event.name;
                    if (historyItem.name && historyItem.name.indexOf(':') > 0) {
                        historyItem.name = historyItem.name.substring(0, historyItem.name.indexOf(':'));
                    }
                }

                state.history.push(historyItem);
            }
        }
        return state;
    }
    /*
     * Get notification info
     */
    function getNotificationInfo(n, description) {
        var h = [],
            idx = -1;

        h[++idx] = '<p>';
        h[++idx] = localise.set["c_target"];
        h[++idx] = ': ';
        h[++idx] = n.target;
        h[++idx] = '<br/>';

        h[++idx] = localise.set["c_to"];
        h[++idx] = ': ';
        h[++idx] = n.emails ? n.emails.join(',') : '';
        h[++idx] = '<br/>';

        if(description) {
            h[++idx] = description;
            h[++idx] = '<br/>';
        }
        h[++idx] = '</p>';

        return h.join('');

    }

    /*
     * Convert a list of changes into a bs4 card
     */
    function getChangeCard(changes, index) {
        var h = [],
            idx = -1,
            i, j;

        h[++idx] = '<div class="card bg-white">';

        h[++idx] = '<div class="card-header" id="heading_';
        h[++idx] = index;
        h[++idx] = '">';
        h[++idx] = '<h5 class="mb-0">';
        h[++idx] = '<button class="btn btn-link card-button" data-toggle="collapse" data-target="#collapse_';
        h[++idx] = index;
        h[++idx] = '" aria-expanded="false" aria-controls="collapse_';
        h[++idx] = index;
        h[++idx] = '">';
        h[++idx] = changes.length + ' '  + localise.set["c_changes"];
        h[++idx] = '</button>';
        h[++idx] = '</h5>';
        h[++idx] = '</div>';    // Header

        h[++idx] = '<div id="collapse_';
        h[++idx] = index;
        h[++idx] = '" class="collapse change_card" aria-labelledby="heading_';
        h[++idx] = index;
        h[++idx] = '">';
        h[++idx] = '<div class="card-body">';

        var baseUrl = window.location.protocol + "//" + window.location.host + "/";
        for(i = 0; i < changes.length; i++)  {

            h[++idx] = '<div class="row mt-1">';

            var type = changes[i].type;
            if(type === 'begin repeat') {
                var changeArray = changes[i].changes;
                var id;

                h[++idx] = '<div class="col-md-12">';

                // Add the tab nav links
                h[++idx] = '<ul class="nav nav-tabs" role="tablist">';
                for(j = 0; j < changeArray.length; j++) {
                    id = i + '_' + j;

                    h[++idx] = '<li class="nav-item">';
                        h[++idx] = '<a class="nav-link ';
                        if(j == 0) {
                            h[++idx] = 'active';
                        }
                        h[++idx] = '" id="chgtab_';
                        h[++idx] = id;
                        h[++idx] = '" data-toggle="tab" href="#chgpanel_';
                        h[++idx] = id;
                        h[++idx] = '" role="tab" aria-controls="chgpanel_';
                        h[++idx] = id;
                        h[++idx] = '" aria-selected="';
                        if(j == 0) {
                            h[++idx] = 'true';
                        } else {
                            h[++idx] = 'false';
                        }
                        h[++idx] = '">';
                        h[++idx] = j;
                        h[++idx] = '</a>';
                    h[++idx] = '</li>';
                }
                h[++idx] = '</ul>';

                // Add the tab panels
                h[++idx] = '<div class="tab-content">';

                for(j = 0; j < changeArray.length; j++) {
                    id = i + '_' + j;

                    h[++idx] = '<div class="tab-pane fade';
                    if(j == 0) {
                        h[++idx] = ' show active';
                    }
                    h[++idx] = '" id="chgpanel_';
                    h[++idx] = id;
                    h[++idx] = '" role="tabpanel" aria-labelledby="chgtab_';
                    h[++idx] = id;
                    h[++idx] = '">';
                    h[++idx] = getChangeCard(changeArray[j], id);
                    h[++idx] = '</div>';
                }
                h[++idx] = '</div>';        // Tab content
                h[++idx] = '</div>';        // The column


            } else {

                var newVal = changes[i].newVal;
                var oldVal = changes[i].oldVal;
                if(type === 'image') {
                    newVal = baseUrl + newVal;
                    oldVal = baseUrl + oldVal;
                }

                if(type === 'geopoint' || type === 'geoshape' || type === 'geotrace' || type === 'geocompund') {
                    h[++idx] = actioncommon.addCellMap(true, 'change_maps_',
                        globals.gRecordChangeMaps, changes[i], newVal, oldVal);
                } else {

                    h[++idx] = '<div class="col-md-3">';
                    if(changes[i].displayName) {
                        h[++idx] = htmlEncode(changes[i].displayName);
                    } else {
                        h[++idx] = htmlEncode(changes[i].col);
                    }
                    h[++idx] = '</div>';

                    h[++idx] = '<div class="col-md-4">';
                    h[++idx] = actioncommon.addCellMarkup(oldVal);
                    h[++idx] = '</div>';

                    h[++idx] = '<div class="col-md-1">';        // Separator
                    h[++idx] = '<i class="fa fa-arrow-right" aria-hidden="true"></i>';
                    h[++idx] = '</div>';

                    h[++idx] = '<div class="col-md-4">';
                    h[++idx] = actioncommon.addCellMarkup(newVal);
                    h[++idx] = '</div>';
                }
            }

            h[++idx] = '</div>';        // row
        }


        h[++idx] = '</div>';        // body
        h[++idx] = '</div>';        // collapse

        h[++idx] = '</div>';        // card

        return h.join('');
    }


    function getData(sId, oversightSurvey, subForm, callback, clearCache) {

    	var filter;

	    var url = '/api/v1/data/';
	    url += sId;
	    url += "?mgmt=true";

	    if (oversightSurvey) {
		    url += "&oversightSurvey=" + oversightSurvey;
	    }

	    if(subForm) {
		    url += "&form=" + subForm;

		    // Check for drill down
		    if(gDrillDownStack.length > 0) {
			    url += "&parkey=" + gDrillDownStack[gDrillDownStack.length - 1].record;
		    }
	    }

	    if (isDuplicates) {
		    url += "&group=true";
	    }

	    if(globals.gCurrentInstance) {
		    url += "&instanceid=" + globals.gCurrentInstance;
	    }

	    /*
		 * date filtering
		 */
	    if(!gGetSettings) {
		    var fromDate = document.getElementById('filter_from').value,
			    toDate = document.getElementById('filter_to').value,
			    dateName = $('#date_question').val();
		    var dateSet = (fromDate && fromDate.trim().length) || (toDate && toDate.trim().length);

		    if (dateSet && dateName && dateName.trim().length) {
			    url += "&dateName=" + dateName;
			    if (fromDate && fromDate.trim().length) {
				    url += "&startDate=" + fromDate;
			    }
			    if (toDate && toDate.trim().length) {
				    url += "&endDate=" + toDate;
			    }
		    }

		    if($('#include_bad').prop('checked')) {
			    url += "&bad=yes";
		    }
            if($('#include_completed').prop('checked')) {
                url += "&completed=yes";
            } else {
                url += "&completed=no";
            }

		    // Limit number of records returned
		    var limit = $('#limit').val();
		    var iLimit = 0;
		    if (limit && limit.trim().length > 0) {
			    try {
				    iLimit = parseInt(limit);
				    url += "&limit=" + iLimit;
			    } catch (err) {
				    alert(err);
			    }
		    }

		    // Advanced filter
		    filter = $('#advanced_filter').val();
		    // Apply combined filter
		    if (filter && filter.trim().length > 0) {
			    url += "&filter=" + encodeURIComponent(filter);
		    }

		    // Drill Down Filters for launched forms
		    if(gDrillDownStack.length > 0) {
			    var stackObj = gDrillDownStack[gDrillDownStack.length - 1];

			    if(stackObj.type === "child_form" && stackObj.key) {
			        /*
			         * The filter will select those records where the key question is equal to either the
			         * primary key of this survey or its key
			         */
			        var filter = "(${" + stackObj.key + "} = '" + stackObj.record + "'";
			        if(stackObj.key_value) {
			            filter += "or ${" + stackObj.key + "} = '" + stackObj.key_value + "')"
                    } else {
			            filter += ")";
                    }
				    url += "&dd_filter=" + encodeURIComponent(filter);
			    } else if(stackObj.type === "parent_form" && stackObj.key) {
			        var keyValue = gTasks.gSelectedRecord[stackObj.key];

			        if(keyValue) {
                        if (stackObj.key_value) {
                            url += "&dd_hrk=" + keyValue;
                        }
                    }
                }
		    }


	    } else {
		    url += "&getSettings=true";
	    }

	    url += "&format=dt";
	    url += "&schema=true";
	    url += "&view=0";                       // TODO
	    url += "&merge_select_multiple=yes";
	    url += "&sort=prikey&dirn=desc";

	    url += "&tz=" + encodeURIComponent(globals.gTimezone);

	    // First Check the Cache
	    if(!clearCache && gTasks.cache.data[url]) {
		    gTasks.cache.currentData = gTasks.cache.data[url];
            callback(gTasks.cache.data[url]);
            updateSettings(gTasks.cache.currentData.settings);
            map.setLayers(gTasks.cache.currentData.schema.layers);
            updateFormList(gTasks.cache.currentData.forms);
            updateCharts(gTasks.cache.currentData.settings.charts);
	    } else {

		    addHourglass();
		    $.ajax({
			    url: url,
			    dataType: 'json',
			    cache: false,
			    success: function (data) {
				    removeHourglass();
				    gRefreshingData = false;
				    gGetSettings = false;

				    var theCallback = callback;
				    if(data && data.status === "error") {
					    alert(data.msg);
					    clearTable();
					    return;
				    } else if(data.data && data.data[0] && data.data[0].status === "error") {
					    alert(data.data[0].msg);
					    clearTable();
					    return;
				    } else if(data && data.status === "ok") {
					    // Continue presumably there is no data
					    clearTable();
					    return;
				    } else {
					    var theKey = url;

					    gTasks.cache.data[theKey] = data;
					    gTasks.cache.currentData = data;

					    updateSettings(gTasks.cache.currentData.settings);
					    map.setLayers(gTasks.cache.currentData.schema.layers);
					    updateFormList(gTasks.cache.currentData.forms);
                        updateCharts(gTasks.cache.currentData.settings.charts);

					    // Add a config item for the group value if this is a duplicates search
					    if (isDuplicates) {
						    gTasks.cache.currentData.schema.columns.unshift({
							    hide: true,
							    include: true,
							    column_name: "_group",
							    displayName: "_group"
						    });
					    }

					    // Initialise the column settings
					    initialiseColumns();

					    theCallback(data);
				    }
			    },
			    error: function (xhr, textStatus, err) {
				    removeHourglass();

				    if (globals.gMainTable) {
					    globals.gMainTable.destroy();
					    globals.gMainTable = undefined;
				    }
				    $("#trackingTable").empty();

				    gRefreshingData = false;
				    gGetSettings = false;

				    if (xhr.readyState == 0 || xhr.status == 0) {
					    return;  // Not an error
				    } else {
					    alert(localise.set["error"] + ": " + err);
				    }
			    }
		    });
        }


    }

    function tableOnDraw() {
        var i;

        if(!globals.gMainTable) {
            return;     // Table not ready
        }

        gDeleteColumn = -1;
        gDeleteReasonColumn = -1;

        if (isDuplicates) {

            var rows = globals.gMainTable.rows({page: 'current'}).nodes();
            var last = null;

            globals.gMainTable.column(0, {page: 'current'}).data().each(function (group, i) {
                if (group && last !== group) {
                    $(rows).eq(i).before(
                        '<tr class="group" style="background-color: #CCC;"><td colspan="5">' + group + '</td></tr>'
                    );

                    last = group;
                }
            });
        }

        var columns = gTasks.cache.currentData.schema.columns;

        for (i = 0; i < columns.length; i++) {
            var headItem = columns[i];

            // Highlighting
            if (headItem.markup) {
                $(globals.gMainTable.column(i).nodes()).each(function (index) {
                    var $this = $(this),
                        v = $this.text();

                    for (var j = 0; j < headItem.markup.length; j++) {
                        if (headItem.markup[j].value == v) {
                            $this.addClass(getColorClass(headItem.markup[j].classes));
                        }
                    }
                });
            }

            // Barcode
            if (headItem.barcode) {
                $(globals.gMainTable.column(i).nodes()).each(function (index) {
                    var $this = $(this),
                        opt = {
                            render: 'div',
                            size: 100,
                            text: $this.text()
                        }

                    $this.empty().qrcode(opt);

                });
            }

            // Deleted
            if(headItem.del_col) {
                gDeleteColumn = i;
                $(globals.gMainTable.column(i).nodes()).each(function (index) {
                    var $this = $(this);
                    if($this.text() === "t") {
                        $this.text(localise.set["c_yes"]);
                        $this.addClass('bg-danger');
                    } else  if($this.text() === "f") {
                        $this.text(localise.set["c_no"]);
                    }
                });
            } else if(headItem.del_reason_col) {
                gDeleteReasonColumn = i;
            }
        }

        // Refresh the views that depend on the displayed rows
        map.refreshAllLayers(gMapView, gOverallMapConfig.map);
        chart.refresh();

        if(gTasks.gBulkInstances && gTasks.gBulkInstances.length) {
            for(i = 0; i < gTasks.gBulkInstances.length; i++ ) {
                globals.gMainTable.row('#' + escSelector(gTasks.gBulkInstances[i])).select();      // Reselect the row, escape the :
            }
        }
    }

    function getColorClass(color) {
        if(color === 'yellow') {
            return 'bg-warning';
        } else if(color === 'blue') {
            return 'bg-info';
        } else if(color === 'red') {
            return 'bg-danger';
        } else if(color === 'red') {
            return 'bg-danger';
        } else if(color === 'green') {
            return 'bg-success';
        }
    }

    /*
     * If settings were requested from the server then update the setting fields
     */
    function updateSettings(settings) {
        if(settings) {

            $('#filter_from').val(settings.startDate);
            $('#filter_to').val(settings.toDate);
            $('#date_question').val(settings.dateName);
            $('#limit').val(settings.limit);
            $('#advanced_filter').val(settings.filter);
            $('#include_bad').prop('checked', settings.include_bad === "yes");
            $('#include_completed').prop('checked', settings.include_completed === "yes");
        }
    }

    /*
     * Show a records details
     */
    function showRecord(editable) {

        window.location.hash="#edit";
        $('.shareRecordOnly, .role_select').hide();
        $('#srLink').val("");
        getSurveyRoles(globals.gCurrentSurvey);
        getRecordChanges(gTasks.gSelectedRecord);

        var sIdent = gTasks.cache.surveyList[globals.gCurrentProject][gTasks.gSelectedSurveyIndex].ident;
        var instanceId = gTasks.gSelectedRecord.instanceid;
        $('.launchwebform').prop("href", "/app/myWork/webForm/" + sIdent + "?datakey=instanceid&datakeyvalue=" + instanceId);

        $('.overviewSection').hide();
        $('.editRecordSection').show();

        if(editable) {
            $('.saverecord').removeClass('disabled');
        } else {
            $('.savercord').addClass('disabled');
        }
        actioncommon.showEditRecordForm(gTasks.gSelectedRecord, gTasks.cache.currentData.schema, $('#editRecordForm'), $('#surveyForm'), editable, true);
    }

    /*
     * Open a page for bulk editing
     */
    function showBulkEdit() {

        window.location.hash="#bulk";
        $('.shareRecordOnly, .role_select').hide();
        $('#srLink').val("");
        getSurveyRoles(globals.gCurrentSurvey);

        //var sIdent = gTasks.cache.surveyList[globals.gCurrentProject][gTasks.gSelectedSurveyIndex].ident;


        $('.overviewSection').hide();
        $('.bulkEditSection').show();

        actioncommon.showBulkEditForm(gTasks.gSelectedRecord, gTasks.cache.currentData.schema, $('#bulkEditForm'));
    }


    /*
     * -------------------------------------------------------------------------------------
     * Task management functions copied from taskManagement.js
     * (Some of) this duplication should be fixed but will require selection of a single map API
     */

    /*
     * Add a task
	 */
    $('#addTask').click(function () {

        // TODO default location to location of record
        var task = {},
            taskFeature = {
                geometry: {
                    coordinates: [],
                    type: 'Point'
                },
                properties: {}
            };

        editTask(true, task, taskFeature);
    });

    $('#addNotification').click(function(){
        edit_notification(false, -1, true);
        $('#addNotificationPopup').modal("show");
    });

    /*
	 * Edit an existing task or create a new one
	 */
    function editTask(isNew, task, taskFeature) {
        var scheduleDate,
            splitDate = [];

        console.log("open edit task: " + task.from);

        window.gCurrentTaskFeature = taskFeature;

        $('form[name="taskProperties"]')[0].reset();

        if (isNew) {
            $('#taskPropLabel').html(localise.set["t_add_task"]);
            $('#tp_pol').prop('checked', true);
            $('#tp_assign_auto').prop('checked', false);

        } else {
            $('#taskPropLabel').html(localise.set["t_edit_task"]);
            $('#tp_pol').prop('checked', task.complete_all);
            $('#tp_assign_auto').prop('checked', task.assign_auto);
        }

        /*
		 * Set up data
		 */
        $('#tp_repeat').prop('checked', task.repeat);
        $('#tp_pol').prop('checked', task.complete_all);
        $('#tp_assign_auto').prop('checked', task.assign_auto);
        $('#tp_name').val(task.name);		// name
        if(isNew) {
            $('#tp_form_name').val($('#tp_form_name option:first').val());
        } else {
            $('#tp_form_name').val(taskFeature.properties.form_id);	// form id
        }
        setupAssignType(taskFeature.properties.assignee, 0, taskFeature.properties.emails, taskFeature.properties.assign_data);
        $('#tp_user').val(taskFeature.properties.assignee);	// assignee
        $('#tp_assign_emails').val(taskFeature.properties.emails);
        $('#tp_repeat').prop('checked', taskFeature.properties.repeat);
        $('#tp_pol').prop('checked', taskFeature.properties.complete_all);
        $('#tp_assign_auto').prop('checked', taskFeature.properties.assign_auto);

        // Set end date first as otherwise since it will be null, it will be defaulted when from date set
        if (task.to) {
            $('#tp_to').data("DateTimePicker").date(localTime(task.to));
        }
        if (task.from) {
            $('#tp_from').data("DateTimePicker").date(localTime(task.from));
        }

        $('#nfc_uid').val(task.location_trigger);
        gCurrentGroup = task.location_group;
        gCurrentLocation = getLocationIndex(task.location_name, gTags);
        if(gCurrentGroup && gCurrentGroup != '') {
            $('.location_group_list_sel').text(gCurrentGroup);
            setLocationList(gTags, gCurrentLocation, gCurrentGroup);
        }

        if(task.guidance) {
            $('#tp_guidance').val(task.guidance);
        } else {
            $('#tp_guidance').val(task.address);    // Initialise with address data
        }
        if (task.update_id && task.update_id.length > 0) {
            $('#initial_data').html(getInitialDataLink(taskFeature));
        }
        $('#tp_show_dist').val(task.show_dist);

        $('#location_save_panel').hide();
        $('#task_properties').modal("show");

        if (!gModalMapInitialised) {
            setTimeout(function () {
                map.initDynamicMap(gTaskMapConfig, true, undefined, false);
            }, 0);
            gModalMapInitialised = true;
        } else {
            //gClickOnMapenabled = false;     // TODO
            //modalMapReady();
        }

    }

    /*
	 * Callback after saving a task
	 */
    function doneTaskSave() {
        getRecordChanges(gTasks.gSelectedRecord);
        getLocations(processLocationList);
    }

    /*
	 * Process a list of locations
	 */
    function processLocationList(tags) {
        gTags = tags;
        gCurrentGroup = refreshLocationGroups(tags, true, gCurrentGroup);
        setLocationList(tags, gCurrentLocation, gCurrentGroup);

        // Respond to a location group being selected
        $('.dropdown-item', '#location_group').click(function () {
            gCurrentGroup = $(this).text();
            gCurrentLocation = '-1';
            $('.location_group_list_sel').text(gCurrentGroup);
            setLocationList(gTags, gCurrentLocation, gCurrentGroup);
        });
    }

    /*
     * Save a notification
     */
    function sendImmediateNotification() {

        var url,
            notification,
            $dialog,
            notificationString,
            target = $('#target').val();

        if(target === "email") {
            notification = saveEmail();
        } else if(target === "forward") {
            notification = saveForward();
        } else if(target === "sms") {
            notification = saveSMS();
        } else if(target === "document") {
            notification = saveDocument();
        }

        if(!notification.error) {

            notification.trigger = $('#trigger').val();
            notification.sIdent = $('#survey').val();
            notification.enabled = $('#nt_enabled').is(':checked');
            notification.filter = $('#not_filter').val();
            notification.name = $('#name').val();
            notification.instanceId = gTasks.gSelectedRecord.instanceid;

            if(notification.trigger === 'task_reminder') {
                var idx = $('#task_group').val();
                if(gTaskGroups.length > 0 && idx < gTaskGroups.length) {
                    notification.tgId = gTaskGroups[idx].tg_id;
                }
                var periodCount = $('#r_period').val();
                notification.period = periodCount + ' ' + $('#period_list_sel').val();

                // Validate
                if(!periodCount || periodCount <= 0) {
                    alert(localise.set["msg_pc"]);
                    return(-1);
                }
                console.log("Reminder for tg: " + notification.tgId + ' after ' + notification.period);
            }

            url = "/surveyKPI/notifications/immediate";

            notificationString = JSON.stringify(notification);
            $dialog = $(this);
            addHourglass();
            $.ajax({
                type: "POST",
                dataType: 'text',
                cache: false,
                async: false,
                url: url,
                data: { notification: notificationString },
                success: function(data, status) {
                    removeHourglass();
                    $('#addNotificationPopup').modal("hide");
                },
                error: function(xhr, textStatus, err) {
                    removeHourglass();
                    if(xhr.readyState == 0 || xhr.status == 0) {
                        return;  // Not an error
                    } else {
                        alert(localise.set["msg_err_save"] + xhr.responseText);
                    }
                }
            });

        } else {
            alert(localise.set["msg_inv_email"]);
        }
    }

    function escSelector(input) {
        var output = input.replace(/:/g, '\\:');
        console.log(output);
        return output;
    }

    function toggleRecord(title, bad) {
        var columns = gTasks.cache.currentData.schema.columns;

        gBad = bad;

        if(gDeleteReasonColumn >= 0) {
            $('#toggle_reason').val(gTasks.gSelectedRecord[columns[gDeleteReasonColumn].displayName]);
        } else {
            $('#toggle_reason').val("");
        }
        $('#toggleRecordTitle, #toggleRecordSave').text(title);
        $('#toggleRecord').modal("show");
    }

    function clearTable() {
        if ( $.fn.dataTable.isDataTable( $("#trackingTable")) && globals.gMainTable) {
            globals.gMainTable.destroy();
        }
        $("#trackingTable").empty()
    }

    function clearDrillDown() {
	    $('.dd_only,.du_only').hide();
        gDrillDownNext = undefined;
	    gDrillDownStack = [];
    }

    function drillDown() {
        var form = $('#dd_form').html();
        if(form !== "") {

            gDrillDownNext.record = gTasks.gSelectedRecord.prikey;
            if (gDrillDownNext.type === 'child_form') {
                gDrillDownNext.key_value = gTasks.gSelectedRecord._hrk;     // Drill down to child using HRK of this, the parent form
            } else {
                gDrillDownNext.key_value = gTasks.gSelectedRecord[gDrillDownNext.key];     // Drill down to parent using its HRK, this is the child form
            }

            // Set the key_value to undefined if it is zero length
	        if(gDrillDownNext.key_value && gDrillDownNext.key_value.length === 0) {
                gDrillDownNext.key_value = undefined;
            }

            gDrillDownStack.push(gDrillDownNext);

	        updateDrillDownFormList();
	        if(gDrillDownNext) {
	        	$('.dd_only').show();
	        }

            subFormChanged();

            $('.du_only').show();
        }
    }

});



define("../managed_forms", function(){});

